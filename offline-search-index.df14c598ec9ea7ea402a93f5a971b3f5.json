[{"body":"Hugo / Docsy The documentation system is built using Hugo with the Docsy theme. Content is written in Markdown format. General information is available at these links:\nHugo Docsy Markdown : Basic Syntax Extended Syntax Markdown Cheatsheet with GitHub flavour Hugo Page Bundles Most of the content is pulled from other Git Repos and mounted into the content directory. Therefore, the same documentation may be reused in several documentation systems.\nContent Organisation Warning: Hugo content organisation is not always explained well. For instance, “leaf means it has no children”, really does not explain what a leaf is … and since when do leaves have children? or not have them? This post is helpful if you suspect that the Hugo documentation seems to be missing the point.\nIn Hugo, content is organised as Page Bundles, which are, in turn collections of Page Resources. Page bundles are simply a collection of related files (i.e. page resources) all placed in the same directory. Page bundles may either be a Leaf Bundle (directory contains file index.md) or a Branch Bundle (directory contains file _index.md). A simple Page can be difficult to work with, especially if your content includes images.\ncontent/ └── docs ├── page.md \u003c-- page ├── leaf \u003c-- page bundle, specifically a leaf bundle │ ├── leaf.jpg │ └── index.md └── branch \u003c-- page bundle, specifically a branch bundle ├── page-1.md ├── page-2.md ├── branch.jpg └── _index.md In terms of arranging content, a Branch Bundle may contain other Bundles (Branch or Leaf), where as a Leaf Bundle may not contain other Bundles. This arrangement is reflected in the structure of the site.\nDoc Generation Several Repos/Projects have generated documentation. This documentation is updated with the following generalised process:\nUpdate documentation in the source files.\nRun the make generate Makefile target to update the generated content.\nCommit the updated content and push the changes upstream.\nWhen the documentation is ready, tag a “patch” release on the Repo, the next time the documentation system updates, it will fetch the updated content.\nEach of the generated documentation formats/systems are explained in the following sections.\nC based API Documentation Markdown format documentation, embedded in C comment blocks. CDocGen toolchain for generation of documentation (tools/cdocgen). PlantUML images generated from embedded diagrams (tools/plantuml). Examples read from source files, and also included in build for quality assurance of example code. YAML based Schema Documentation OpenAPI schema definition with embedded documentation (including examples). Validation (swagger) and generation (widdershins). Additional templating (adding Hugo metadata) with sed. ","categories":"","description":"","excerpt":"Hugo / Docsy The documentation system is built using Hugo with the …","ref":"/dse.doc/docs/devel/documentation/","tags":"","title":"Documentation Systems"},{"body":"Documentation.\n","categories":"","description":"","excerpt":"Documentation.\n","ref":"/dse.doc/docs/","tags":"","title":"Documentation"},{"body":"Dynamic Simulation Environment - User Guides for Models.\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - User Guides for Models.\n","ref":"/dse.doc/docs/user/models/","tags":"","title":"User Guide - Models"},{"body":"Dynamic Simulation Environment - User Guides for Tools.\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - User Guides for Tools.\n","ref":"/dse.doc/docs/user/tools/","tags":"","title":"User Guide - Tools"},{"body":"Dynamic Simulation Environment - User Guide.\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - User Guide.\n","ref":"/dse.doc/docs/user/","tags":"","title":"User Guide"},{"body":"Schema documentation.\n","categories":"","description":"","excerpt":"Schema documentation.\n","ref":"/dse.doc/schemas/","tags":"","title":"Schemas"},{"body":"Dynamic Simulation Environment - Architecture Documents\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - Architecture Documents\n","ref":"/dse.doc/docs/arch/","tags":"","title":"Architecture Documents"},{"body":"API Documentation.\n","categories":"","description":"","excerpt":"API Documentation.\n","ref":"/dse.doc/apis/","tags":"","title":"APIs"},{"body":"Dynamic Simulation Environment - Developer Documentation\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - Developer Documentation\n","ref":"/dse.doc/docs/devel/","tags":"","title":"Developer Documentation"},{"body":"ModelC API Reference ","categories":"","description":"","excerpt":"ModelC API Reference ","ref":"/dse.doc/apis/modelc/","tags":"","title":"ModelC API Reference"},{"body":"C Lib API Reference ","categories":"","description":"","excerpt":"C Lib API Reference ","ref":"/dse.doc/apis/clib/","tags":"","title":"C Lib API Reference"},{"body":"Synopsis The Dynamic Simulation Environment (DSE) presents models with a simple vector interface for the exchange of signals. Those signals can be either:\nscalar : Internally represented as a 64bit storage container (double). These values are transparently exchanged between models, and those models may cast the values to other types (as required by the simulation designer). binary : Binary strings (i.e. including embedded NULL characters) can be exchanged between models, and with an associated MIME type, complex bus simulations can be realised. An associated API can be used to access signal vectors:\n#include \u003cdse/modelc/model.h\u003e int model_function(ModelInstanceSpec* mi) { SignalVector* sv = model_sv_create(mi); while (sv \u0026\u0026 sv-\u003ename) { for (uint i = 0; i++; i \u003c sv-\u003ecount) { if (sv-\u003eis_binary) { sv-\u003ereset(sv, i); sv-\u003eappend(sv, i, \"hello world\", 12); printf(\"%s = %f (%s)\\n\", sv-\u003esignal[i], sv-\u003ebinary[i], sv-\u003emime_type[i]); } else { printf(\"%s = %f\\n\", sv-\u003esignal[i], sv-\u003escalar[i]); } } /* Next signal vector. */ sv++; } } Scalar Signal Vector Scalar signal vectors are used by models to exchange signal values. Those values of a scalar signal vector are represented internally as 64bit storage container (double), and they are transparently exchanged between models. Models can cast these values to any scalar data type as required.\nTip When casting scalar values, use a signal annotation to describe the type cast which should be used. That way, simulation integrators and other model developers will be aware of how the signal value should be interpreted. API Methods /* Access signal annotations. */ const char* value = sv-\u003eannotation(sv, i, \"name\"); Configuration Scalar signal vectors are represented by a SignalGroup YAML document. Individual signals may have additional annotations which can be used to describe the behaviour or properties of the signal - those annotations may be interpreted by a model which uses those signals.\nScalar Signal Vector :\nkind: SignalGroup metadata: name: scalar spec: signals: - signal: foo - signal: bar annotations: type-cast: int32 Binary Signal Vector Binary signal vectors are used by models to exchange binary data, the effect of which is to create binary data streams between models. When associated with a MIME type, complex communication protocols can be realised (e.g. CAN Bus simulation). When several models exchange binary data values for the same signal, each of those values will be consolidated into a single value which represents a binary stream, and that consolidated value is exchanged between all models.\nBecause the binary signals may represent variable length data objects, there are a collection of API Methods available to reliably interface with this vector type.\nAPI Methods /* Work with a binary signal. */ sv-\u003ereset(sv, i); /* Reset the binary signal (i.e. length = 0). */ sv-\u003eappend(sv, i, data, length); /* Append data to the signal. */ sv-\u003erelease(sv, i); /* Free the memory buffer of a binary signal. */ /* Access signal annotations. */ const char* value = sv-\u003eannotation(sv, i, \"name\"); Tip Generally calling sv-\u003erelease() is not necessary and, if avoided, will result in less memory allocation overhead during model runtime. Configuration Binary signal vectors are represented by a SignalGroup YAML document with a metadata annotation vector_type: binary. Each signal of a binary signal vector should also have an annotation mime_type which describes the binary data. The default value provided by the Signal Vector API is application/octet-stream (which, from a system integration perspective, is almost totally useless).\nIndividual signals may have additional annotations which can be used to describe the behaviour or properties of the signal - those annotations may be interpreted by a model which uses those signals.\nBinary Signal Vector :\nkind: SignalGroup metadata: name: binary annotations: vector_type: binary spec: signals: - signal: foo annotations: mime_type: 'application/octet-stream; interface=parameter; file=calibration.csv' - signal: bar annotations: mime_type: 'application/x-automotive-bus; interface=stream; type=frame; schema=fbs' References dse/modelc/model.h - definition of Signal Vector API. SignalGroup schema definition. DSE Model C examples: Binary Model Gateway Model Frame Stream Interface (Automotive Bus) with sample code. ","categories":"","description":"","excerpt":"Synopsis The Dynamic Simulation Environment (DSE) presents models with …","ref":"/dse.doc/docs/arch/signalvector/","tags":["ModelC","Architecture"],"title":"Signal Vectors"},{"body":"Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway API which can be used to connect remote simulations, via a gateway model, to a running DSE simulation. A gateway model takes care of signal exchange and time synchronisation between the remote simulation and the DSE simulation. Signals can be either scalar values or binary strings, the latter enabling virtual bus connections between simulation environments.\nThe gateway model runs in the remote simulation, and is written in that systems native language (or modelling construct). Connections from the gateway model to the DSE simulation are implemented with platform independent protocols, the resultant distributed simulation may combine any number of operating systems and processor architectures.\n#include \u003cdse/modelc/gateway.h\u003e /* Setup the gateway. */ ModelGatewayDesc gw; model_gw_setup(\u0026gw, \"gateway\", yaml_files, LOG_INFO, step_size, end_time); /* Run the simulation. */ while (model_time \u003c= end_time) { marshal_signal_vectors_out(gw-\u003esv); int rc = model_gw_sync(\u0026gw, model_time); marshal_signal_vectors_in(gw-\u003esv); ... } /* Exit the simulation. */ model_gw_exit(\u0026gw); Design Deployment A generalised deployment showing how a remote simulation is connected to a DSE simulation using a gateway model. Each simulation has several models, synchronisation and signal exchange are achieved via the gateway model.\nGateway Model Deployment\nSequence Diagram The following diagram shows how a gateway model running in a remote simulation interacts with a DSE simulation.\nGateway Model Sequence Diagram\nReferences dse/modelc/gateway.h - Gateway API header file. dse/modelc/model/gateway.c - Gateway API implementation and documentation. dse/modelc/examples/gateway - Example gateway model. ","categories":"","description":"","excerpt":"Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway …","ref":"/dse.doc/docs/arch/clib.fmi/","tags":["ModelC","Architecture"],"title":"Gateway Models"},{"body":"Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway API which can be used to connect remote simulations, via a gateway model, to a running DSE simulation. A gateway model takes care of signal exchange and time synchronisation between the remote simulation and the DSE simulation. Signals can be either scalar values or binary strings, the latter enabling virtual bus connections between simulation environments.\nThe gateway model runs in the remote simulation, and is written in that systems native language (or modelling construct). Connections from the gateway model to the DSE simulation are implemented with platform independent protocols, the resultant distributed simulation may combine any number of operating systems and processor architectures.\n#include \u003cdse/modelc/gateway.h\u003e /* Setup the gateway. */ ModelGatewayDesc gw; model_gw_setup(\u0026gw, \"gateway\", yaml_files, LOG_INFO, step_size, end_time); /* Run the simulation. */ while (model_time \u003c= end_time) { marshal_signal_vectors_out(gw-\u003esv); int rc = model_gw_sync(\u0026gw, model_time); marshal_signal_vectors_in(gw-\u003esv); ... } /* Exit the simulation. */ model_gw_exit(\u0026gw); Design Deployment A generalised deployment showing how a remote simulation is connected to a DSE simulation using a gateway model. Each simulation has several models, synchronisation and signal exchange are achieved via the gateway model.\nGateway Model Deployment\nSequence Diagram The following diagram shows how a gateway model running in a remote simulation interacts with a DSE simulation.\nGateway Model Sequence Diagram\nReferences dse/modelc/gateway.h - Gateway API header file. dse/modelc/model/gateway.c - Gateway API implementation and documentation. dse/modelc/examples/gateway - Example gateway model. ","categories":"","description":"","excerpt":"Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway …","ref":"/dse.doc/docs/arch/gateway/","tags":["ModelC","Architecture"],"title":"Gateway Models"},{"body":" Dynamic Simulation Environment The Dynamic Simulation Environment is a message based distributed simulation platform which defines the interface between models as signal vectors. Signal vectors are a logical grouping of either scalar or binary data which are exchanged between models at discrete points in time. Models may be developed in any programming language and may run on any operating system or hardware platform.\nSimulations are constructed using models with a compositional approach, where system elements represented by the simulation are decomposed/recomposed from a collection of models according the broader simulation objectives. This compositional approach to simulation, called Functional Simulation (FSIL), supports the development of a variety of simulation strategies.\nThe Dynamic Simulation Environment (DSE) can be used to integrate legacy tools into a simulation, such integration techniques include; Gateway models which connect remote systems to a DSE simulation; and Model Compatibility Libraries which import foreign models into a DSE simulation. Several Gateway and Model Compatibility Libraries are available alongside the Model C Library, our C based implementation of the Dynamic Simulation Environment.\nMessages The Dynamic Simulation Environment uses a distributed algorithm, based upon a small set of messages, which facilitate control and execution of simulations. Using those messages (and the associated distributed algorithm) a variety of simulation capabilities can be realised, including: Co-simulation, Federated (distributed) simulations, Cross-Platform simulations.\nThe Messages of the Dynamic Simulation Environment are used to:\nProgress time in a Simulation: the synchronisation algorithm which drives the Dynamic Simulation Environment is implemented with 3 messages; two of which are used to implement the Co-simulation algorithm, and a third message which is used for event driven progression of time.\nFacilitate the exchange of Signals between Models: signal values are first delta encoded (i.e. only changed values), and then embedded as a payload within messages. These messages are then exchanged with, and processed by, a Simulation Bus which implements the distributed algorithm of the Dynamic Simulation Environment.\nImplementation of Model Interfaces: the messages of the Dynamic Simulation Environment are defined using cross platform serialization libraries (Flatbuffers, MsgPack and gRPC). Model interfaces can therefore be written for any combination of operating System, architecture or programming language.\nSignal Vectors The Model C Library presents signals to a model developer as Signal Vectors; simple vector objects, either holding scalar or binary signals, and a collection of supporting methods. Typically, the only interactions a Model Developer will have with the Dynamic Simulation Environment will be related to Signal Vectors.\nIn the Dynamic Simulation Environment, when using the Model C Library, Signal Vectors are used to:\nProvide a simple Model API: only 2 functions are required to implement a Model in the Dynamic Simulation Environment.\nRepresent Signals: all scalar types (bool, int8, float, double etc.) can represented in a scalar Signal Vector, and complex or streaming data types can be represented with a binary Signal Vector. A binary signal may also be annotated with a MIMEtype to further describe additional schemas or properties of the binary data.\nEncapsulate Models from other modelling standards: a Model Compatibility Layer may be implemented to extend the Model C Library to support a foreign modelling tool or framework. In that case, the native data types of the foreign model may be marshalled into either scalar or binary Signal Vectors as required, and then interact seamlessly with other models present in the simulation.\nConnect to external simulations: a Gateway Model allows remote/legacy simulation tools to be connected to a Dynamic Simulation Environment and exchange signals using Signal Vectors. Gateway models are written in the same programming language or framework as that of the remote/legacy simulation tool, and also run in that same environment.\nThe Core Platform The Dynamic Simulation Environment Core Platform is a collection of schemas, libraries and tools which can be used to design and implement simulations using the compositional approach.\nContributing Want to contribute? Great! Each project repository has contribution instructions, however the general recommendation is to open an Issue or Pull Request. If your planning a larger contribution, get in contact first (e.g. open an Issue) and discuss the changes.\nMore Information Check out the docs, or open an issue on one of the repos.\n","categories":"","description":"","excerpt":" Dynamic Simulation Environment The Dynamic Simulation Environment is …","ref":"/dse.doc/about/","tags":"","title":"About the Dynamic Simulation Environment"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/architecture/","tags":"","title":"Architecture"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/cli/","tags":"","title":"CLI"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/cmocka/","tags":"","title":"CMocka"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/developer/","tags":"","title":"Developer"},{"body":" Learn More Git Hub The Dynamic Simulation Environment is a message based distributed simulation platform which defines the interface between models as signal vectors. Signal vectors are a logical grouping of either scalar or binary data which are exchanged between models at discrete points in time. Models may be developed in any programming language and may run on any operating system or hardware platform.\nSimulations are constructed using models with a compositional approach, where system elements represented by the simulation are decomposed/recomposed from a collection of models according the broader simulation objectives. This compositional approach to simulation, called Functional Simulation (FSIL), supports the development of a variety of simulation strategies.\nThe Dynamic Simulation Environment (DSE) can be used to integrate legacy tools into a simulation, such integration techniques include; Gateway models which connect remote systems to a DSE simulation; and Model Compatibility Layers which import foreign models into a DSE simulation. Several Gateway and Model Compatibility Layers are available alongside the Model C Library, our C based implementation of the Dynamic Simulation Environment.\nGetting Started Get started with the DSE.\nRead more …\nContributions welcome! We do a Pull Request contributions workflow on GitHub.\nRead more …\nGitHub Discussions Ask technical questions.\nRead more …\n","categories":"","description":"","excerpt":" Learn More Git Hub The Dynamic Simulation Environment is a message …","ref":"/dse.doc/","tags":"","title":"Dynamic Simulation Environment"},{"body":"FMU Model API The FMU Model API (a part of the DSE C Lib) provides a simplified interface for developing Models which adhere to the Modelica Association FMI Standard. It has the following notable capabilities:\nModels are compatible with either FMI 2 or FMI 3 (selected via linker). Simple model lifecycle: model_init() model_step() - only function needed for a minimal FMU implementation! … Storage system with fast hash based index for all FMI Variable types, including binary data. Integration with DSE Network Codec API which provides a MIMEtype selected (and configured) CAN Virtual Buses. The Network Codec has a simple to use programming interface: ncodec_write() / ncodec_flush() - to send CAN frames ncodec_read() - to receive CAN frames. Component Diagram @startuml fmu-model title DSE C Lib - FMU Model interface \"FMI\" as FmiIf package \"FMU\" { interface \"Model IF\" as ModelIf component \"Model\" as Model component \"FMI Adapter\" as FmiFmu component \"Storage\" as Storage } component \"Importer\" as Importer FmiIf -left- FmiFmu FmiIf )-right- Importer Model -right- ModelIf ModelIf )-right- FmiFmu Model .down.\u003e Storage : use FmiFmu .down.\u003e Storage : use center footer Dynamic Simulation Environment @enduml Example The following example shows a minimal model implementation which simply increments a counter.\n// Copyright 2023 Robert Bosch GmbH #include \u003cdse/clib/fmi/fmu.h\u003e #include \u003cstdio.h\u003e #define UNUSED(x) ((void)x) #define VR_COUNT 42 int model_step(FmuModelDesc* model_desc, double model_time, double stop_time) { UNUSED(model_time); UNUSED(stop_time); int* value_ref = storage_ref(model_desc, VR_COUNT, STORAGE_INT); if (value_ref == NULL) return -1; *value_ref += 1; printf(\"count: %d\\n\", *value_ref); return 0; } Linking When building an FMU, link the following files:\nfmu.c : generic implementation parts storage.c : storage mechanism fmi2/fmi2fmu.c : version specific parts model.c : model specific parts Typedefs FmuAdapterDesc typedef struct FmuAdapterDesc { const char * name; FmuLoadHandler load_func; FmuInitHandler init_func; FmuStepHandler step_func; FmuUnloadHandler unload_func; FmuSetVarHandler set_var_func; FmuGetVarHandler get_var_func; } FmuInstDesc typedef struct FmuInstDesc { const char * name; const char * path; void * model_doc; FmuAdapterDesc * adapter; FmuStrategyDesc * strategy; void * inst_data; void * model_desc; } FmuModelDesc typedef struct FmuModelDesc { FmuMemAllocFunc mem_alloc; FmuMemFreeFunc mem_free; void * instance_data; void * private; int external_binary_free; } FmuStrategyDesc typedef struct FmuStrategyDesc { const char * name; FmuStrategyExecuteFunc exec_func; FmuStrategyMapVariables map_func; FmuStrategyToVariables marshal_to_var_func; FmuStrategyFromVariables marshal_from_var_func; FmuStrategyMapDestroy map_destroy_func; double step_size; double model_time; double stop_time; double model_time_correction; } storage_bucket typedef struct storage_bucket { storage_type type; int index; } Functions fmi2_cosim_execute Applies an action (load, init, step etc) from an FMI2 CoSim execution strategy to the specified FMU instance. The strategy action will call FMU methods according to the FMI Standard.\nParameters inst (FmuInstDesc*) Model Descriptor, references various runtime functions and data. action (FmuStrategyAction) The action which should be executed by the strategy. Returns 0 Success, an equivalent status is passed to the FMU Importer. !0 Failure, an equivalent status is passed to the FMU Importer. model_create Creates an FMU Model Descriptor object and performs any necessary initialisation of the FMU Model.\nCalled by fmi2Instantiate().\nCalled by fmi3InstantiateCoSimulation().\nParameters fmu_inst (void*) FMU provided instance data. mem_alloc (FmuMemAllocFunc) Function pointer for the memory allocation function which the Model should use. Recommend using calloc(). mem_free (FmuMemFreeFunc) Function pointer for the memory free function which the Model should use. Typically free(). Returns FmuModelDesc* A new FMU Model Descriptor object. model_destroy Called by fmi2FreeInstance().\nCalled by fmi3FreeInstance().\nParameters model_desc (FmuModelDesc*) Model Descriptor, references various runtime functions and data. Returns 0 Success, an equivalent status is passed to the FMU Importer. !0 Failure, an equivalent status is passed to the FMU Importer. model_finalize Releases the resources created by model_create().\nCalled by fmi2FreeInstance().\nCalled by fmi3FreeInstance().\nParameters model_desc (FmuModelDesc*) Model Descriptor, references various runtime functions and data. model_init Called by fmi2ExitInitializationMode() as the FMU exits initialisation mode.\nCalled by fmi3ExitInitializationMode() as the FMU exits initialisation mode.\nParameters model_desc (FmuModelDesc*) Model Descriptor, references various runtime functions and data. Returns 0 Success, an equivalent status is passed to the FMU Importer. !0 Failure, an equivalent status is passed to the FMU Importer. model_step Called by fmi2DoStep().\nCalled by fmi3DoStep().\nParameters model_desc (FmuModelDesc*) Model Descriptor, references various runtime functions and data. Returns 0 Success, an equivalent status is passed to the FMU Importer. !0 Failure, an equivalent status is passed to the FMU Importer. model_terminate Called by fmi2Terminate().\nCalled by fmi3Terminate().\nParameters model_desc (FmuModelDesc*) Model Descriptor, references various runtime functions and data. Returns 0 Success, an equivalent status is passed to the FMU Importer. !0 Failure, an equivalent status is passed to the FMU Importer. storage_destroy Destroy any allocated storage.\nParameters model_desc (FmuModelDesc*) Model Descriptor. Returns 0 (int) Success. +ve (int) Failure, inspect errno for the failing condition. storage_get_bucket Returns a reference/pointer to the requested storage bucket.\nParameters model_desc (FmuModelDesc*) Model Descriptor. type (storage_type) Indicate the storage type bucket which should be retrieved. Returns storage_bucket* Reference to the requested storage bucket. NULL The specified storage bucket is not provisioned. storage_init Initialise the storage subsystem for an FMU.\nParameters model_desc (FmuModelDesc*) Model Descriptor. Returns 0 (int) Success. +ve (int) Failure, inspect errno for the failing condition. storage_ref Get a reference (pointer to) the specified storage value. The returned reference must be cast to the provided storage_type by the caller before accessing the storage value.\nParameters model_desc (FmuModelDesc*) Model Descriptor. vr (unsigned int) FMU Variable Reference. type (storage_type) Indicate the storage type bucket from which the storage reference should be retrieved. Returns void* Reference to a storage value (caller must cast to storage_type). NULL A reference to the storage value could not be retrieved. Example #include \u003cdse/fmi/fmu.h\u003e static FmuModelDesc* model_desc; int set_int_value(unsigned int vr, int value) { int *ref = (int*)storage_ref(model_desc, vr, STORAGE_INT); if (ref == NULL) return 1; *ref = value; return 0; } ","categories":"","description":"","excerpt":"FMU Model API The FMU Model API (a part of the DSE C Lib) provides a …","ref":"/dse.doc/apis/clib/fmi/","tags":"","title":"FMI API Reference"},{"body":"Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.\nComponent Diagram @startuml gateway-model title Gateway Model node \"Dynamic Simulation Environment\" { component \"Model\" as m1 component \"Model\" as m2 interface \"SimBus\" as SBif m1 -left-\u003e SBif m2 -right-\u003e SBif } package \"Gateway Model\" { component \"ModelC Lib\" as ModelC component \"Model\" } SBif \u003c-down- ModelC Model -up-\u003e ModelC :model_gw_setup() Model -up-\u003e ModelC :model_gw_sync() Model -up-\u003e ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cstdlib.h\u003e #include \u003cerrno.h\u003e #include \u003cdse/modelc/gateway.h\u003e #include \u003cdse/logger.h\u003e /** * Gateway Model. * * A normal gateway would exchange signals with the host simulation, however * in this example a simple conversion is applied to each signal (to * demonstrate the effect). * * Example * ------- * ./gateway 0.005 0.02 gateway.yaml */ int main(int argc, char** argv) { if (argc \u003c 4) { log_fatal( \"Missing arguments! (gateway \u003cstep_size\u003e \u003cend_time\u003e [yaml ...])\"); } double model_time = 0.0; double step_size = atof(argv[1]); double end_time = atof(argv[2]); const char** yaml_files = calloc(argc - 3 + 1, sizeof(char*)); memcpy(yaml_files, \u0026argv[3], ((argc - 3) * sizeof(char*))); /* Setup the gateway. */ ModelGatewayDesc gw; model_gw_setup(\u0026gw, \"gateway\", yaml_files, LOG_INFO, step_size, end_time); /* Run the simulation. */ while (model_time \u003c= end_time) { int rc = model_gw_sync(\u0026gw, model_time); if (rc == ETIME) { log_notice( \"Gateway is behind simulation time, advancing gateway time.\"); model_time += step_size; continue; } /* Process the signal vectors. */ SignalVector* sv = gw.sv; while (sv \u0026\u0026 sv-\u003ename) { if (sv-\u003eis_binary) { /* Binary vector. */ for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_info(\"[%f] %s[%d] = \u003c%d:%d\u003e%s (%s)\", model_time, sv-\u003ename, i, sv-\u003elength[i], sv-\u003ebuffer_size[i], sv-\u003ebinary[i], sv-\u003esignal[i]); /* Exchange/update the gateway signal. */ char buffer[100]; snprintf(buffer, sizeof(buffer), \"st=%f,index=%d\", model_time, i); sv-\u003ereset(sv, i); sv-\u003eappend(sv, i, buffer, strlen(buffer) + 1); } } else { /* Scalar vector. */ for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_info(\"[%f] %s[%d] = %f (%s)\", model_time, sv-\u003ename, i, sv-\u003escalar[i], sv-\u003esignal[i]); /* Exchange/update the gateway signal. */ sv-\u003escalar[i] = sv-\u003escalar[i] + ((i + 1) \u003c\u003c 2); } } /* Next signal vector. */ sv++; } /* Next step. */ model_time += step_size; } /* Exit the simulation. */ model_gw_exit(\u0026gw); free(yaml_files); return 0; } Typedefs ModelGatewayDesc typedef struct ModelGatewayDesc { int * sim; int * mi; int * sv; const char ** argv; char * name_arg; } Functions model_gw_exit Terminates the Gateway Model and releases all objects referenced by the ModelGatewayDesc object. The object itself is not affected and should be released by the caller (if necessary).\nParameters gw (ModelGatewayDesc*) A gateway descriptor object, holds references to various ModelC objects. Returns 0 Success. +ve Failure, inspect errno for the failing condition. model_gw_setup Parameters gw (ModelGatewayDesc*) A gateway descriptor object, holds references to various ModelC objects. name (const char*) Name of the gateway model. Used when parsing the provided YAML files to select the relevant configuration items (i.e. Model and SignalGroup schemas). yaml_files (const char*) A list of YAML files where the relevant gateway configuration objects should be found. log_level (int) The log level to apply to the gateway model. Common values include; LOG_NOTICE (default), LOG_INFO, LOG_QUIET (only errors) or LOG_DEBUG. Set to a negative number to use the default log level. step_size (double) Step size for interactions with the Simbus. end_time (double) End time for the simulation (acts as guard against “forever” simulations). Returns 0 Success. +ve Failure, inspect errno for the failing condition. model_gw_sync Parameters gw (ModelGatewayDesc*) A gateway descriptor object, holds references to various ModelC objects. model_time (double) The current simulation time of the gateway model for which the Gateway API should synchronise with. Returns 0 Success. E_GATEWAYBEHIND The specified model_time is behind the simulation time. The time should be advanced by the caller and then retry this call until the condition clears. +ve Failure, inspect errno for the failing condition. ","categories":"","description":"","excerpt":"Gateway Model When implemented, a Gateway Model makes it possible for …","ref":"/dse.doc/apis/modelc/gateway/","tags":"","title":"Gateway API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/gdb/","tags":"","title":"GDB"},{"body":"(v0.0.1)\nManifest kind: Manifest metadata: name: string labels: property1: string property2: string annotations: property1: string property2: string spec: repos: - name: string repo: string path: string registry: string user: string token: string tools: - name: string version: string repo: string arch: - string schema: string models: - name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string simulations: - name: string parameters: transport: redispubsub environment: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true models: - name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true documentation: - name: string uri: string repo: string processing: string generate: string modelc: true This schema object defines a Manifest kind. A Manifest kind is used to describe a compositional simulation in terms of Tools, Models, Configuration and other Files. The manifest can then be used to generate the simulation system.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » repos [Repo] true List of repositories where artifacts used by this simulation may be located. » tools [Tool] true List of tools used by this simulation. » models [Model] true List of model libraries used by this simulation. » simulations [Simulation] true List of individual simulations which comprise this compositional simulation. » documentation [File] false List of documentation files supporting this simulation. Enumerated Values Property Value kind Manifest Repo name: string repo: string path: string registry: string user: string token: string Define a repository where artifacts might be located. When a repository is referenced by a Tool, Model or File, that object will have the repository properties available as Task Variables which may be used to define a custom URI schema.\nProperties Name Type Required Description name string true Name of the repository definition. repo string false Repository URI (e.g. as used by the curl command). path string false Repository path to the root location of artifacts. registry string false Registry name/path as used by docker. user string true User for authentication with the repository. token string true Token for authentication with the repository. Tool name: string version: string repo: string arch: - string schema: string Define a tool which will be used by the simulation.\nProperties Name Type Required Description name string true Name of the tool. version string true Version of the tool. repo string false The name of the repo where this tool can be downloaded from. arch [string] false Architectures of the tool that should be downloaded. schema string false Define the URI schema for the tool. Model name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string Define a model library which will be used by the simulation. A model library may be referenced by one or more model instances (which themselves are defined in individual simulations).\nProperties Name Type Required Description name string true Name of the model. version string true Version of the model. repo string true The name of the repository definition where this model can be downloaded from. arch string false Architecture of the model that should be downloaded. If more than one architecture of a model should be downloaded, then an additional model (with a different name) can be defined for each architecture. schema string false Define the URI schema for the model. channels [object] false Some models (i.e. Simbus) require specification of channels. » name string false The name of the channel, used when connecting this channel to the SimBus. » alias string false The alias of the channel, used when the channel name will be determined elsewhere. » expectedModelCount integer false Indicates how many models are expected to connect to this channel (used by SimBus only). » selectors object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none File name: string uri: string repo: string processing: string generate: string modelc: true Define a file which will be used by a model of the composed simulation. File processing follows the sequence; all uri nodes are processed (e.g. downloaded/copied), all processing commands are executed, finally all generate commands are executed.\nProperties Name Type Required Description name string true Path of the file relative to the root of the simulation package. This is the final path, after download or generation. When no processing or generate node is specified, the uri is downloaded/copied directly to the specified name. uri string false The URI where the file (or source for the file) is located. The uri may be a URL or local file. If a URL requires authentication, then include a repo in the file definition and the authentication will be taken from that referenced repo definition. repo string false The name of the repository definition where authentication details for this file are located. processing string false Processing commands for the downloaded/copied file. generate string false Generate commands that produce the (final) file. modelc boolean false When set to true this file is included as a parameter to the ModelC command. ModelInstance name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true Define a model instance, which belongs to a simulation.\nProperties Name Type Required Description name string true Name of the model instance. model string true The model library used by this model instance. channels [Model/properties/channels/items] true Indicates how channels are mapped to the model instance. files [File] false List of files used by the model instance. Simulation name: string parameters: transport: redispubsub environment: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true models: - name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true Define ain individual simulation.\nProperties Name Type Required Description name string true Name of the simulation. parameters object false Parameters used to configure the simulation. » transport string true Select from the supported transports. » environment object false Dictionary of environment variables which control the simulation. The name of each element will be capitalized before being injected into the simulation environment. »» additionalProperties string false none files [File] false List of files used by the simulation and/or shared between model instances. models [ModelInstance] true List of model instance definitions included in the simulation. Enumerated Values Property Value transport redispubsub undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nManifest kind: Manifest metadata: name: string labels: …","ref":"/dse.doc/schemas/yaml/manifest/","tags":["Schema"],"title":"Schema: Manifest"},{"body":"Model Compatibility Layer The Model Compatibility Layer (MCL) can be used to implement support for models which were written according to different a modeling interface. This is done by combining a Strategy and Adapter pattern to build an MCL which can load, execute and exchange data with a the foreign model.\nComponent Diagram @startuml mcl-component title Compatibility Layer component \"ModelC\" { component \"MCL Model\" as MCLmodel } component \"MCL Lib\" { interface \"Strategy\" as Sif interface \"Adapter\" as Aif component \"MCL\" as MCL } interface \"Model Interface\" as Mif component \"Model\" as Model MCLmodel --( Sif MCLmodel --( Aif Sif -- MCL Aif -- MCL MCL -( Mif Mif - Model center footer Dynamic Simulation Environment @enduml Typedefs MclAdapterDesc typedef struct MclAdapterDesc { const char * name; MclLoadHandler load_func; MclInitHandler init_func; MclStepHandler step_func; MclUnloadHandler unload_func; } MclInstanceDesc typedef struct MclInstanceDesc { int * model_instance; int * channel; MclStrategyDesc * strategy; int models; } MclModelDesc typedef struct MclModelDesc { const char * name; int * model_doc; char * path; void * handle; double * vector_double; void ** vector_binary; double model_time; double model_time_correction; double step_size; MclAdapterDesc * adapter; void * private; } MclStrategyDesc typedef struct MclStrategyDesc { const char * name; double model_time; double stop_time; MclExecuteMethod execute; MclExecuteHandler execute_func; MclMarshallOutHandler marshall_out_func; MclMarshallInHandler marshall_in_func; MclInstanceDesc * mcl_instance; } Functions mcl_create Creates an instance of an MCL Model. All configured Model Libraries (of the MCL Model) are first associated with an MCL Adapter and MCL Strategy (provided by an MCL Library) and then loaded via the MCL Adapter load_func().\nParameters model_instance (ModelInstanceSpec*) Model Instance object representing the Model. Contains various identifying and configuration elements. Returns 0 The MCL library way successfully loaded. Exceptions exit(errno) Any error in creating an MCL Model instance represents a fatal configuration error and exit() is called to terminate execution. mcl_destroy Destroy an instance of an MCL Model, releasing any allocated memory or other resources allocated to the MCL Model instance.\nParameters model_instance (ModelInstanceSpec*) Model Instance object representing the Model. Contains various identifying and configuration elements. mcl_load Loads an MCL Library which will contain a number of Strategy and/or Adapter methods. The MCL Library should implement function mcl_setup() which will be called by the MCL when the MCL Libary is loaded. The function mcl_setup() of the MCL Library should call MCL functions mcl_register_strategy() and/or mcl_register_adapter() to register this MCL Library with the MCL.\nParameters model_instance (ModelInstanceSpec*) Model Instance object representing the Model. Contains various identifying and configuration elements. Returns 0 The MCL library way successfully loaded. Exceptions exit(errno) Any error in loading an MCL represents a fatal configuration error and exit() is called to terminate execution. mcl_register_adapter An MCL Library calls this function to register a particular MCL Adapter with the MCL.\nParameters adapter (MclAdapterDesc*) MCL Strategy object representing a strategy capability of the MCL Library. mcl_register_strategy An MCL Library calls this function to register a particular MCL Strategy with the MCL.\nParameters strategy (MclStrategyDesc*) MCL Strategy object representing a strategy capability of the MCL Library. ","categories":"","description":"","excerpt":"Model Compatibility Layer The Model Compatibility Layer (MCL) can be …","ref":"/dse.doc/apis/modelc/mcl/","tags":"","title":"MCL API Reference"},{"body":"Model API The Model API allows model developers and integrators to interface with a Dynamic Simulation Environment via a connection with a Simulation Bus.\nSignal Vector Interface Models exchange signals via the Simulation Bus using a Signal Vector. Signal Vectors represent a logical grouping of signals (i.e. a collection of signals belonging to an ECU interface or bus), they are defined by a SignalGroup schema kind, and a Signal Vector can represent either scalar or binary values.\nComponent Diagram @startuml model-signal-vector title Signal Vector Interface interface \"SimBus\" as SBif package \"Model\" { component \"ModelC Lib\" as ModelC interface \"SignalVectorVTable\" as SVvt component \"Model\" as Mdl } ModelC -up-\u003e SBif Mdl -up-( SVvt SVvt -up- ModelC Mdl --\u003e ModelC :model_sv_create() Mdl --\u003e ModelC :model_sv_destroy() center footer Dynamic Simulation Environment @enduml Example #include \u003cdse/modelc/model.h\u003e #include \u003cdse/logger.h\u003e void print_signal_vectors(ModelInstanceSpec* mi) { SignalVector* sv = model_sv_create(mi); while (sv \u0026\u0026 sv-\u003ename) { log_debug(\"Signal Vector : %s\", sv-\u003ename); for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_debug(\" signal : %s\", sv-\u003esignal[i]); if (sv-\u003eis_binary) { log_debug(\" length : %s\", sv-\u003elength[i]); log_debug(\" buffer_size : %s\", sv-\u003ebuffer_size[i]); log_debug(\" mime_type : %s\", sv-\u003emime_type[i]); // Example use of object functions. void* data = strdup(\"foo\"); sv-\u003ereset(sv, i); sv-\u003eappend(sv, i, data, strlen(\"foo\")); free(data); sv-\u003erelease(sv, i); const char* mime_type = sv-\u003eannotation(sv, i, \"mime_type\"); if (mime_type) log_debug(\" annotation : %s\", mime_type); } else { log_debug(\" scalar : %s\", sv-\u003escalar[i]); } } // Next signal vector. sv++; } } Model Interface The Model Interface must be implemented by a Model. It includes the functions necessary for a Model to be loaded and executed in the Dynamic Simulation Environment.\nComponent Diagram @startuml model-interface skinparam nodesep 55 skinparam ranksep 40 title Model Interface component \"Model\" as m1 component \"Model\" as m2 interface \"SimBus\" as SBif m1 -left-\u003e SBif m2 -right-\u003e SBif package \"Model\" { component \"ModelC Lib\" as ModelC interface \"ModelInterfaceVTable\" as MIvt component \"Model\" as Mdl } SBif \u003c-down- ModelC Mdl -up- MIvt MIvt )-up- ModelC center footer Dynamic Simulation Environment @enduml Example #include \u003cdse/modelc/model.h\u003e #include \u003cdse/logger.h\u003e #define UNUSED(x) ((void)x) /* Signal Vector definition. Note: Signal order should match order in related SignalGroup (YAML). */ typedef enum signal_name_index { SIGNAL_FOO, SIGNAL_BAR, __SIGNAL__COUNT__ } signal_name_index; static double* signal_value; int model_step(double* model_time, double stop_time) { signal_value[SIGNAL_FOO] += 1.2; signal_value[SIGNAL_BAR] += 4.2; *model_time = stop_time; return 0; } int model_setup(ModelInstanceSpec* mi) { int rc = model_function_register(mi, \"example\", 0.005, model_step); if (rc != 0) return rc; /* Register channels (and get storage). */ static ModelChannelDesc channel_desc = { .name = \"model_channel\", .function_name = \"example\", }; rc = model_configure_channel(mi, \u0026channel_desc); if (rc != 0) return rc; signal_value = channel_desc.vector_double; return 0; } int model_exit(ModelInstanceSpec* mi) { UNUSED(mi); return 0; } Typedefs ChannelSpec typedef struct ChannelSpec { const char * name; const char * alias; void * private; } ModelCArguments typedef struct ModelCArguments { const char * transport; char * uri; const char * host; uint32_t port; double timeout; uint8_t log_level; double step_size; double end_time; uint32_t uid; const char * name; const char * file; const char * path; int * yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; uint32_t steps; } ModelChannelDesc typedef struct ModelChannelDesc { const char * name; const char * function_name; const char ** signal_names; uint32_t signal_count; bool propagator_source_channel; bool propagator_target_channel; double * vector_double; void ** vector_binary; uint32_t * vector_binary_size; uint32_t * vector_binary_buffer_size; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char * name; const char * path; const char * file; char * full_path; int * doc; int * channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { uint32_t uid; char * name; ModelDefinitionSpec model_definition; int * spec; int * propagators; int * yaml_doc_list; void * private; } ModelInterfaceVTable typedef struct ModelInterfaceVTable { ModelSetupHandler setup; ModelDoStepHandler step; ModelExitHandler exit; } SignalVector typedef struct SignalVector { const char * name; const char * alias; const char * function_name; bool is_binary; uint32_t count; const char ** signal; BinarySignalAppendFunc append; BinarySignalResetFunc reset; BinarySignalReleaseFunc release; SignalAnnotationGetFunc annotation; BinarySignalCodecFunc codec; ModelInstanceSpec * mi; } SignalVectorVTable typedef struct SignalVectorVTable { BinarySignalAppendFunc append; BinarySignalResetFunc reset; BinarySignalReleaseFunc release; SignalAnnotationGetFunc annotation; BinarySignalCodecFunc codec; } SimulationSpec typedef struct SimulationSpec { const char * transport; char * uri; uint32_t uid; double timeout; double step_size; double end_time; ModelInstanceSpec * instance_list; } Functions model_configure_channel Configure a connection from this Model to a Channel on the Simulation Bus. The Channel can then be represented by a Signal Vector making access to individual Signals and their configuration (annotations) easy.\nParameters model_instance (ModelInstanceSpec*) The Model Instance object (provided via the model_setup() function of the Model API). channel_desc (ModelChannelDesc*) A channel descriptor object which defines the Channel and Model Function names which should be configured. Returns 0 The Channel was configured. +VE An error occurred during the registration of the Channel. model_function_register Register a Model Function. A Model may register one or more Model Functions with repeated calls to this function.\nParameters model_instance (ModelInstanceSpec*) The Model Instance object (provided via the model_setup() function of the Model API). name (const char*) The name of the Model Function. step_size (double) The step size of the Model Function. do_step_handler (ModelDoStepHandler) The “do step” function of the Model Function. Returns 0 The model function was registered. (errno) An error occurred during registration of the model function. The return value is the errno which may indicate the reason for the failure. model_sv_create This is Model User API replacing modelc_debug.c::modelc_get_model_vectors().\nParameters mi (ModelInstanceSpec*) The model instance, which holds references to the registered channels. Returns SignalVector (pointer to NULL terminated list) A list of SignalVector objects representing the signals assigned to a model. The list is NULL terminated (sv-\u003ename == NULL). Caller to free. Example #include \u003cdse/modelc/model.h\u003e #include \u003cdse/logger.h\u003e void print_signal_names(ModelInstanceSpec* mi) { SignalVector* sv_save = model_sv_create(mi); for (SignalVector* sv = sv_save; sv-\u003ename; sv++) { for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_debug(\" signal : %s\", sv-\u003esignal[i]); } } model_sv_destroy(sv_save); } model_sv_destroy The underlying objects of a SignalVector object (e.g. from ModelC object) are not affected by calling this method.\nParameters sv (SignalVector*) The SignalVector object to destroy. Should be the same object as returned from the call to model_sv_create(). ","categories":"","description":"","excerpt":"Model API The Model API allows model developers and integrators to …","ref":"/dse.doc/apis/modelc/model/","tags":"","title":"Model API Reference"},{"body":"(v0.0.1)\nModel kind: Model metadata: name: string labels: property1: string property2: string annotations: property1: string property2: string spec: runtime: dynlib: - path: string os: string arch: string variant: string libs: - string annotations: property1: string property2: string executable: - os: string arch: string libs: - string annotations: property1: string property2: string gateway: annotations: property1: string property2: string mcl: - path: string os: string arch: string variant: string libs: - string annotations: property1: string property2: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string This schema object defines a Model kind. A Model kind is used to define a model which participates within a DSE based simulation.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » runtime object false Selects (or defines) the kind of runtime that a particular model implements. In some cases several runtimes of a particular type may be defined according to operating system architecture. »» dynlib [LibrarySpec] false Dynamic Library runtime specifications. »» executable [ExecutableSpec] false Executable runtime specifications. »» gateway GatewaySpec false Defines a Gateway Model which represents a connection from a remote simulation system. The remote system loads a model which includes the ModelC Gateway functionality, that model is then able to connect to a DSE based simulation using the ModelC Gateway functionality.\nThe remote system may be a different type of simulation environment. »» mcl [LibrarySpec] false Model Compatibility Library runtime specifications. » channels [object] false A list of channels belonging to this model. »» name string false The name of the channel, used when connecting this channel to the SimBus. »» alias string false The alias of the channel, used when the channel name will be determined elsewhere. »» expectedModelCount integer false Indicates how many models are expected to connect to this channel (used by SimBus only). »» selectors object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »»» additionalProperties string false none »» annotations object false Non identifying information (i.e. information specific to the object itself). »»» additionalProperties string false none Enumerated Values Property Value kind Model LibrarySpec path: string os: string arch: string variant: string libs: - string annotations: property1: string property2: string Defines a Model which is implemented as a dynamic library. The model defined here will be loaded by an appropriate runtime executable, that executable provides all necessary library functions related to the DSE simulation environment. Addition libraries may be specified via the libs property.\nProperties Name Type Required Description path string true The relative (to the model package) path to the runtime artifact. os string false Indicate the operating system of the runtime (e.g. linux, windows). arch string false Indicate the architecture of the runtime (e.g. amd64, w32) variant string false Indicate the architecture sub variant of the runtime (e.g. v7) libs [string] false A list of libraries on which the runtime is dependant. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties string false none GatewaySpec annotations: property1: string property2: string Defines a Gateway Model which represents a connection from a remote simulation system. The remote system loads a model which includes the ModelC Gateway functionality, that model is then able to connect to a DSE based simulation using the ModelC Gateway functionality. The remote system may be a different type of simulation environment.\nProperties Name Type Required Description annotations LibrarySpec/properties/annotations false Non identifying information (i.e. information specific to the object itself). ExecutableSpec os: string arch: string libs: - string annotations: property1: string property2: string Defines a model implemented in an executable. The functions representing the model functionality will be taken directly from linked symbols in the executable file.\nProperties Name Type Required Description os string false Indicate the operating system of the executable (e.g. linux, windows). arch string false Indicate the architecture of the executable (e.g. amd64, w32) libs [string] false A list of libraries on which the executable is dependant. The executable would load each of the listed libraries. annotations LibrarySpec/properties/annotations false Non identifying information (i.e. information specific to the object itself). undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nModel kind: Model metadata: name: string labels: property1: …","ref":"/dse.doc/schemas/yaml/model/","tags":["Schema"],"title":"Schema: Model"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/modelc/","tags":"","title":"ModelC"},{"body":"modelc Run the model loader and executer.\nSynopsis # Load and run a Model, specifying the Model, Stack and SignalGroup YAML files. $ dse.modelc --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml Options $ dse.modelc ModelC - model runner usage: [--transport \u003ctransport\u003e] [--uri \u003cendpoint\u003e] (i.e. redis://localhost:6379) [--host \u003chost url\u003e] *** depreciated, use --uri *** [--port \u003cport number\u003e] *** depreciated, use --uri *** [--stepsize \u003cdouble\u003e] [--endtime \u003cdouble\u003e] [--uid \u003cmodel uid\u003e] [--name \u003cmodel name\u003e] *** normally required *** [--timeout \u003cdouble\u003e] [--logger \u003cnumber\u003e] 0..6 *** 0=more, 6=less, 3=INFO *** [--file \u003cmodel file\u003e] [--path \u003cpath to model\u003e] *** relative path to Model Package *** [YAML FILE [,YAML FILE] ...] ","categories":"","description":"","excerpt":"modelc Run the model loader and executer.\nSynopsis # Load and run a …","ref":"/dse.doc/docs/user/tools/modelc/","tags":["ModelC","CLI"],"title":"modelc"},{"body":"GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB debugging with the following technique:\nIn the main Makefile, add the GDB_CMD environment variable (i.e. --env GDB_CMD=\"$(GDB_CMD)\") to every DOCKER_CMD that requires interactive GDB debugging support.\nFor each Makefile run target where interactive GDB debugging is required, prefix the run command with the GDB_CMD variable, for example: cd build/_out; $(GDB_CMD) bin/test_tdd.\nSet the GDB_CMD environment variable with your GDB command (e.g. export GDB_CMD=\"gdb -ex run\").\nExecute your Makefile run target, which will start in GDB according to the configuration in GDB_CMD.\nA few simple GDB commands:\nbt - backtrace. frame x - move to stack frame x (where x is from output of bt command). print x - print the value of variable x. list - list the code around the current stopped point. quit - exit GDB. Hint: this technique is particularly helpful when working with CMocka based Test Cases.\nExample GDB_CMD settings:\n# Run GDB. $ export GDB_CMD=\"gdb -q -ex run\" # Run GDB and exit if the program finished without error. $ export GDB_CMD=\"gdb -q -ex='set confirm on' -ex=run -ex=quit\" Example Makefile:\n# Docker CMDS (shortened example). ifneq ($(CI), true) DOCKER_BUILDER_CMD := docker run -it --rm \\ --volume $$(pwd):/tmp/repo \\ ... --env GDB_CMD=\"$(GDB_CMD)\" \\ --workdir /tmp/repo \\ $(GCC_BUILDER_IMAGE) endif # Run target. run: cd build/_out; $(GDB_CMD) bin/test_tdd ModelC Integration with GDB in Docker Environment When developing parts of the Model C Library it is occasionally necessary to run the various elements under GDB. The Docker based build environment can be configured to do this, and there are several Makefile targets which help in establishing that environment.\nExact commands to run SimBus and ModelC can be taken from the output of unit/integration tests.\nStart Docker Environment (Terminal 1) This command creates a Docker Network, starts a Redis Container, and then starts a Docker Build Container ready for use. The current directory of the repo is also mapped into the container at /tmp/repo.\n:~/git/dse/dse.modelc$ make test-env 433d62be46ba4a2af17a03754e240e4e2774a093bceb86bed875dc0c4c9e7ec0 dse 658d227bbdf354525c31d930b9b045c867898498cd37fd3fbbae12e0aec626ca a035f2d928d18d4df4cfb2215d65e0f75abfb8a9fcdb5f52904d8fff115c4286 :/tmp/repo# ls dse/modelc/build/_out/ bin data examples include lib licenses root@c5e03415542a:/tmp/repo# Connect to Docker Environment and start SimBus (Terminal 2) :~/git/dse/dse.modelc$ make test-env-it docker exec -it --workdir /tmp/repo modelc_testenv /bin/bash :/tmp/repo# cd /tmp/repo/dse/modelc/build/_out/examples/binary :/tmp/repo/dse/modelc/build/_out/examples/binary# gdb --args /tmp/repo/dse/modelc/build/_out/bin/simbus --logger 2 --timeout 1 stack.yaml (gdb) run Starting program: /tmp/repo/dse/modelc/build/_out/bin/simbus --logger 2 --timeout 1 stack.yaml Version: 0.0.2 ... Start the Bus ... Connect to Docker Environment and start ModelC (Terminal 3) :~/git/dse/dse.modelc$ make test-env-it docker exec -it --workdir /tmp/repo modelc_testenv /bin/bash :/tmp/repo# cd /tmp/repo/dse/modelc/build/_out/examples/binary :/tmp/repo/dse/modelc/build/_out/examples/binary# gdb --args /tmp/repo/dse/modelc/build/_out/bin/modelc --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml (gdb) run Starting program: /tmp/repo/dse/modelc/build/_out/bin/modelc --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml Version: 0.0.2 Platform: linux-amd64 ... Model function model_setup called Configure Channel: binary_channel Channel Name: Network Channel Alias: binary_channel [INFO] signal[0] : RAW (_load_signals:259) Unique signals identified: 1 Init Controller channel: Network Pub Key: bus.ch.Network.tx Sub Key: bus.ch.Network.rx [INFO] Allocate signal vector type 1 for 1 signals. (model_configure_channel:405) [FATAL] Binary vector not allocated! (model_setup:94) [Inferior 1 (process 37) exited with code 0175] (gdb) General GDB commands bt frame up down info locals info args ","categories":"","description":"","excerpt":"GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB …","ref":"/dse.doc/docs/devel/modelc_debug/","tags":["Developer","ModelC","GDB"],"title":"Model C Debug Techniques"},{"body":"Network Codec The Model C Library integrates the DSE Network Codec implementation of the Automotive Bus schemas.\nBuild Integration The Network Codec integration repackages the necessary include files with the Model C Library packages. No additional build integration is required. A typical CMake configuration might look like this:\nFetchContent_Declare(dse_modelc_lib URL ${MODELC_LIB__URL} SOURCE_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.modelc.lib\" ) FetchContent_MakeAvailable(dse_modelc_lib) set(DSE_MODELC_INCLUDE_DIR \"${dse_modelc_lib_SOURCE_DIR}/include\") # ... dynamic linked Model (ModelC.exe provides objects) ... target_include_directories(some_target PRIVATE ${DSE_MODELC_INCLUDE_DIR} ../.. ) # ... static linked target (typical CMocka test application) ... set(MODELC_BINARY_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.modelc.lib\") find_library(MODELC_LIB NAMES libmodelc_bundled.a PATHS ${MODELC_BINARY_DIR}/lib REQUIRED NO_DEFAULT_PATH ) add_library(modelc STATIC IMPORTED GLOBAL) set_target_properties(modelc PROPERTIES IMPORTED_LOCATION \"${MODELC_LIB}\" INTERFACE_INCLUDE_DIRECTORIES \"${MODELC_BINARY_DIR}\" ) set(DSE_MODELC_LIB_INCLUDE_DIR \"${MODELC_BINARY_DIR}/include\") add_executable(test_mstep mstep/__test__.c mstep/test_mstep.c ) target_include_directories(test_mstep PRIVATE ${DSE_MODELC_LIB_INCLUDE_DIR} ./ ) target_link_libraries(test_mstep PUBLIC -Wl,-Bstatic modelc -Wl,-Bdynamic ${CMAKE_DL_LIBS} PRIVATE cmocka dl m ) Configuration of Binary Signals Binary signals are configured with a MIME Type. The Signal Vector integration with the Network Codec will automatically open codec objects for each supported MIME Type that is supported (by the codec). Additional configuration of the codec objects can be done with the ncodec_config() API function.\nkind: SignalGroup metadata: name: network labels: channel: network_vector annotations: vector_type: binary spec: signals: - signal: can_bus annotations: mime_type: application/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=2; interface_id=3 Additional configuration information is available here. Especially the behaviour of bus_id,node_idand interface_id configuration items are described.\nConfiguration items can also be set at runtime with the ncodec_config() API as the following example shows:\n#include \u003cdse/modelc/model.h\u003e #include \u003cdse/ncodec/codec.h\u003e static void _setup_node_id(SignalVector* sv, uint32_t idx) { const char* v = sv-\u003eannotation(sv, idx, \"node_id\"); if (v) { NCODEC* nc = sv-\u003ecodec(sv, idx); ncodec_config(nc, (struct NCodecConfigItem){ .name = \"node_id\", .value = v, }); } } Usage in Model Code The Network Codec integration is fairly easy to use. The general approach is as follows:\n#include \u003cdse/modelc/model.h\u003e #include \u003cdse/ncodec/codec.h\u003e void do_bus_rx(SignalVector* sv, uint32_t idx) { NCODEC* nc = sv-\u003ecodec(sv, idx); while (1) { NCodecMessage msg = {}; len = ncodec_read(nc, \u0026msg); if (len \u003c 0) break; put_rx_frame_to_queue(msg.frame_id, msg.buffer, msg.len); } } void do_bus_tx(SignalVector* sv, uint32_t idx) { uint32_t id; uint8_t* msg; size_t len; NCODEC* nc = sv-\u003ecodec(sv, idx); while (get_tx_frame_from_queue(\u0026id, \u0026msg, \u0026len)) { ncodec_write(nc, \u0026(struct NCodecMessage){ .frame_id = id, .buffer = msg, .len = len, }); } ncodec_flush(nc); } Usage in Test Cases When developing Test Cases its possible to use an existing Network Codec object to send or receive messages with the objects owner (usually a model). This is particularly useful for testing messaging behaviour of a model under specific circumstances. When doing this its necessary to circumvent the node_id filtering of that codec, as the following example illustrates.\n#include \u003cdse/testing.h\u003e #include \u003cdse/modelc/model.h\u003e #include \u003cdse/ncodec/codec.h\u003e char* get_ncodec_node_id(NCODEC* nc) { assert_non_null(nc); int index = 0; char* node_id = NULL; while (index \u003e= 0) { NCodecConfigItem ci = ncodec_stat(nc, \u0026index); if (strcmp(ci.name, \"node_id\") == 0) { node_id = ci.value; break; } index++; } if (node_id) return strdup(node_id); return NULL; } void set_ncodec_node_id(NCODEC* nc, char* node_id) { assert_non_null(nc); ncodec_config(nc, (struct NCodecConfigItem){ .name = \"node_id\", .value = node_id, }); } void test_message_sequence(void** state) { ModelCMock* mock = *state; NCODEC* nc = sv-\u003ecodec(sv, idx); // ... // Modify the node_id. char* node_id_save = get_ncodec_node_id(nc); set_ncodec_node_id(nc, \"42\"); // Send a message (which will not be filtered). ncodec_write(nc, \u0026(struct NCodecMessage){ .frame_id = frame_id, .buffer = data, .len = len, }); ncodec_flush(nc); // Restore the existing node_id. set_ncodec_node_id(nc, node_id_save); free(node_id_save); // ... } ","categories":"","description":"","excerpt":"Network Codec The Model C Library integrates the DSE Network Codec …","ref":"/dse.doc/docs/devel/modelc_ncodec/","tags":["Developer","ModelC"],"title":"Model C with Network Codec"},{"body":"mstep Debug tool to load and step a model through a simulation.\nSynopsis # Load and step a Model, specifying the Model, Stack and SignalGroup YAML files. $ dse.mstep --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml Options $ mstep --help Model Loader and Stepper usage: [--transport \u003ctransport\u003e] [--uri \u003cendpoint\u003e] (i.e. redis://localhost:6379) [--host \u003chost url\u003e] *** depreciated, use --uri *** [--port \u003cport number\u003e] *** depreciated, use --uri *** [--stepsize \u003cdouble\u003e] [--endtime \u003cdouble\u003e] [--uid \u003cmodel uid\u003e] [--name \u003cmodel name\u003e] *** normally required *** [--timeout \u003cdouble\u003e] [--logger \u003cnumber\u003e] 0..6 *** 0=more, 6=less, 3=INFO *** [--file \u003cmodel file\u003e] [--path \u003cpath to model\u003e] *** relative path to Model Package *** [YAML FILE [,YAML FILE] ...] ","categories":"","description":"","excerpt":"mstep Debug tool to load and step a model through a simulation. …","ref":"/dse.doc/docs/user/tools/mstep/","tags":["ModelC","CLI"],"title":"mstep"},{"body":"Network Codec A Network Codec has two interfaces: a Codec Interface which is used to encode/decode message from a Model/Device (connected to a Network), and a Stream Interface which is used to exchange the encoded messages with other Model/Devices connected to the same Network.\nThe Network Codec API (codec.h \u0026 codec.c) provides the framework for implementing both the Codec Interface and the Stream Interface. A typical realisation of this scheme would be:\nStream Implementation - provided by the Model Environment. Network Codec Implementation - provided by a Codec vendor. Model - using the Network Codec API to configure and use a Network, with the assistance of both the Network Codec and Stream implementations. Component Diagram @startuml ncodec-component title Network Codec package \"Model Environment\" { interface \"Signal Interface\" as Sif component \"Model\" as foo { component \"Model\" as Model interface \"CodecVTable\" as Cvt component \"Codec\" as Codec interface \"StreamVTable\" as Svt } component \"Stream\" as Stream interface \"Binary Interface\" as Bif component \"Codec Lib\" as lib } Sif )-down- Model Model -right-( Cvt Cvt -right- Codec Codec -right-( Svt Svt -right- Stream Stream -down-( Bif lib .up.\u003e Codec Model --\u003e lib :ncodec_open() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cstddef.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003cdse/ncodec/codec.h\u003e #define MIMETYPE \"application/x-codec-example\" extern NCodecStreamVTable example_stream; extern int stream_seek(NCODEC* nc, size_t pos, int op); int main(int argc, char* argv[]) { int rc; static const char* greeting = \"Hello World\"; if (argc \u003e 1) { rc = ncodec_load(argv[1], NULL); if (rc) { printf(\"Load failed (rc %d)\\n\", rc); return rc; } } NCODEC* nc = ncodec_open(MIMETYPE, (void*)\u0026example_stream); if (nc == NULL) { printf(\"Open failed (errno %d)\\n\", errno); return errno; } ncodec_config(nc, (struct NCodecConfigItem){ .name = \"name\", .value = \"simple network codec\" }); /* Write a message to the Network Codec. */ ncodec_write(nc, \u0026(struct NCodecMessage){ .frame_id = 42, .buffer = (uint8_t*)greeting, .len = strlen(greeting) }); ncodec_flush(nc); /* Reposition to start of stream. */ stream_seek(nc, 0, NCODEC_SEEK_SET); /* Read the response from the Network Codec. */ NCodecMessage msg = {}; rc = ncodec_read(nc, \u0026msg); if (rc \u003e 0) { printf(\"Message is: %s\\n\", (char*)msg.buffer); } else { printf(\"There was no message! (reason %d)\\n\", rc); } /* Close the Network Codec. */ ncodec_close(nc); return 0; } Typedefs NCodecConfigItem typedef struct NCodecConfigItem { const char * name; const char * value; } NCodecInstance typedef struct NCodecInstance { const char * mime_type; NCodecVTable codec; NCodecStreamVTable * stream; } NCodecMessage typedef struct NCodecMessage { uint32_t frame_id; uint8_t * buffer; size_t len; } NCodecStreamVTable typedef struct NCodecStreamVTable { NCodecStreamRead read; NCodecStreamWrite write; NCodecStreamSeek seek; NCodecStreamTell tell; NCodecStreamEof eof; NCodecStreamClose close; } NCodecVTable typedef struct NCodecVTable { NCodecConfig config; NCodecStat stat; NCodecWrite write; NCodecRead read; NCodecFlush flush; NCodecClose close; } Functions ncodec_close Parameters nc (NCODEC*) Network Codec object. ncodec_config Set an additional parameter on a Network Codec. If the parameter is already specified in the MIMEtype of the codex, the value being set will take priority over the value originally specified in the MIMEtype.\nParameters nc (NCODEC*) Network Codec object. item (NetworkConfigItem) The config item being set. ncodec_create Implemented in Codec library.\nParameters mime_type (const char*) The MIMEtype specifier. Returns NCodecOpen (pointer) Returns a pointer to a codec function which can open the specified MIMEtype. NULL This codec library does not support the specified MIMEtype. ncodec_flush Parameters nc (NCODEC*) Network Codec object. Returns 0 The Network Codec internal buffers were flushed to the connected stream. -ENOSTR The object represented by nc does not represent a valid stream. -ENOSR No stream resource has been configured. ncodec_load Implemented by integrator.\nParameters filename (const char*) Name of the Network Codec library to load. hint (const char*) Optional path from where to load the Network Codec. Returns 0 The Network Codec library way successfully loaded. -1 The Network Codec library could not be loaded. Inspect errno for more details. ncodec_open Implemented by integrator.\nParameters name (const char*) A name associated with the codec instance being opened. mime_type (const char*) The MIMEtype specifier. Returns NCODEC (pointer) Object representing the Network Codec. NULL The Network Codec could not be created. Inspect errno for more details. Error Conditions Available by inspection of errno.\nELIBACC Static library(ies) not loaded. EINVAL Stream parameter not valid. ENODATA A Network Codec matching the MIMEtype could not be found. ENOENT The ncodec_create was not found in any loaded static library. ncodec_read Read messages from a Network Codex until the stream represented by the codec is fully consumed (i.e. no more messages).\nThe codec owns the message buffer/memory returned by this function. Messages should be consumed immediately within a sequence of calls to ncodec_read (e.g. until ENOMSG), or duplicate the messages for later processing.\nParameters nc (NCODEC*) Network Codec object. msg (NCodecMessage*) (out) The message representation to write to the Network Codec. Caller owns the message buffer/memory. Returns : The number of bytes read from the Network Codec. Will be identical to the value returned in `msg.len`. Additional messages may remain on the Network Codec, after processing this message, repeat calls to `ncodec_read` until -ENOMSG is returned. -ENOMSG No message is available from the Network Codec. -ENOSTR The object represented by nc does not represent a valid stream. -ENOSR No stream resource has been configured. -EINVAL Bad msg argument. ncodec_stat Parameters nc (NCODEC*) Network Codec object. index (int*) (out) Index of the config item returned by this call. When there are no more config items to be returned, this value is set to -1 and an empty NetworkConfigItem object is returned. Returns NetworkConfigItem A config item. ncodec_write Write the provided message to the Network Codec object.\nThe caller owns the message buffer/memory and the codec implementation will encode (i.e. duplicate) the content of that message buffer/memory during this call.\nParameters nc (NCODEC*) Network Codec object. msg (NCodecMessage*) The message representation to write to the Network Codec. Caller owns the message buffer/memory. Returns +VE (int) The number of bytes written to the Network Codec. Will be identical to the value provided in msg.len. -ENOSTR The object represented by nc does not represent a valid stream. -EINVAL Bad msg argument. ","categories":"","description":"","excerpt":"Network Codec A Network Codec has two interfaces: a Codec Interface …","ref":"/dse.doc/apis/ncodec/","tags":"","title":"Network Codec API Reference"},{"body":"(v1.0.0)\nNetwork kind: Network metadata: name: CAN1 annotations: message_lib: examples/stub/data/message.so function_lib: examples/stub/data/function.so spec: messages: - message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t - signal: Alive annotations: struct_member_name: alive struct_member_offset: 1 struct_member_primitive_type: uint8 - signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t functions: encode: - function: counter_inc_uint8 annotations: position: 1 - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network definition.\nSupported annotations: Annotation Description message_lib Relative path of the shared library containing the Network Message symbols. function_lib Relative path of the shared library containing Network Function symbols. node_id The identifier of the Node used to indicate the sender of a network message. Typically specified in a mimeTYPE for the Network Signal, however a value may also be specified here. interface_id The identifier of the Interface of the Node used to send a network message. Typically specified in a mimeTYPE for the Network Signal, however a value may also be specified here. bus_id The identifier of the Bus connected to the Interface of the Node. Typically specified in a mimeTYPE for the Network Signal, however a value may also be specified here. Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » messages [Message] true A list of messages belonging to this Network. Enumerated Values Property Value kind Network Message message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t functions: encode: - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network message definition.\nSupported annotations: Annotation Description struct_name Name of the typedef/struct representing the message. struct_size Size of the message struct (in bytes). frame_id The frame id of the message when encoded to a bus transport (e.g. CAN Frame ID). frame_length The length of the message when encoded (in bytes). cycle_time_ms Message will be sent according to the specified schedule (milliseconds). Properties Name Type Required Description message string true The name of the message. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties string false none signals [Signal] false A list of signals represented in this message. functions object false Message functions to be applied to this message. » encode [Function] false Message functions applied to the encode processing path (i.e. from Signal to Network interface). Functions are implicitly applied in the order of definition. » decode [Function] false Message functions applied to the decode processing path (i.e. from Network to Signal interface). Functions are implicitly applied in the order of definition. Signal signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t A Network signal definition.\nSupported annotations: Annotation Description init_value The signal is initialised to this value. The value will be interpreted according to the struct_member_primitive_type annotation. struct_member_name Name of the struct member which represents this signal. struct_member_offset Offset of the member in the struct (in bytes). struct_member_primitive_type The primitive type of the member (select from int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t, float or double). Properties Name Type Required Description signal string true The name of the signal. annotations Message/properties/annotations false Non identifying information (i.e. information specific to the object itself). Function function: crc_generate annotations: position: 0 A Network Function definition.\nProperties Name Type Required Description function string true The name of the function (i.e. the name of the symbol in the Network Function shared library). annotations Message/properties/annotations false Non identifying information (i.e. information specific to the object itself). undefined\n","categories":"","description":"","excerpt":"(v1.0.0)\nNetwork kind: Network metadata: name: CAN1 annotations: …","ref":"/dse.doc/schemas/yaml/network/","tags":["Schema"],"title":"Schema: Network"},{"body":"(v0.0.1)\nParameterSet kind: ParameterSet metadata: name: string labels: property1: string property2: string annotations: property1: string property2: string spec: parameters: - parameter: string value: string annotations: property1: string property2: string A parameter_set definition.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » parameters [Parameter] true A list of parameters belonging to this parameter set. Enumerated Values Property Value kind ParameterSet Parameter parameter: string value: string annotations: property1: string property2: string A signal parameter definition.\nProperties Name Type Required Description parameter string true The name of the parameter. value string false The value of the parameter. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties string false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nParameterSet kind: ParameterSet metadata: name: string …","ref":"/dse.doc/schemas/yaml/parameterset/","tags":["Schema"],"title":"Schema: ParameterSet"},{"body":"(v0.0.1)\nPropagator kind: Propagator metadata: name: string labels: property1: string property2: string annotations: property1: string property2: string spec: options: direction: both signals: - signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A propagator definition.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » options object false none »» direction string false none » signals [SignalEncoding] false A list of signals belonging to this propagator. Enumerated Values Property Value kind Propagator direction both direction forward direction reverse SignalEncoding signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A signal encoding definition.\nProperties Name Type Required Description signal string true The name of the signal. target string false none encoding object false none » linear object false none »» min number false none »» max number false none »» factor number false none »» offset number false none » mapping [object] false none »» name string false none »» source number false none »» target number false none »» range object false none »»» min number false none »»» max number false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nPropagator kind: Propagator metadata: name: string labels: …","ref":"/dse.doc/schemas/yaml/propagator/","tags":["Schema"],"title":"Schema: Propagator"},{"body":"(v1.0.0)\nRunnable kind: Runnable metadata: name: target annotations: target_lib: examples/stub/lib/target.so spec: tasks: - function: task_init schedule: 0 - function: task_5ms schedule: 5 - function: task_10ms schedule: 10 - function: task_20ms schedule: 20 - function: task_40ms schedule: 40 A Runnable definition.\nSupported annotations: Annotation Description target_lib Relative path of the shared library containing the Runnable library. Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » tasks [Task] true A list of tasks belonging to this Runnable. Enumerated Values Property Value kind Runnable Task function: task_init schedule: 20 A Runnable task definition.\nProperties Name Type Required Description function string true The name of the function representing the task. This function\nwill be loaded from the library referenced by the Runnable\nannotation target_lib. schedule integer true The task schedule interval (in milliseconds). undefined\n","categories":"","description":"","excerpt":"(v1.0.0)\nRunnable kind: Runnable metadata: name: target annotations: …","ref":"/dse.doc/schemas/yaml/runnable/","tags":["Schema"],"title":"Schema: Runnable"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/schema/","tags":"","title":"Schema"},{"body":"Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.\nTypedefs SchemaLabel typedef struct SchemaLabel { const char * name; const char * value; } SchemaObject typedef struct SchemaObject { const char * kind; const char * name; void * doc; void * data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char * kind; const char * name; SchemaLabel * labels; int labels_len; void * data; } SchemaSignalObject typedef struct SchemaSignalObject { const char * signal; void * data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec. The caller should free the object by calling schema_release_channel_selector().\nThe returned SchemaObjectSelector can be used when calling schema_object_search() to search for schema objects.\nNote: A channel selector will not match on metadata/name.\nParameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects that will searched by the generated selector. channel (ChannelSpec*) A channel spec object. kind (const char*) The kind of schema object to select. Returns SchemaObjectSelector (pointer) The complete selector object. NULL A selector object could not be created. This return value does not represent an error condition. The caller will determine if this condition represents and error (typically a configuration error). schema_object_enumerator Enumerate over all child objects of a schema list object. Each child object is marshalled via the generator function and returned to the caller.\nWhen index exceeds the length of the schema list object the function returns NULL and the enumeration is complete.\nParameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects which will be enumerated over.. object (SchemaObject*) The schema list object to enumerate over. path (const char*) Enumerate objects located at this path, relative from the object. index (uint32_t*) Maintains the enumerator postion between calls. Set to 0 to begin a new schema object enumeration (i.e. from the first object in the list). generator (SchemaObjectGenerator) A generator function which creates the required schema object. Returns void* Pointer to the generated object created by the generator function. The caller must free this object. NULL The enumeration is complete. schema_object_search Search the collection of schema objects according to the selector, and call the handler function for each matching object. Schema objects are searched in the order they were parsed (i.e. listed order at the CLI).\nExample #include \u003cdse/modelc/model.h\u003e #include \u003cdse/modelc/schema.h\u003e #include \u003cdse/logger.h\u003e int match_handler(ModelInstanceSpec* mi, SchemaObject* object) { uint32_t index = 0; SchemaSignalObject* so; do { so = schema_object_enumerator(mi, object, \"spec/signals\", \u0026index, schema_signal_object_generator); if (so == NULL) break; if (so-\u003esignal) { log_debug(\" signal identified: %s\", so-\u003esignal); } free(so); } while (1); return 0; } void object_search(ModelInstanceSpec* mi, const char* channel_name) { ChannelSpec channel_spec = { .name = channel_name }; SchemaObjectSelector* selector = schema_build_channel_selector( mi, \u0026channel_spec, \"SignalGroup\"); if (selector) { schema_object_search(mi, selector, match_handler); } schema_release_selector(selector); } Parameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects which will be searched. selector (SchemaObjectSelector*) A selector object, schema objects are matched as follows: kind - matches the object kind (if NULL matches all object kinds). name - matches the object name (if NULL matches all object names). labels[] - matches all labels of the object (i.e. AND). handler (SchemaMatchHandler) A handler function which is called for each matching schema object. The handler can control the search continuation by returning as follows: 0 - the search should continue until no more matches are found. +ve - the search should stop and return 0 (indicating success). -ve - the search should abort, set errno with a value to indicate the failing condition, and return +ve (indicating failure). Returns 0 The schema search successfully completed. +ve Failure, inspect errno for an indicator of the failing condition. schema_release_selector Release any allocated memory in a SchemaObjectSelector object.\nParameters selector (SchemaObjectSelector*) A selector object, created by calling schema_build_channel_selector(). schema_signal_object_generator Generate a schema signal object.\nParameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects which will be searched. data (void*) The YAML node to generate from. Returns void* Pointer to the generated schema signal object. The caller must free this object. NULL The object cannot be generated. ","categories":"","description":"","excerpt":"Schema API The Schema API provides a number of functions for parsing …","ref":"/dse.doc/apis/modelc/schema/","tags":"","title":"Schema API Reference"},{"body":"(v0.0.1)\nSignalData Data = [[0..N],[0..N]] MsgPack encoded Signal Data. Number of elements in each nested array should be identical.\nProperties oneOf\nName Type Required Description anonymous SignalUid false Signal UID. xor\nName Type Required Description anonymous SignalValueNumeric false Numeric signal value. The value may be encoded as any integer or float type. xor\nName Type Required Description anonymous SignalValueBinary false Binary signal value. SignalUid 0 Signal UID.\nProperties Name Type Required Description anonymous integer(int32) false Signal UID. SignalValueNumeric 0 Numeric signal value. The value may be encoded as any integer or float type.\nProperties Name Type Required Description anonymous number(double) false Numeric signal value. The value may be encoded as any integer or float type. SignalValueBinary string Binary signal value.\nProperties Name Type Required Description anonymous string(binary) false Binary signal value. undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nSignalData Data = [[0..N],[0..N]] MsgPack encoded Signal …","ref":"/dse.doc/schemas/yaml/signaldata/","tags":["Schema"],"title":"Schema: SignalData"},{"body":"(v0.0.1)\nSignalGroup kind: SignalGroup metadata: name: string labels: property1: string property2: string annotations: property1: string property2: string spec: signals: - signal: string annotations: property1: string property2: string A signal group definition.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » signals [Signal] true A list of signals belonging to this signal group. Enumerated Values Property Value kind SignalGroup Signal signal: string annotations: property1: string property2: string A signal definition.\nProperties Name Type Required Description signal string true The name of the signal. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties string false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nSignalGroup kind: SignalGroup metadata: name: string labels: …","ref":"/dse.doc/schemas/yaml/signalgroup/","tags":["Schema"],"title":"Schema: SignalGroup"},{"body":"simbus Run the SimBus.\nSynopsis # Run the SimBus, specifying the Stack YAML file. $ dse.simbus --logger 2 --timeout 1 stack.yaml Options $ simbus --help Standalone SimBus usage: [--transport \u003ctransport\u003e] [--uri \u003cendpoint\u003e] (i.e. redis://localhost:6379) [--host \u003chost url\u003e] *** depreciated, use --uri *** [--port \u003cport number\u003e] *** depreciated, use --uri *** [--stepsize \u003cdouble\u003e] [--endtime \u003cdouble\u003e] [--uid \u003cmodel uid\u003e] [--name \u003cmodel name\u003e] *** normally required *** [--timeout \u003cdouble\u003e] [--logger \u003cnumber\u003e] 0..6 *** 0=more, 6=less, 3=INFO *** [--file \u003cmodel file\u003e] [--path \u003cpath to model\u003e] *** relative path to Model Package *** [YAML FILE [,YAML FILE] ...] ","categories":"","description":"","excerpt":"simbus Run the SimBus.\nSynopsis # Run the SimBus, specifying the Stack …","ref":"/dse.doc/docs/user/tools/simbus/","tags":["ModelC","CLI"],"title":"simbus"},{"body":"SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC \u003c-\u003e SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.\nComponent Diagram @startuml simmock-objects title SimMock Objects package \"SimBus Mock\" { class Signal \u003c\u003cSignalVector\u003e\u003e { +uint32_t count +double scalar[] +annotation() } class Network \u003c\u003cSignalVector\u003e\u003e { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.yaml .... kind: \u003cb\u003eSignalGroup metadata: name: \u003cb\u003esignal labels: channel: \u003cb\u003esignal_vector ] file svNet [ signalgroup.yaml .... kind: \u003cb\u003eSignalGroup metadata: name: \u003cb\u003enetwork labels: channel: \u003cb\u003enetwork_vector annotations: vector_type: \u003cb\u003ebinary ] Signal -\u003e svSig Network -\u003e svNet } map ModelMock { sv_signal *--\u003e Signal sv_network *--\u003e Network } map SimMock { model *--\u003e ModelMock sv_signal *--\u003e Signal sv_network_rx *-\u003e Network sv_network_tx *-\u003e Network } center footer Dynamic Simulation Environment @enduml Typedefs FrameCheck typedef struct FrameCheck { int frame_id; int offset; int value; } ModelMock typedef struct ModelMock { const char * name; int * mi; int * sv_signal; int * sv_network; int * sv_save; int model_setup_func; int model_exit_func; } SignalCheck typedef struct SignalCheck { int index; double value; } SimMock typedef struct SimMock { int sim; double step_size; ModelMock * model; void * doc_list; double model_time; int * sv_signal; int * sv_network_rx; int * sv_network_tx; } Functions simmock_alloc Create a SimMock object.\nParameters inst_names[] (const char*) Array of model instance names which should be allocated in the SimMock object. count (size_t) The number of elements in the inst_names array. Returns SimMock* The allocated SimMock object. Caller should free by calling simmock_free(). simmock_configure Configure a SimMock object with a list of command line arguments (as would be used by the ModelC.exe).\nExample #include \u003cdse/testing.h\u003e #include \u003cdse/modelc/mocks/simmock.h\u003e int test_setup(void** state) { const char* inst_names[] = { \"target_inst\", \"network_inst\", }; char* argv[] = { (char*)\"test_runnable\", (char*)\"--name=target_inst;network_inst\", (char*)\"--logger=5\", // 1=debug, 5=QUIET (commit with 5!) (char*)\"../../../../tests/cmocka/network/stack.yaml\", (char*)\"../../../../tests/cmocka/network/signalgroup.yaml\", (char*)\"../../../../tests/cmocka/network/network.yaml\", (char*)\"../../../../tests/cmocka/network/model.yaml\", (char*)\"../../../../tests/cmocka/network/runnable.yaml\", }; SimMock* mock = simmock_alloc(inst_names, ARRAY_SIZE(inst_names)); simmock_configure(mock, argv, ARRAY_SIZE(argv), ARRAY_SIZE(inst_names)); simmock_load(mock, true); simmock_setup(mock, \"signal\", \"network\"); /* Return the mock. */ *state = mock; return 0; } Parameters mock (SimMock*) A SimMock object. argv (char*) Array of arguments. argc (size_t) Number of elements in the argv array. expect_model_count (size_t) The expected number of models to be configured (based on the parsed list of arguments). simmock_exit Call model_exit() for each model.\nParameters mock (SimMock*) A SimMock object. simmock_find_model Find a MockModel object contained within a SimMock object.\nParameters mock (SimMock*) A SimMock object. name (const char*) The name of the model to find. Returns MockModel* The identified MockModel object. NULL No MockModel was found. simmock_frame_check Check the content of a binary signal for various frames. The binary signal should be represented by a Network Codec (NCodec) object.\nExample #include \u003cdse/testing.h\u003e #include \u003cdse/modelc/mocks/simmock.h\u003e void test_network__frame_check(void** state) { SimMock* mock = *state; /* 0ms - initial tick, Rx consumed, Tx of initial content. */ { for (uint32_t i = 0; i \u003c 1; i++) { assert_int_equal(simmock_step(mock, true), 0); } FrameCheck f_checks[] = { { .frame_id = 0x1f3u, .offset = 0, .value = 0x01 }, { .frame_id = 0x1f4u, .offset = 1, .value = 0x02 }, { .frame_id = 0x1f5u, .offset = 4, .value = 0x02 }, }; simmock_print_network_frames(mock, LOG_DEBUG); simmock_frame_check(mock, \"network_inst\", \"can_bus\", f_checks, ARRAY_SIZE(f_checks)); } } Parameters mock (SimMock*) A SimMock object. model_name (const char*) The name of the model to check. sig_name (const char*) The name of the binary signal where frames should be located. checks (FrameCheck*) Array of FrameCheck objects. count (size_t) The number elements in the checks array. simmock_free Destroy and free resources allocated to a SimMock object.\nParameters mock (SimMock*) The SimMock object to be released. simmock_load Load all of the models referenced by a SimMock object.\nParameters mock (SimMock*) A SimMock object. expect_exit_function (bool) Indicate that model libraries should contain a model_exit function. simmock_print_network_frames Print the frames contained in each network vector of each model.\nParameters mock (SimMock*) A SimMock object. level (int) The log level to print at. simmock_print_scalar_signals Print the scalar signal values of each signal vector of each model.\nParameters mock (SimMock*) A SimMock object. level (int) The log level to print at. simmock_read_frame Read a frame, using the associated NCodec object, from the specified binary signal.\nParameters sv (SignalVector*) A Signal Vector object. sig_name (const char*) The name of the binary signal where frames should be written. data (uint8_t*) Array for the read data. The data is preallocated by the caller. len (size_t) Length of the data array. Returns uint32_t The Frame ID associated with the read data. 0 No frame was found in the specified binary signal. simmock_setup Calls the model_setup() function on each model and then creates Signal Vectors for each model. Additional Signal Vectors are created to facilitate the mocked behaviour of a simulation (via the SimMock object).\nParameters mock (SimMock*) A SimMock object. sig_name (const char*) The name of the scalar channel. sig_name (const char*) The name of the binary channel. simmock_signal_check Check the values of various signals on the Signal Vector (scalar).\nExample #include \u003cdse/testing.h\u003e #include \u003cdse/modelc/mocks/simmock.h\u003e #define SIG_task_init_done 1 #define SIG_task_5_active 2 #define SIG_task_5_counter 6 void test_network__signal_check(void** state) { SimMock* mock = *state; /* 0ms - initial tick, Rx consumed, Tx of initial content. */ { for (uint32_t i = 0; i \u003c 1; i++) { assert_int_equal(simmock_step(mock, true), 0); } SignalCheck s_checks[] = { { .index = SIG_task_init_done, .value = 1.0 }, { .index = SIG_task_5_active, .value = 0.0 }, { .index = SIG_task_5_counter, .value = 0.0 }, }; simmock_print_scalar_signals(mock, LOG_DEBUG); simmock_signal_check(mock, \"network_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); } } Parameters mock (SimMock*) A SimMock object. model_name (const char*) The name of the model to check. checks (SignalCheck*) Array of SignalCheck objects. count (size_t) The number elements in the checks array. func (SignalCheckFunc) Optional function pointer for performing the signal check. simmock_step Calls model_step() on each model and manages the mocked exchange of both scalar and binary Signal Vectors.\nParameters mock (SimMock*) A SimMock object. assert_rc (bool) Indicate that an assert check (value 0) should be made for each return from a call to model_step(). Returns int The combined (or’ed) return code of each call to model_step(). simmock_write_frame Write a frame, using the associated NCodec object, to the specified binary signal.\nParameters sv (SignalVector*) A Signal Vector object. sig_name (const char*) The name of the binary signal where frames should be written. data (uint8_t*) Array of data to write (in the frame). len (size_t) Length of the data array. frame_id (uint32_t) The Frame ID associated with the data. ","categories":"","description":"","excerpt":"SimMock API The SimMock API provides interfaces for the development of …","ref":"/dse.doc/apis/modelc/simmock/","tags":"","title":"SimMock API Reference"},{"body":"(v0.0.1)\nStack kind: Stack metadata: name: string labels: property1: string property2: string annotations: property1: string property2: string spec: connection: timeout: string transport: redis: uri: string timeout: 0 models: - name: string uid: 0 model: name: string mcl: strategy: string models: - name: string metadata: property1: string property2: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string A stack definition.\nProperties Name Type Required Description kind string true Indicate the type of object. metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none spec object true none » connection object false none »» timeout string false Model timeout for messages from the transport. »» transport object false none oneOf\nName Type Required Description »»» anonymous object false none »»»» redis RedisConnection true Redis connection. xor\nName Type Required Description »»» anonymous object false none »»»» redispubsub RedisConnection true Redis connection. xor\nName Type Required Description »»» anonymous object false none »»»» mq MessageQueue true Message Queue based connection. continued\nName Type Required Description » models [ModelInstance] false [A model instance object.] Enumerated Values Property Value kind Stack ModelInstance name: string uid: 0 model: name: string mcl: strategy: string models: - name: string metadata: property1: string property2: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: property1: string property2: string A model instance object.\nProperties Name Type Required Description name string true none uid integer true none model object true none » name string true none » mcl object false none »» strategy string true none »» models [object] true A list of models belonging to this MCL. »»» name string true The name of the MCL model. » metadata object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none channels [object] false none » name string false The name of the channel, used when connecting this channel to the SimBus. » alias string false The alias of the channel, used when the channel name will be determined elsewhere. » expectedModelCount integer false Indicates how many models are expected to connect to this channel (used by SimBus only). » selectors object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties string false none RedisConnection uri: string timeout: 0 Redis connection.\nProperties Name Type Required Description uri string false none timeout integer false none MessageQueue uri: string Message Queue based connection.\nProperties Name Type Required Description uri string false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nStack kind: Stack metadata: name: string labels: property1: …","ref":"/dse.doc/schemas/yaml/stack/","tags":["Schema"],"title":"Schema: Stack"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/testing/","tags":"","title":"Testing"},{"body":"CMocka Testing for C Code The DSE Projects use CMocka for both Unit and Integration testing. This document introduces the typical CMocka Test Project and explains the testing features which are most often used when developing.\nCode Layout and Test Organisation L- tests/cmocka Directory containing CMocka tests. L- target An individual test target (single test executable). L- __tests__.c Entry point for the test target (runs test groups). L- test_foo.c Contains a test group (e.g. related tests). L- CMakeLists.txt Make definitions for all test targets. L- Makefile CMake automation. L- Makefile High-level build automation. Example Test Files tests/cmocka/target/__test__.c // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cdse/testing.h\u003e extern int run_foo_tests(void); int main() { int rc = 0; rc |= run_foo_tests(); return rc; } tests/cmocka/target/test_foo.c // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cdse/testing.h\u003e #define UNUSED(x) ((void)x) #define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0])) typedef struct FooMock { int foo_value; } FooMock; static int test_setup(void** state) { FooMock* mock = calloc(1, sizeof(FooMock)); mock-\u003efoo_value = 4; *state = mock; return 0; } static int test_teardown(void** state) { FooMock* mock = *state; if (mock) free(mock); return 0; } typedef struct FooTest { int test_value; int remainder; } void test_foo__data_driven(void** state) { FooMock* mock = *state; FooTest tests[] = { { .test_value = 5, .remainder = 1 }, { .test_value = 8, .remainder = 4 }, { .test_value = 2, .remainder = -2 }, }; for (size_t i = 0; i \u003c ARRAY_SIZE(tests); i++) { int remainder = tests[i].test_value - mock-\u003efoo_value; assert_int_equal(remainder, tests[i].remainder); } } int run_foo_tests(void) { void* s = test_setup; void* t = test_teardown; const struct CMUnitTest tests[] = { cmocka_unit_test_setup_teardown(test_foo__data_driven, s, t), }; return cmocka_run_group_tests_name(\"FOO\", tests, NULL, NULL); } tests/cmocka/CMakeLists.txt cmake_minimum_required(VERSION 3.21) project(test_project) include(FetchContent) include(GNUInstallDirs) set(CMAKE_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/_out) set(CMAKE_ENABLE_EXPORTS ON) set(CMAKE_C_STANDARD 99) set(CMAKE_C_STANDARD_REQUIRED TRUE) set(CMAKE_POSITION_INDEPENDENT_CODE ON) set(CMAKE_BUILD_TYPE Debug) set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -O3 -ggdb\") list(APPEND C_CXX_WARNING_FLAGS -Wall -W -Wwrite-strings -Wno-missing-field-initializers -Wno-misleading-indentation ) add_compile_options(${C_CXX_WARNING_FLAGS}) FetchContent_Declare(dse_clib URL https://github.com/boschglobal/dse.clib/archive/refs/tags/v1.0.5.tar.gz SOURCE_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.clib\" ) FetchContent_MakeAvailable(dse_clib) set(DSE_CLIB_SOURCE_DIR ${dse_clib_SOURCE_DIR}/dse/clib) set(DSE_CLIB_INCLUDE_DIR \"${DSE_CLIB_SOURCE_DIR}/../..\") add_executable(test_target runnable/__test__.c runnable/test_foo.c ) target_include_directories(test_target PRIVATE ${DSE_CLIB_INCLUDE_DIR} ./ ) target_compile_definitions(test_target PUBLIC CMOCKA_TESTING ) target_link_libraries(test_target PRIVATE cmocka dl m ) install(TARGETS test_target) tests/cmocka/Makefile GDB_CMD ?= valgrind -q --leak-check=yes # GDB_CMD ?= gdb -q -ex='set confirm on' -ex=run -ex=quit default: build setup: mkdir build; cd build; cmake .. build: # Build from scratch if no build dir. if [ ! -d \"build\" ]; then make setup; fi # Build. cd build; make cd build; make install .PHONY: run run: cd build/_out; $(GDB_CMD) bin/test_target .PHONY: clean clean: rm -rf build .PHONY: cleanall cleanall: clean Makefile export NAMESPACE = fsil export MODULE = runnable export PROJECT_URL ?= $(GITHUB_ORG)/$(NAMESPACE).$(MODULE).git export DOCKER_REPO ?= ghcr.io/boschglobal export EXTERNAL_BUILD_DIR ?= /tmp/$(NAMESPACE).$(MODULE) export PACKAGE_ARCH ?= linux-amd64 export CMAKE_TOOLCHAIN_FILE ?= $(shell pwd -P)/extra/cmake/$(PACKAGE_ARCH).cmake export PACKAGE_VERSION ?= 0.0.2 export GCC_BUILDER_IMAGE ?= $(DOCKER_REPO)/dse-gcc-builder:main ifneq ($(CI), true) DOCKER_BUILDER_CMD := docker run -it --rm \\ --volume $$(pwd):/tmp/repo \\ --volume $(EXTERNAL_BUILD_DIR):$(EXTERNAL_BUILD_DIR) \\ --volume ~/.ccache:/root/.ccache \\ --env CMAKE_TOOLCHAIN_FILE=/tmp/repo/extra/cmake/$(PACKAGE_ARCH).cmake \\ --env EXTERNAL_BUILD_DIR=$(EXTERNAL_BUILD_DIR) \\ --env PACKAGE_ARCH=$(PACKAGE_ARCH) \\ --env HTTP_PROXY=$(http_proxy) \\ --env HTTPS_PROXY=$(https_proxy) \\ --env NO_PROXY=$(no_proxy) \\ --env AR_USER=$(AR_USER) \\ --env AR_TOKEN=$(AR_TOKEN) \\ --env GHE_USER=$(GHE_USER) \\ --env GHE_TOKEN=$(GHE_TOKEN) \\ --env DOCKER_REPO=$(DOCKER_REPO) \\ --env PROJECT_URL=$(PROJECT_URL) \\ --env GDB_CMD=\"$(GDB_CMD)\" \\ --env PACKAGE_VERSION=$(PACKAGE_VERSION) \\ --env NAMESPACE=$(NAMESPACE) \\ --env MODULE=$(MODULE) \\ --workdir /tmp/repo \\ $(GCC_BUILDER_IMAGE) endif do-test_cmocka-build: $(MAKE) -C tests/cmocka build do-test_cmocka-run: $(MAKE) -C tests/cmocka run .PHONY: test_cmocka test_cmocka: @${DOCKER_BUILDER_CMD} $(MAKE) do-test_cmocka-build @${DOCKER_BUILDER_CMD} $(MAKE) do-test_cmocka-run .PHONY: test test: test_cmocka Testing Features and Integrations DSE Testing Headers The DSE C Lib includes a header file dse/testing.h which can be used to include the required set of CMocka headers and other testing related adaptations. The functionality of the header is enabled with build defines as follows:\nCMOCKA_TESTING - enables the set of CMocka include files. Typically used in CMocka test projects.\nUNIT_TESTING - enables the set of CMocka include files and also enables the extended memory testing functionality in CMocka.\nWhen these defines are not used (i.e. during testing), the dse/testing.h header file has no effect. It can be safely included by any source code.\nTip : Valgrind is an easier form of memory testing than that offered by CMocka. In general, CMocka memory testing requires instrumentation of all code included in a test target (via dse/testing.h). This becomes troublesome when integrating external libraries as the CMocka techniques do not work well when all code is not similarly instrumented (as is the case with external libraries). In short, Valgrind is easier.\nValgrind Memory Checks Valgrind memory checks can be enabled within the build environments by setting the environment variable GDB_CMD before running a test target.\n$ export GDB_CMD=\"valgrind -q --leak-check=full --track-origins=yes --error-exitcode=808\" $ make test ... This is the default setting for many DSE Projects.\nGDB Based Debugging Runtime exceptions (e.g. segmentation faults) can be quickly debugged by enabling GDB within the build environments by setting the environment variable GDB_CMD before running a test target.\n$ export GDB_CMD=\"gdb -q -ex='set confirm on' -ex=run -ex=quit\" $ make test ... More information about using GDB is available at Model C Debug Techniques.\nTesting Techniques Data Driven Tests An especially powerful technique for writing tests which uses tabular data to execute and test a variety of conditions. A data driven test typically has two parts:\nThe table (an array) containing data which will be fed, row by row, into the function being tested. Each row of the table will contain both arguments and expected responses (or other evaluation criteria).\nThe evaluation which, for each row of the table, will call the functions being tested and evaluate the results.\nExample Data Driven Test Example data driven test. #include \u003cdse/testing.h\u003e typedef struct TestRow { int value; int result; } void test_foo__data_driven(void** state) { Mock* mock = *state; TestRow tests[] = { { .value = 5, .result = 10 }, { .value = 8, .result = 16 }, { .value = 2, .result = 4 }, }; for (size_t i = 0; i \u003c ARRAY_SIZE(tests); i++) { int result = double(tests[i].value); assert_int_equal(result, tests[i].result); } } Integration Testing Integration testing is possible by creating a test which directly links against the DSE Model C Library and uses its “MStep” API to load, configure and step a model. With this technique it is possible to verify the following:\nConfiguration files are correctly parsed. Model configuration and initialisation. Model operation, externally observed via changes to signals (i.e. Signal Vectors). Detection of memory leaks (using Valgrind). Example MStep Test Example MStep test loading and stepping a model. #include \u003cdlfcn.h\u003e #include \u003cdse/testing.h\u003e #include \u003cdse/logger.h\u003e #include \u003cdse/modelc/model.h\u003e #include \u003cdse/restbus/restbus.h\u003e void test_mstep(void** state) { char* argv[] = { (char*)\"test_mstep\", (char*)\"--name=stub_inst\", (char*)\"--logger=5\", // QUIET (char*)\"examples/stub/data/stack.yaml\", (char*)\"../../../../tests/cmocka/mstep/model_mstep.yaml\", (char*)\"../../../../tests/cmocka/mstep/restbus_mstep.yaml\", }; int argc = ARRAY_SIZE(argv); int rc; ModelCArguments args; SimulationSpec sim; ModelInstanceSpec* mi; /* Setup the ModelC interfaces. */ modelc_set_default_args(\u0026args, \"test\", 0.0005, 0.0010); modelc_parse_arguments(\u0026args, argc, argv, \"MStep Test\"); rc = modelc_configure(\u0026args, \u0026sim); assert_int_equal(rc, 0); mi = modelc_get_model_instance(\u0026sim, args.name); assert_non_null(mi); /* Directly load the Restbus Model. */ void* handle = dlopen(mi-\u003emodel_definition.full_path, RTLD_NOW | RTLD_LOCAL); assert_non_null(handle); ModelSetupHandler model_setup_func = dlsym(handle, MODEL_SETUP_FUNC_STR); ModelExitHandler model_exit_func = dlsym(handle, MODEL_EXIT_FUNC_STR); assert_non_null(model_setup_func); assert_non_null(model_exit_func); /* Call the Model Setup. */ rc = model_setup_func(mi); assert_int_equal(rc, 0); SignalVector* sv = model_sv_create(mi); /* Locate the restbus and network vectors. */ SignalVector* sv_restbus = NULL; SignalVector* sv_network = NULL; while (sv \u0026\u0026 sv-\u003ename) { if (strcmp(sv-\u003ename, \"restbus\") == 0) sv_restbus = sv; if (strcmp(sv-\u003ename, \"network\") == 0) sv_network = sv; /* Next signal vector. */ sv++; } assert_non_null(sv_restbus); assert_string_equal(sv_restbus-\u003ename, \"restbus\"); assert_int_equal(sv_restbus-\u003ecount, 3); assert_non_null(sv_restbus-\u003escalar); assert_non_null(sv_network); assert_string_equal(sv_network-\u003ename, \"network\"); assert_int_equal(sv_network-\u003ecount, 1); assert_non_null(sv_network-\u003ebinary); assert_non_null(sv_network-\u003elength); assert_non_null(sv_network-\u003ebuffer_size); /* Check the initial values. */ assert_double_equal(sv_restbus-\u003escalar[0], 1.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[1], 0.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[2], 265.0, 0.0); assert_null(sv_network-\u003ebinary[0]); assert_int_equal(sv_network-\u003elength[0], 0); assert_int_equal(sv_network-\u003ebuffer_size[0], 0); /* Step the model - ensure no can_tx based on setting initial values. */ rc = modelc_step(mi, args.step_size); assert_int_equal(rc, 0); assert_double_equal(sv_restbus-\u003escalar[0], 1.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[1], 0.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[2], 265.0, 0.0); assert_null(sv_network-\u003ebinary[0]); assert_int_equal(sv_network-\u003elength[0], 0); assert_int_equal(sv_network-\u003ebuffer_size[0], 0); sv_network-\u003ereset(sv_network, 0); /* Call the Model Exit. */ rc = model_exit_func(mi); assert_int_equal(rc, 0); } CMake file (partial) with linking to DSE Model C Library. ... # External Project - DSE ModelC Library (for linking to mstep) # ------------------------------------- set(MODELC_BINARY_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.modelc.lib\") find_library(MODELC_LIB NAMES libmodelc_bundled.a PATHS ${MODELC_BINARY_DIR}/lib REQUIRED NO_DEFAULT_PATH ) add_library(modelc STATIC IMPORTED GLOBAL) set_target_properties(modelc PROPERTIES IMPORTED_LOCATION \"${MODELC_LIB}\" INTERFACE_INCLUDE_DIRECTORIES \"${MODELC_BINARY_DIR}\" ) ... # Target - MSTEP # -------------- add_executable(test_mstep ) target_include_directories(test_mstep PRIVATE ./ ) target_compile_definitions(test_mstep PUBLIC CMOCKA_TESTING PRIVATE PLATFORM_OS=\"${CDEF_PLATFORM_OS}\" PLATFORM_ARCH=\"${CDEF_PLATFORM_ARCH}\" ) target_link_libraries(test_mstep PUBLIC -Wl,-Bstatic modelc -Wl,-Bdynamic ${CMAKE_DL_LIBS} PRIVATE cmocka dl m ) install(TARGETS test_mstep) Mocking Functions Mock functions are used to adjust (or mimic) the behaviour of real functions in situations where the normal behaviour of a real function is not desired; either because the real function might not operate normally (missing dependencies), or when a particular behaviour needs to be injected (to test a related behaviour). CMocka provides a stack based mocking system which makes it possible to implement and inject mocked functional behaviours.\nThese mocking features are:\nexpect_value() - indicate that the mock function should be called with this parameter set to the specified value. Useful when the mock function is called indirectly from the code being tested.\ncheck_expected() - the mock function checks that the provided parameter matched the expected value (set by expect_value()).\nwill_return() - push a value onto the mock stack before the mocked function is called (i.e. called in test code). Expected to be called in a pair with mock().\nmock() - pop a value from the mock stack. Called inside the mock function.\nExample Mock Example mocked function and test case. #include \u003cdse/testing.h\u003e /* The real function to be mocked. */ int test_function(int a, int b); /* The mock function, prefixed with '__wrap_'. */ int __wrap_test_function(int a, int b) { /* Test that the correct parameters were passed to the mock. */ check_expected(a); check_expected(b); /* mock() - Pop values from the stack of test values. */ int a_wrap = mock_type(int); int b_wrap = mock_type(int); /* Condition/behaviour being mocked. */ if (a_wrap == 1 \u0026\u0026 b_wrap == 2) return 3; return 0; } /* Test functions. */ void test_success(void **state) { /* Push expect values to the mock stack. */ expect_value(__wrap_test_function, a, 1); expect_value(__wrap_test_function, b, 2); /* Push values to the mock stack. */ will_return(__wrap_test_function, 1); will_return(__wrap_test_function, 2); /* Call the original function, and evaluate the mocked behaviour. */ assert_int_equal(test_function(1, 2), 3); } int main(void) { const struct CMUnitTest tests[] = { cmocka_unit_test(test_success), }; return cmocka_run_group_tests(tests, NULL, NULL); } Inline Python with Cog Info : Cog usage is experimental in DSE Test Projects.\nCog is a useful technique for preprocessing Python scripts embedded in C code. Interesting use cases include:\nCreation of “here documents” (text documents embedded in code files). Generation of C code, using cog.outl() to write code into the same file during cog processing. Example Cog Integration Embedded Cog Heredoc. #include \u003cdse/testing.h\u003e #define UNUSED(x) ((void)x) /* Cog Heredoc. */ /*[[[cog yaml=\"\"\" kind: SignalGroup metadata: name: network_signals spec: signals: - signal: RAW \"\"\" with open('sg.yaml', 'w') as f: f.write(yaml) ]]]*/ /*[[[end]]]*/ int main(void) { /* Test implementation ... */ } CMake integration. # Setup preprocessing to generate output files at configuration stage. execute_process(COMMAND cog.py ${CMAKE_CURRENT_BINARY_DIR}/../../util/test.c) # GLOB the generated files and install. file (GLOB GENERATED_YAML_FILES ${CMAKE_CURRENT_BINARY_DIR}/../*.yaml ) install( FILES ${GENERATED_YAML_FILES} DESTINATION data/yaml ) # Setup a custom command to invoke cog. add_custom_command( OUTPUT SYMBOLIC test COMMAND cog.py ${CMAKE_CURRENT_BINARY_DIR}/../../util/test.c DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/../../util/test.c COMMENT \"Creating symbolic file and running cog\" ) Installing Cog. $ pip install cogapp References and Further Reading CMocka assert macros CMocka API - links to checking paramters and mock objects functions. CMocka project page Test Driven Development for Embedded C - very good reference on TDD and C. Cog, Inline Python - An introduction to cog. ","categories":"","description":"","excerpt":"CMocka Testing for C Code The DSE Projects use CMocka for both Unit …","ref":"/dse.doc/docs/devel/modelc_cmocka/","tags":["Developer","Testing","CMocka"],"title":"Testing with CMocka"},{"body":"SimMock and CMocka Testing for Model Developers The DSE ModelC Library includes a SimMock source code library which may be used to develop integration tests for Models. With the SimMock library, a Model Developer is able to easily develop CMocka Testcases which:\nValidate a model configuration and confirm the Models operation. Develop scenarios where expected signal exchange is verified. Inject network messages into the simulation or model (e.g. CAN frames) and read network messages. Check expected values for both scalars (Signals) and messages (Network). Stack several Model Instances within one SimMock and confirm their interoperation. Example Test Files tests/cmocka/network/test_network.c // Copyright 2023 Robert Bosch GmbH #include \u003cdse/testing.h\u003e #include \u003cdse/logger.h\u003e #include \u003cfsil/runnable/runnable.h\u003e #include \u003cdse/ncodec/codec.h\u003e #include \u003cmocks/simmock.h\u003e static int test_setup(void** state) { const char* inst_names[] = { \"target_inst\", \"network_inst\", }; char* argv[] = { (char*)\"test_runnable\", (char*)\"--name=target_inst;network_inst\", (char*)\"--logger=5\", // 1=debug, 5=QUIET (commit with 5!) (char*)\"../../../../tests/cmocka/network/stack.yaml\", (char*)\"../../../../tests/cmocka/network/signalgroup.yaml\", (char*)\"../../../../tests/cmocka/network/network.yaml\", (char*)\"../../../../tests/cmocka/network/model.yaml\", (char*)\"../../../../tests/cmocka/network/runnable.yaml\", }; SimMock* mock = simmock_alloc(inst_names, ARRAY_SIZE(inst_names)); simmock_configure(mock, argv, ARRAY_SIZE(argv), ARRAY_SIZE(inst_names)); simmock_load(mock, true); simmock_setup(mock, \"signal\", \"network\"); /* Return the mock. */ *state = mock; return 0; } static int test_teardown(void** state) { SimMock* mock = *state; simmock_exit(mock); simmock_free(mock); return 0; } #define SIG_reset_counters 0 #define SIG_task_init_done 1 #define SIG_task_5_active 2 #define SIG_task_10_active 3 #define SIG_task_20_active 4 #define SIG_task_40_active 5 #define SIG_task_5_counter 6 #define SIG_task_10_counter 7 #define SIG_task_20_counter 8 #define SIG_task_40_counter 9 void test_network__network2target2network(void** state) { SimMock* mock = *state; ModelMock* network_model = \u0026mock-\u003emodel[1]; assert_non_null(network_model); /* 0-19.5ms */ { for (uint32_t i = 0; i \u003c 39; i++) { assert_int_equal(simmock_step(mock, true), 0); } SignalCheck s_checks[] = { { .index = SIG_task_init_done, .value = 1.0 }, { .index = SIG_task_5_active, .value = 1.0 }, { .index = SIG_task_5_counter, .value = 3.0 }, { .index = SIG_task_10_active, .value = 1.0 }, { .index = SIG_task_10_counter, .value = 1.0 }, { .index = SIG_task_20_active, .value = 0.0 }, { .index = SIG_task_20_counter, .value = 0.0 }, }; simmock_signal_check(mock, \"target_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); simmock_signal_check(mock, \"network_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); } /* Inject a message carrying the reset_counters signal. */ uint8_t buffer[8] = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; simmock_write_frame(mock-\u003esv_network_tx, \"can_bus\", buffer, 8, 0x1f0u); assert_int_equal(simmock_step(mock, true), 0); /* 20ms */ { for (uint32_t i = 0; i \u003c 1; i++) { assert_int_equal(simmock_step(mock, true), 0); } SignalCheck s_checks[] = { { .index = SIG_task_init_done, .value = 1.0 }, { .index = SIG_task_5_active, .value = 1.0 }, { .index = SIG_task_5_counter, .value = 1.0 }, { .index = SIG_task_10_active, .value = 1.0 }, { .index = SIG_task_10_counter, .value = 1.0 }, { .index = SIG_task_20_active, .value = 1.0 }, { .index = SIG_task_20_counter, .value = 1.0 }, }; FrameCheck f_checks[] = { { .frame_id = 0x1f4u, .offset = 1, .value = 0x02 }, { .frame_id = 0x1f4u, .offset = 2, .value = 0x02 }, { .frame_id = 0x1f4u, .offset = 3, .value = 0x02 }, { .frame_id = 0x1f5u, .offset = 4, .value = 0x02 }, { .frame_id = 0x1f7u, .offset = 4, .value = 0x02 }, }; simmock_print_scalar_signals(mock, LOG_DEBUG); simmock_print_network_frames(mock, LOG_DEBUG); assert_int_equal(network_model-\u003esv_network-\u003elength[0] \u003e 0, true); simmock_signal_check(mock, \"network_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); simmock_frame_check(mock, \"network_inst\", \"can_bus\", f_checks, ARRAY_SIZE(f_checks)); } } int run_network_tests(void) { void* s = test_setup; void* t = test_teardown; const struct CMUnitTest tests[] = { cmocka_unit_test_setup_teardown(test_network__network2target2network, s, t), }; return cmocka_run_group_tests_name(\"NETWORK\", tests, NULL, NULL); } References and Further Reading Testing with CMocka ","categories":"","description":"","excerpt":"SimMock and CMocka Testing for Model Developers The DSE ModelC Library …","ref":"/dse.doc/docs/devel/modelc_simmock/","tags":["Developer","Testing","CMocka"],"title":"Testing Models with SimMock"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/schemas/yaml/","tags":["Schema"],"title":"YAML Schemas"}]