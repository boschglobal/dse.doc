<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C Lib API Reference on Dynamic Simulation Environment</title><link>https://boschglobal.github.io/dse.doc/apis/clib/</link><description>Recent content in C Lib API Reference on Dynamic Simulation Environment</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://boschglobal.github.io/dse.doc/apis/clib/index.xml" rel="self" type="application/rss+xml"/><item><title>Marshal API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</guid><description>Marshal API The Marshal API supports two modes of operation:
Marshalling of intrinsic data types between source and target where the target represents externally defined data structures. Marshalling of signal maps between a signal interface and the source data objects (of the marshalling sub-system). When these operations are combined it becomes possible to map signals to externally defined data structures (i.e. C style structs).
Component Diagram @startuml data-marshal-interface skinparam nodesep 55 skinparam ranksep 40 title Marshal Interface interface &amp;#34;Signals&amp;#34; as sig package &amp;#34;Controller&amp;#34; { component &amp;#34;Source&amp;#34; as sou component &amp;#34;Target&amp;#34; as tar } sig -right-&amp;gt; sou : out sig &amp;lt;-right- sou : in sou -right-&amp;gt; tar : out sou &amp;lt;-right- tar : in center footer Dynamic Simulation Environment @enduml Typedefs MarshalGroup typedef struct MarshalGroup { char* name; int count; MarshalKind kind; MarshalDir dir; MarshalType type; struct { uint32_t* ref; struct { int32_t* _int32; uint64_t* _uint64; double* _double; char** _string; void** _binary; void* ptr; } _binary_len; } target; struct { int offset; struct { double* scalar; void** binary; } binary_len; } source; struct { MarshalStringEncode* string_encode; MarshalStringDecode* string_decode; } functions; uint64_t [4] __reserved__; } MarshalMapSpec typedef struct MarshalMapSpec { const char* name; int count; bool is_binary; const char** signal; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; uint64_t [4] __reserved__; } MarshalSignalMap typedef struct MarshalSignalMap { char* name; int count; bool is_binary; struct { int* index; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; } signal; struct { int* index; struct { double* scalar; void** binary; } binary_len; } source; uint64_t [4] __reserved__; } MarshalStruct typedef struct MarshalStruct { char* name; int count; void* handle; MarshalKind kind; MarshalDir dir; struct { MarshalType* type; int* offset; int* length; } target; struct { int* index; void** pdata; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; } source; uint64_t [4] __reserved__; } Functions marshal_generate_signalmap Creates a signal map between signals (i.</description></item><item><title>Mdf API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/mdf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/mdf/</guid><description>MDF API The MDF API (a part of the DSE C Lib) provides methods for creating an MDF4 data stream. Data is saved according to the ASAM Standards.
Because of the streaming design the exact number of samples written to an MDF file is not known when the MDF file is initially created. Accordingly, to indicate this condition, the follwing flags are set in the MDF file:
Update of cycle counters for CG-/CABLOCK required.</description></item><item><title>Schedule API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/schedule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/schedule/</guid><description>Schedule API The Schedule API proves a task schedule with configurable beat and an optional delay. Interfaces of the Schedule object allow for customization of the schedule behaviour, these include:
ScheduleVTable - tick and marshalling call interfaces. ScheduleTaskVTable - Support custom task call interfaces, the default is a simple void (*)(void) function call. Component Diagram @startuml schedule-api skinparam nodesep 55 skinparam ranksep 40 title Schedule API component &amp;#34;Schedule&amp;#34; as s component &amp;#34;ScheduleItem&amp;#34; as sI component &amp;#34;ScheduleTask&amp;#34; as sT interface &amp;#34;ScheduleVTable&amp;#34; as sVT interface &amp;#34;ScheduleTaskVTable&amp;#34; as sTVT component &amp;#34;Integration&amp;#34; as vT component &amp;#34;Target&amp;#34; as task s --( sVT s --( sTVT sVT -- vT sTVT -- vT s ---&amp;gt; sI : [0.</description></item></channel></rss>