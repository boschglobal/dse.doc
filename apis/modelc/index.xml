<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ModelC API Reference on Dynamic Simulation Environment</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/</link><description>Recent content in ModelC API Reference on Dynamic Simulation Environment</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://boschglobal.github.io/dse.doc/apis/modelc/index.xml" rel="self" type="application/rss+xml"/><item><title>Gateway API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</guid><description>Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.
Component Diagram @startuml gateway-model title Gateway Model node &amp;#34;Dynamic Simulation Environment&amp;#34; { component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif } package &amp;#34;Gateway Model&amp;#34; { component &amp;#34;ModelC Lib&amp;#34; as ModelC component &amp;#34;Model&amp;#34; } SBif &amp;lt;-down- ModelC Model -up-&amp;gt; ModelC :model_gw_setup() Model -up-&amp;gt; ModelC :model_gw_sync() Model -up-&amp;gt; ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.</description></item><item><title>MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</guid><description>Model Compatibility Layer The Model Compatibility Layer (MCL) can be used to implement support for models which were written according to different a modeling interface. This is done by combining a Strategy and Adapter pattern to build an MCL which can load, execute and exchange data with a the foreign model.
Component Diagram @startuml mcl-component title Compatibility Layer component &amp;#34;ModelC&amp;#34; { component &amp;#34;MCL Model&amp;#34; as MCLmodel } component &amp;#34;MCL Lib&amp;#34; { interface &amp;#34;Strategy&amp;#34; as Sif interface &amp;#34;Adapter&amp;#34; as Aif component &amp;#34;MCL&amp;#34; as MCL } interface &amp;#34;Model Interface&amp;#34; as Mif component &amp;#34;Model&amp;#34; as Model MCLmodel --( Sif MCLmodel --( Aif Sif -- MCL Aif -- MCL MCL -( Mif Mif - Model center footer Dynamic Simulation Environment @enduml Typedefs MclAdapterDesc typedef struct MclAdapterDesc { const char* name; MclLoadHandler load_func; MclInitHandler init_func; MclStepHandler step_func; MclUnloadHandler unload_func; } MclInstanceDesc typedef struct MclInstanceDesc { int* model_instance; int* mcl_channel_sv; MclStrategyDesc* strategy; int models; } MclModelDesc typedef struct MclModelDesc { const char* name; int* model_doc; char* path; void* handle; double* vector_double; void** vector_binary; double model_time; double model_time_correction; double step_size; MclAdapterDesc* adapter; void* private; } MclStrategyDesc typedef struct MclStrategyDesc { const char* name; double model_time; double stop_time; MclExecuteMethod execute; MclExecuteHandler execute_func; MclMarshallOutHandler marshall_out_func; MclMarshallInHandler marshall_in_func; MclInstanceDesc* mcl_instance; } Functions mcl_create Creates an instance of an MCL Model.</description></item><item><title>Model API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/model/</guid><description>Model API The Model API allows model developers and integrators to implement models which can be connected to a Simulation Bus. Models are able to exchange signals with other models via this connection to a Simulation Bus. A runtime environment, such as the ModelC Runtime/Importer, will load the model and also manages the connection with the Simulation Bus.
The Model API provides two simple interfaces which facilitate the development of models; the Model Interface which is concerned with the model lifecycle; and the Signal Interface which facilitates signal exchange.</description></item><item><title>Runtime API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</guid><description>Runtime API The Runtime API provides methods for implementing a model Runtime/Importer which can be used to load, configure and execute a model.
Typedefs ChannelSpec typedef struct ChannelSpec { const char* name; const char* alias; void* private; } ModelCArguments typedef struct ModelCArguments { const char* transport; char* uri; const char* host; int port; double timeout; int log_level; double step_size; double end_time; int uid; const char* name; const char* file; const char* path; void* yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; int steps; } ModelChannelDesc typedef struct ModelChannelDesc { const char* name; const char* function_name; const char** signal_names; int signal_count; int propagator_source_channel; int propagator_target_channel; double* vector_double; void** vector_binary; int* vector_binary_size; int* vector_binary_buffer_size; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char* name; const char* path; const char* file; char* full_path; void* doc; void* channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { int uid; char* name; int* model_desc; ModelDefinitionSpec model_definition; void* spec; void* yaml_doc_list; void* private; } SimulationSpec typedef struct SimulationSpec { const char* transport; char* uri; int uid; double timeout; double step_size; double end_time; ModelInstanceSpec* instance_list; } Functions modelc_destroy Bypass the controller and call model_destroy() directly.</description></item><item><title>Schema API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</guid><description>Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.
Typedefs SchemaLabel typedef struct SchemaLabel { const char* name; const char* value; } SchemaObject typedef struct SchemaObject { const char* kind; const char* name; void* doc; void* data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char* kind; const char* name; SchemaLabel* labels; int labels_len; void* data; } SchemaSignalObject typedef struct SchemaSignalObject { const char* signal; void* data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec.</description></item><item><title>SimMock API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</guid><description>SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC &amp;lt;-&amp;gt; SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.
Component Diagram @startuml simmock-objects title SimMock Objects package &amp;#34;SimBus Mock&amp;#34; { class Signal &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +double scalar[] +annotation() } class Network &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.</description></item></channel></rss>