<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>ModelC API Reference on Dynamic Simulation Environment</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/</link><description>Recent content in ModelC API Reference on Dynamic Simulation Environment</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://boschglobal.github.io/dse.doc/apis/modelc/index.xml" rel="self" type="application/rss+xml"/><item><title>Gateway API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</guid><description>Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.
Component Diagram @startuml gateway-model title Gateway Model node &amp;#34;Dynamic Simulation Environment&amp;#34; { component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif } package &amp;#34;Gateway Model&amp;#34; { component &amp;#34;ModelC Lib&amp;#34; as ModelC component &amp;#34;Model&amp;#34; } SBif &amp;lt;-down- ModelC Model -up-&amp;gt; ModelC :model_gw_setup() Model -up-&amp;gt; ModelC :model_gw_sync() Model -up-&amp;gt; ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.</description></item><item><title>MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</guid><description>Model Compatibility Library API A Model Compatibility Library provides an interface for supporting 3rd-party model interfaces in a DSE Simulation.
Component Diagram @startuml mcl-interface skinparam nodesep 55 skinparam ranksep 40 title MCL Interface component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif package &amp;#34;MCL&amp;#34; { component &amp;#34;Runtime&amp;#34; as ModelC component &amp;#34;MCL&amp;#34; as Mcl interface &amp;#34;ModelVTable&amp;#34; as MVt interface &amp;#34;MclVTable&amp;#34; as MclVt component &amp;#34;MCL Lib&amp;#34; as MclLib } MclLib -up- MclVt MclLib -up- MVt SBif &amp;lt;-down- ModelC MVt )-up- ModelC MclVt )-up- Mcl component &amp;#34;Model&amp;#34; as MclModel interface &amp;#34;Model I/F&amp;#34; as ModelIf MclModel -up- ModelIf ModelIf )-up- MclLib center footer Dynamic Simulation Environment @enduml Typedefs MclDesc typedef struct MclDesc { int model; const char* adapter; const char* version; MclVTable vtable; double step_size; double model_time; double model_time_correction; struct { int count; const char** signal; struct { double* scalar; void** binary; } binary_len; int* kind; } source; int* msm; uint64_t [4] __reserved__; } MclVTable typedef struct MclVTable { MclLoad load; MclInit init; MclStep step; MclMarshalOut marshal_out; MclMarshalIn marshal_in; MclUnload unload; void *[2] __reserved__; } Functions mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.</description></item><item><title>Model API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/model/</guid><description>Model API The Model API allows model developers and integrators to implement models which can be connected to a Simulation Bus. Models are able to exchange signals with other models via this connection to a Simulation Bus. A runtime environment, such as the ModelC Runtime/Importer, will load the model and also manages the connection with the Simulation Bus.
The Model API provides two simple interfaces which facilitate the development of models; the Model Interface which is concerned with the model lifecycle; and the Signal Interface which facilitates signal exchange.</description></item><item><title>Runtime API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</guid><description>Runtime API The Runtime API provides methods for implementing a model Runtime/Importer which can be used to load, configure and execute a model.
Typedefs ChannelSpec typedef struct ChannelSpec { const char* name; const char* alias; void* private; } ModelCArguments typedef struct ModelCArguments { const char* transport; char* uri; const char* host; int port; double timeout; int log_level; double step_size; double end_time; int uid; const char* name; const char* file; const char* path; void* yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; int steps; const char* sim_path; int [4] __reserved__; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char* name; const char* path; const char* file; char* full_path; void* doc; void* channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { int uid; char* name; int* model_desc; ModelDefinitionSpec model_definition; void* spec; void* yaml_doc_list; void* private; int [8] __reserved__; } RuntimeModelDesc typedef struct RuntimeModelDesc { int model; struct { const char* runtime_model; char* sim_path; const char* model_name; const char* simulation_yaml; int argc; char** argv; void* doc_list; int log_level; double step_size; double end_time; double step_time_correction; int binary_signals_reset; RuntimeModelVTable vtable; } runtime; int [5] __reserved__; } RuntimeModelVTable typedef struct RuntimeModelVTable { RuntimeModelSetEnv set_env; void *[2] __reserved__; } SimulationSpec typedef struct SimulationSpec { const char* transport; char* uri; int uid; double timeout; double step_size; double end_time; ModelInstanceSpec* instance_list; const char* sim_path; int mode_loopback; int sequential_cosim; void* spec; int [3] __reserved__; } Functions modelc_destroy Bypass the controller and call model_destroy() directly.</description></item><item><title>Schema API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</guid><description>Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.
Typedefs SchemaFieldMapSpec typedef struct SchemaFieldMapSpec { const char* key; uint8_t val; } SchemaFieldSpec typedef struct SchemaFieldSpec { SchemaFieldType type; const char* path; int offset; const SchemaFieldMapSpec* map; } SchemaLabel typedef struct SchemaLabel { const char* name; const char* value; } SchemaObject typedef struct SchemaObject { const char* kind; const char* name; void* doc; void* data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char* kind; const char* name; SchemaLabel* labels; int labels_len; void* data; } SchemaSignalObject typedef struct SchemaSignalObject { const char* signal; void* data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec.</description></item><item><title>SimMock API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</guid><description>SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC &amp;lt;-&amp;gt; SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.
Component Diagram @startuml simmock-objects title SimMock Objects package &amp;#34;SimBus Mock&amp;#34; { class Signal &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +double scalar[] +annotation() } class Network &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.</description></item></channel></rss>