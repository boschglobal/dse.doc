[{"body":"C1 System System Context C2 Container Interop Native Virtual ECU C3 Component Bootloader Runnable Model Composite Model Gateway FMI MCL C4 ","categories":"","description":"","excerpt":"C1 System System Context C2 Container Interop Native Virtual ECU C3 …","ref":"/dse.doc/docs/arch/c4/","tags":["Architecture"],"title":"C4 Architecture Diagrams"},{"body":"Synopsis Containerised simulation builder with DSL (DSE Lang).\nDescribe a Simulation simulation arch=linux-amd64 channel network uses dse.fmi https://github.com/boschglobal/dse.fmi v1.1.32 model fmu_CAN dse.fmi.network_model channel network network_channel workflow generate-model var NETWORK_SIGNAL can_bus var MIME_TYPE \"application/x-automotive-bus;interface=stream;type=frame;bus=can;schema=fbs;bus_id=1;node_id=2;interface_id=3\" var MEASUREMENT measurement.txt var OUT_DIR {{.PATH}}/data workflow generate-fmimodelc var FMU_NAME example var SIGNAL_GROUPS network Use the Builder Tool # Build a simulation. $ cd examples/runnable $ builder runnable.dse $ task -y Run the Simulation # Run a simulation. $ simer out/sim -stepsize 0.0005 -endtime 0.10 DSE Lang Simulations using the Simulation Development Platform (SDP) are written in a custom DSL called DSE Lang. This DSL is used to describe the construction of a simulation and its constituent channels, models and workflows.\n@startuml\r@startebnf dse-lang-syntax\rtitle DSE Lang Syntax\r(* Simulation Structural Elements *)\rsimulation = \"simulation\", [ \"arch=\", ARCH ], [ \"stepsize=\", STEP_SIZE ], [ \"endtime=\", END_TIME ];\rchannel = { \"channel\", CHANNEL_NAME, { \"network\", NETWORK_NAME, MIMEtype}- }-;\ruses = {USES_NAME, URI, [ VERSION ], [ \"path=\", PATH ], [ \"user=\", USER ], [ \"token=\", TOKEN ]}-;\rvar = { \"var\", VAR_NAME, VALUE}-;\rstack = \"stack\", STACK_NAME, [ \"stacked=\", ( \"false\" | \"true\" ) ], [ \"sequential=\", ( \"false\" | \"true\" ) ], [ \"arch=\", ARCH ];\r(* Model Construction Elements *)\rmodel =\r\"model\", MODEL_NAME,\r(\rMODEL, [ \"external=\", ( \"false\" | \"true\" ) ]\r| \"external=\", ( \"false\" | \"true\" )\r),\r[ \"arch=\", ARCH ],\r[ \"uid=\", UID ];\rchannel = { \"channel\", CHANNEL_NAME, CHANNEL_ALIAS }-;\renvar = { \"envar\", ENVAR_NAME, VALUE }-;\rfile = { \"file\", MODEL_FILE, (FILE_SOURCE | \"uses\", USES_NAME) }-;\rworkflow = \"workflow\", NAME, [ \"uses \", USES_NAME ],\r{[ \"var\", VAR_NAME, (VALUE | \"uses\", USES_NAME | \"var\", VAR_NAME)]}-;\r@endebnf\r@enduml Channel (Model) channel CHANNEL_NAME CHANNEL_ALIAS\rCHANNEL_NAME: the name of a simulation channel. CHANNEL_ALIAS: the alias used by the model for this channel. Channel (Simulation) channel CHANNEL_NAME\r[network NETWORK_NAME MIME_TYPE] ...\rCHANNEL_NAME: the name of a simulation/model channel. NETWORK_NAME: the name of the network. MIME_TYPE: the network’s protocol, format, and attributes. Envar envar ENVAR_NAME VAR_VALUE\rENVAR_NAME: the name of a environment variable. VAR_VALUE: the variable value. File file MODEL_FILE [FILE_SOURCE]\rfile MODEL_FILE [use USES_NAME]\rMODEL_FILE: the name by which the model refers to the file. FILE_SOURCE: the actual path of the file. USES_NAME: the name of a dependency that this file entry imports. Model model MODEL_INST_NAME MODEL_NAME [external=EXTERNAL] [arch=ARCH] [uid=UID]\r[channel CHANNEL_NAME CHANNEL_ALIAS] ...\rMODEL_INST_NAME: the name of the model (used within the simulation). MODEL_NAME: the name of the model as referenced by a uses item. EXTERNAL: the boolean flag indicating that the model is external, either a complete external model or one linked with workflows. When the model is fully external, it belongs to the external stack. ARCH: the architecture of this model. UID: the unique id of the model. CHANNEL_NAME: the name of a simulation channel to be mapped to this model. CHANNEL_ALIAS: the model alias for the channel being mapped. Simulation simulation [arch=ARCH] [stepsize=STEP_SIZE] [endtime=END_TIME]\r[channel CHANNEL_NAME] ...\rARCH: the architecture of the overall simulation. Select from supported platforms, including: linux-amd64 linux-x86 linux-i386 windows-x64 windows-x86 STEP_SIZE: the time increment for each simulation step (default : 0.0005). END_TIME: the total simulation duration (default : 0.005). Stack stack STACK_NAME [stacked=STACKED] [sequential=SEQUENTIAL] [arch=ARCH]\rSTACK_NAME: the name of the stack. STACKED: the boolean flag that indicates if the models in a stack should be layered. SEQUENTIAL: the boolean flag for stacks that ensures models are executed one after another, in a defined order. ARCH: the architecture of this stack and the models it contains. Note: When a model is fully external, it belongs to the external stack.\nUses uses\r[USES_NAME URI [VERSION] [path=PATH] [user=USER] [token=TOKEN]] ...\rUSES_NAME: the name of the uses item. URI: a URI for the uses item. May be a URL or file. VERSION: the version of the uses item. PATH: a sub-path of the uses item (incase the item should be extracted from a ZIP archive). USER: authentication user needed for retrieving the _uses_item. TOKEN: authentication token (or password) needed for retrieving the _uses_item. Var var VAR_NAME VAR_VALUE\rVAR_NAME: the name of a variable. VAR_VALUE: the variable value. Workflow Workflow WORKFLOW_NAME [uses USES_NAME]\r[var VAR_NAME VAR_VALUE] ...\r[var VAR_NAME uses USES_NAME] ...\rWORKFLOW_NAME: the name of the workflow. USES_NAME (workflow level): the name of a dependency that this workflow imports. VAR_NAME: the name of a variable used by this workflow. VAR_VALUE: the variable value. USES_NAME (variable level): sets the variable value to the path of this uses item. Special Variables DSE Lang uses a templating mechanism to introduce special variables to a DSE Script (in the form: {{ .SPECIAL_VAR }}). Those variables are used to influence how a simulation is constructed. Additionally, the templating mechanism can be used to introduce environment variables to a DSE Script (useful for authentication).\nENV_VAR Expands to the named ENV_VAR. MODEL When used within the context of a model expands to the models name (i.e. MODEL_INST_NAME). OUTDIR The output directory of the SDP toolchains (typically out). Contains the simulation folder. PATH When used within the context of a model expands to the models path within the simulation filesystem (set to SIMDIR/MODEL_INST_NAME). SIMDIR The simulation folder (typically sim). Builder Tool Info: The Builder Tool is already setup and configured in both GitHub Codespaces and Dev Containers environments.\nSetup The SDP Builder is a containerized tool which can be configured and used in a Linux environment. The following container images are available.\n# Latest Builder Container: $ docker pull ghcr.io/boschglobal/dse-builder:latest # Specific versions of the Builder Container $ docker pull ghcr.io/boschglobal/dse-builder:1.0.4 $ docker pull ghcr.io/boschglobal/dse-builder:1.0 Shell Function Info: The following shell function passes credentials to the Build Container which are used to fetch artifacts and repository metadata. Adjust as necessary for your environment (the -e parameters of the docker command).\n# Define a shell function (or add to .profile file). $ export BUILDER_IMAGE=ghcr.io/boschglobal/dse-builder:latest $ builder() { ( if test -f \"$1\"; then cd $(dirname \"$1\"); fi \u0026\u0026 docker run -it --user $(id -u):$(id -g) --rm -e AR_USER -e AR_TOKEN -e GHE_USER -e GHE_TOKEN -e GHE_PAT -v $(pwd):/workdir $BUILDER_IMAGE \"$@\"; ) } # Build the simulation. $ cd examples/runnable $ builder runnable.dse # And then use Task to complete the simulation (according to the build plan). export TASK_X_REMOTE_TASKFILES=1 $ task -y -v ls -R out/sim Authentication Any uses items in your DSE Script which require authentication credentials need to be defined in your environment and passed to the builder container. For example the following DSE Script uses a private GitHub repository and Artifactory instance:\nsimulation arch=linux-amd64 channel signal uses fsil.runnable https://{{.GHE_TOKEN}}@github.boschdevcloud.com/fsil/fsil.runnable v1.1.2 user={{.AR_USER}} token={{.AR_TOKEN}} and needs the following authentication setup:\n# Define authentication tokens. export AR_USER=foo export AR_TOKEN=foo_token export GHE_TOKEN=goo_token # Specify the shell function. $ builder() { ( if test -f \"$1\"; then cd $(dirname \"$1\"); fi \u0026\u0026 docker run -it --user $(id -u):$(id -g) --rm -e AR_USER -e AR_TOKEN -e GHE_TOKEN -v $(pwd):/workdir $BUILDER_IMAGE \"$@\"; ) } ","categories":"","description":"","excerpt":"Synopsis Containerised simulation builder with DSL (DSE Lang). …","ref":"/dse.doc/docs/user/builder/","tags":["SDP","DSELang","Builder"],"title":"Builder - Simulation Development Platform"},{"body":"Synopsis Developers wishing to contribute, as well as those having no choice in the matter, will find this documentation page full of useful information to guide you towards finalising your contribution.\nGit Commands Setup and Configure Git # Set user name and email (for signoff). git config --global --add user.name \"User Name (dept)\" git config --global --add user.email \"user.name@de.bosch.com\" Working with Commits Sign Off # Add a signoff to a commit. git commit -s -m \"Commit message.\" # Append a signoff to an existing commit. git commit --amend -s --no-edit # Add signoff to several commits. git rebase --signoff HEAD~3 Cherry-Pick Particularly useful when recovering from mistakes, or where you simply need to get a commit onto your branch.\n# Cherry pick between branches. git checkout --track origin/devel git checkout foo git cherry-pick a253c6359aa85da5627caf2f746282ac0e53cea1 Working with PRs Rebase a PR and push to requesters branch. # Checkout the PR locally. git fetch origin pull/86/head:PR-BRANCH git checkout PR-BRANCH # Rebase the PR and resolve any conflicts. git pull --rebase upstream main # Push the PR back to the originatory fork/branch (force if necessary). git push https://github.boschdevcloud.com/PR-USER/dse.modelc.git HEAD:devel git push https://github.boschdevcloud.com/PR-USER/dse.modelc.git HEAD:devel --force Squash a PR locally # Checkout the PR locally. git fetch origin pull/86/head:PR-BRANCH git checkout PR-BRANCH # Soft reset to the commit (SHA) _prior_ to the PR commits $ git log --oneline $ git reset --soft 5df673c $ git commit -am \"MDF API implementation.\" $ git commit --amend --author=\"\" --no-edit # Rebase the PR and squash in any edits. $ git add . $ git commit --amend --no-adit $ git pull --rebase upstream main # or $ git pull --rebase origin devel # Set the author. git commit --amend --author=\"John Doe (VM/EMT3) \u003cJohn.Doe@de.bosch.com\u003e\" --no-edit # Fix any issues, dd a signoff, merge to main/devel branch. $ git commit --amend -s --no-edit $ git checkout main # or $ git checkout devel $ git pull . PR-MDF --rebase # Push the PR back to the originatory fork/branch. $ git push upstream HEAD:main # and/or $ git push origin HEAD:devel Modify an existing PR on the requester fork/branch. # Update local devel branch (push local changes prior). $ git remote -v origin https://github.boschdevcloud.com/fsil/dse.modelc.git (fetch) origin https://github.boschdevcloud.com/fsil/dse.modelc.git (push) $ git switch origin/devel $ git pull --rebase # Ensure you have no local commits at this point. # Create a new branch and pull in the PR (no merge). git switch -c USER-PR-BRANCH origin/devel git pull https://github.boschdevcloud.com/USER/dse.modelc.git PR-BRANCH --rebase # Edit and commit changes. git commit -m\"Fix PR issue.\" # Push back to the PR (and delete the local branch). git push https://github.boschdevcloud.com/USER/dse.modelc.git HEAD:PR-BRANCH git switch devel git branch -D USER-PR-BRANCH devel Working with Remotes Setup for OSS Contributions When working directly with OSS repos it is helpful to maintain a clear set of remotes (and avoid mistakes). The following example shows one approach:\n# Add the origin remote as the development mirror (using clone). $ git clone https://github.boschdevcloud.com/fsil/dse.modelc.git # Add the upstream remote as the OSS repo. git remote add upstream https://github.com/boschglobal/some.repo.git git fetch upstream main git fetch upstream main --tags # Add a fsil.fork remote for your own PRs. git remote add fsil.fork https://github.com/boschglobal/some.repo.git git fetch fsil.fork git switch -c PR-BRANCH fsil.fork/main # Review the remote setup. $ git remote -v fsil.fork https://github.boschdevcloud.com/USER/fsil.dse.modelc.git (fetch) fsil.fork https://github.boschdevcloud.com/USER/fsil.dse.modelc.git (push) origin https://github.boschdevcloud.com/fsil/dse.modelc.git (fetch) origin https://github.boschdevcloud.com/fsil/dse.modelc.git (push) upstream https://github.com/boschglobal/dse.modelc.git (fetch) upstream https://github.com/boschglobal/dse.modelc.git (push) Pushing to OSS Remotes # Pull in upstream changes (avoid merge). $ git branch * devel main $ pull upstream main --rebase # Push changes from 'devel' to 'main'. git push upstream devel:main # Alternative, push from the current HEAD location to 'main'. git push upstream HEAD:main GitHub Dependabot Auto Merge Setup your GitHub Repo for Dependabot:\nSettings -\u003e General -\u003e Pull Requests -\u003e Allow auto-merge [select] Rules -\u003e Ruleset -\u003e [New branch ruleset] -\u003e Ruleset Name : default (or main) Bypass list : Repository admin \u0026 Maintain roles Target branches : default (or main) Rules : Require status checks to pass (these are workflow names) Lint Code Base build (linux-amd64) test_go [Create] Enforcement status -\u003e [Active] -\u003e [Save changes] Issues -\u003e Labels -\u003e New Label -\u003e add “automerge”, “dependabot” Add the following files to configure Dependabot and add an Auto-Merge workflow.\n.github/dependabot.yml --- version: 2 updates: - package-ecosystem: \"gomod\" directories: - \"**/*\" schedule: interval: \"daily\" groups: gomod-automerge: update-types: - \"patch\" - \"minor\" labels: - \"automerge\" - \"dependabot\" - package-ecosystem: \"github-actions\" directory: \"/\" schedule: interval: \"daily\" groups: actions-merge: update-types: - \"patch\" - \"minor\" - \"major\" labels: - \"dependabot\" .github/workflows/dependabot.yaml Hint: Make sure to match github.repository to your repo name.\n--- name: Dependabot auto-merge on: # yamllint disable-line rule:truthy pull_request: permissions: contents: write pull-requests: write jobs: dependabot: runs-on: ubuntu-latest if: github.event.pull_request.user.login == 'dependabot[bot]' \u0026\u0026 github.repository == 'boschglobal/REPO_NAME' steps: - name: Dependabot metadata id: metadata uses: dependabot/fetch-metadata@v2 with: github-token: \"${{ secrets.GITHUB_TOKEN }}\" - name: Enable auto-merge for Dependabot PRs if: contains(github.event.pull_request.labels.*.name, 'automerge') \u0026\u0026 (steps.metadata.outputs.update-type == 'version-update:semver-patch' || steps.metadata.outputs.update-type == 'version-update:semver-minor') run: gh pr merge --squash --auto \"$PR_URL\" env: PR_URL: ${{github.event.pull_request.html_url}} GH_TOKEN: ${{secrets.GITHUB_TOKEN}} .github/workflows/super_linter.yaml Hint: Make sure to adjust your super-linter checkout to match this snippet:\n--- name: Super Linter ... jobs: build: name: Lint Code Base runs-on: [ubuntu-latest] steps: - uses: actions/checkout@vX with: fetch-depth: 0 ... Maintain a Stable Fork Maintain a Stable Fork with the following references:\nfork (branch): Sync with upstream repo. This branch represents the fork. stable (tag): Reference for the stable forked repo. PR/* (branch): PR branches, each based from ‘stable’. main (branch): The operational branch, based on ‘stable’, and including commits from the PR branches. Update the stable reference $ git fetch --tags upstream $ git checkout v3.43.3 $ git tag -f stable Rebase PR Branches $ git branch --list PR/* $ git checkout PR/requires_check_nil $ git rebase stable # Repeat for each PR ... correct errors as they occur. Rebuild the “main” branch $ git checkout stable $ git switch -C main $ git pull . PR/requires_check_nil # Repeat for each PR ... # Update module URLs. find . -name '*.go' | xargs sed -i 's,github.com/go-task/task,github.com/boschglobal/task,g' find . -name 'go.mod' | xargs sed -i 's,github.com/go-task/task,github.com/boschglobal/task,g' $ git add . $ git commit -s -m\"Update module URLs.\" # Reset main and tag the version. $ git switch -C main $ git tag -f latest $ git tag -a v3.43.3-stable -m\"v3.43.3-stable\" Update the Fork/Origin $ git push origin stable -f $ git push origin main -f $ git push origin latest -f $ git push origin v3.43.3-stable -f # Push updated PRs ... $ git push origin PR/requires_check_nil -f # Repeat for each PR ... Use the Fork # For Go forks. $ go install github.com/boschglobal/task/v3/cmd/task@latest Contributions Checklist Hint: This list covers all items that are checked for every contribution. If you write code properly, use the automation, and document appropriately … then the list will already be satisfied.\nNotice: Items in bold text are mandatory in all circumstances.\nIndividual/Small Contributions: Sign-off from approved contributor. Sign-off implies the following: No copy/pasted code! Approval to contribute (from your organisation/company if required). Acceptance of existing licence(s) used by the repository. No unauthorised IP included with the commit. No personal data or images. No confidential information. Concise commits (squash smaller changes). Linear history (no merges). Copyright statement included with new files. All items from Code Quality Checks. New Dependencies included in Contributions: Suitability of dependency license for integration with this repository. Documentation of dependency license and copyright notices. Evaluation of dependency risk (especially to project stability). Archiving of dependency source code (mitigate continuity risk). OSS Scan completed. All items from Code Quality Checks. New Repositories: Review of architectural concept (as it relates to other repositories). License selection for code and documentation. Approval to create new repository (from your organisation/company if required). Copyright statement included with new files. Documentation (including README file). User documentation. Architectural documentation. Developer documentation. Integration with documentation publishing systems (where appropriate). Clean history! Prior to publishing the repository, the history should be cleaned (i.e. squash to single commit) to remove any intermediate data from the history. OSS Scan completed. Contributor agreement (permission to publish). All items from Code Quality Checks. Code Quality Checks: No compile warnings or errors. No linter warnings or errors (no circumvention). Memory leak checks (often enabled in unit test frameworks). All tests pass. Consistent variable naming (with existing code). Consistent commenting style (with existing code). Consistent code formatting (with existing code). Documentation updated, especially generated documentation. Software Design: Compatibility - if possible changes should be backwards compatible. Platform - avoid precompile flags (i.e. #ifdef/#endif) for managing platform specific code. Logic - avoid excessive nesting (i.e. 3+ levels) and complex conditional statements. Macros - avoid use. Operational Reviews: Logging: Normal operation produces a minimum of logging, sufficient to describe the configuration of the system in a support ticket, and especially sufficient to identify configuration errors. Information logging allows normal operation of system (i.e. no debug logging). No logging output during unit tests. Fault conditions are reported, and where possible, resolution hints are given. FIXME items are either resolved or opened as Issues. No FIXME items should remain in the code. TODO items are opened as Issues if appropriate. Supporting Automation Build System Most code quality checks are supported via automation in repositories. These same checks will be used by CI systems. Use the automation before submitting PRs.\n# Clean the build environment. $ make clean # If you added new dependencies, an additional clean is required. $ make cleanall # Build the software. $ make # Resolve any compiler warnings. # Test the software. $ make test # Resolve any compiler warnings from the test code. # Run static checks. $ make super-linter # Generate additional content, especially if documentation or examples were # modified as they may/will be used as supplemental documentation content. $ make generate # Remember to commit changes for generated content. Code Formatting Code (C language) can be formatted to the prevailing style with the support of automation.\n# Setup the code formatting command (you can put this in your .bash_aliases file). $ export DSE_CLANG_FORMAT_IMAGE=ghcr.io/boschglobal/dse-clang-format:main $ alias dse-clang-format='docker run --rm -it --volume $(pwd):/tmp/code ${DSE_CLANG_FORMAT_IMAGE}' # Format a source file. $ dse-clang-format dse/modelc/gateway.h Platform Specific Code As much as possible please avoid platform specific code, and in particular the use of #ifdef/#endif as these make software particularly difficult to maintain and understand.\nWhen using platform specific code becomes necessary, please use of of the following design patterns:\nUse the existing \u003cplatform.h\u003e The DSE C Library includes a header file for managing smaller platform specific issues. https://github.com/boschglobal/dse.clib/blob/main/dse/platform.h\nUse the Linker Use the linker to switch between code files containing the platform specific implementations, and if necessary describe the interface of those implementations with a header file. Not only does this technique remove the need for any #ifdef/#endif in your code, it will also likely make the underlying design more robust, easy to test … and faster to compile.\nThe DSE Model C Library uses this technique in its Message Queue implementation:\nadd_library(adapter OBJECT ... $\u003c$\u003cBOOL:${UNIX}\u003e:transport/mq_posix.c\u003e ... and associated source code: https://github.com/boschglobal/dse.modelc/blob/main/dse/modelc/adapter/transport/mq_posix.c\nOSS Compliance Items Establishing a Mirror A mirroring strategy for dependences can be largely automated using GitHub actions. The following represents such an implementation:\nmirror.yaml (workflow)\rname: OSS Mirrors\ron:\rworkflow_dispatch:\rschedule:\r- cron: 0 10 * * 0\rjobs:\rbuild:\rruns-on: [fsil-bpc]\rstrategy:\rmatrix:\r# List each pair of source/target repos to be mirrored.\rinclude:\r- source: \"https://github.com/redis/hiredis\"\rtarget: \"fsil-oss-mirrors/hiredis.git\"\rbranch: \"master\"\r- source: \"https://github.com/libevent/libevent\"\rtarget: \"fsil-oss-mirrors/libevent.git\"\rbranch: \"master\"\r- source: \"https://github.com/yaml/libyaml\"\rtarget: \"fsil-oss-mirrors/libyaml.git\"\rbranch: \"master\"\r- source: \"https://github.com/msgpack/msgpack-c\"\rtarget: \"fsil-oss-mirrors/msgpack-c.git\"\rbranch: \"c_master\"\r- source: \"https://gitlab.com/cmocka/cmocka\"\rtarget: \"fsil-oss-mirrors/cmocka.git\"\rbranch: \"master\"\r- source: \"https://github.com/dlfcn-win32/dlfcn-win32\"\rtarget: \"fsil-oss-mirrors/dlfcn-win32.git\"\rbranch: \"master\"\rsteps:\r- name: git-sync branch\ruses: wei/git-sync@v3\rwith:\rsource_repo: ${{ matrix.source }}\rsource_branch: ${{ matrix.branch }}\rdestination_branch: ${{ matrix.branch }}\rdestination_repo: \"https://${{ secrets.GHE_USER }}:${{ secrets.GHE_TOKEN }}@github.boschdevcloud.com/${{ matrix.target }}\"\r- name: git-sync tags\ruses: wei/git-sync@v3\rwith:\rsource_repo: ${{ matrix.source }}\rsource_branch: \"refs/tags/*\"\rdestination_branch: \"refs/tags/*\"\rdestination_repo: \"https://${{ secrets.GHE_USER }}:${{ secrets.GHE_TOKEN }}@github.boschdevcloud.com/${{ matrix.target }}\"\rConfiguration for SCANS Projects will include an automation to assist in the generation of OSS Scan Packages. These OSS Scan Packages include the source from all dependences and may be used to run OSS Compliance Scans.\nImportant: If you are adding a new dependency to a repository, please ensure that it is also added to the automation which generates OSS Scan Packages.\n# Generate the OSS Scan Package. $ make oss # Evaluate the OSS Scan Package content (e.g check for your new dependency). $ ls dse/__oss__/ dlfcnwin32/ dse.clib/ dse_ncodec/ event/ hiredis/ msgpackc/ yaml/ Documentation of License (and notices) Dependency’s of a repository need to have their license and associated notices documented. The easiest way to achieve that is to simply copy each artifact into a licenses directory.\nImportant: All transitive dependencies need to be documented.\nlicenses/\r└── barrust/\r└── LICENSE \u003c-- Code directly included in repo.\r└── dlfcnwin32/\r└── COPYING\r└── dse.clib/\r└── NOTICE\r└── LICENSE\r└── dse_ncodec/\r└── LICENSE\r└── NOTICE\r└── event/\r└── LICENSE\r└── flatbuffers/ \u003c-- Transitive dependency.\r└── LICENSE.txt\r└── flatcc/ \u003c-- Transitive dependency.\r└── LICENSE\r└── NOTICE\r└── hiredis/\r└── COPYING\r└── msgpackc/\r└── LICENSE_1_0.txt\r└── NOTICE\r└── yaml/\r└── License ","categories":"","description":"","excerpt":"Synopsis Developers wishing to contribute, as well as those having no …","ref":"/dse.doc/docs/devel/contribution/","tags":"","title":"Contributions Guide"},{"body":"The documentation system is built by pulling content from individual Git Repos into a Hugo/Docsy project. The Hugo build system then consolidates that content into a single documentation system which is then published.\nHint: Documentation in each Git Repo needs to follow the same layout and structure as the Documentation Repo for the content to be merged correctly.\nLayout Repo Documentation When writing documentation construct a layout as described in the following section. The entiredoc/content folder of your Git Repo will be mounted (effectively merged) into the doc/content folder of the documentation system, therefore pay special attention to the following naming conventions to avoid conflicts with content from other repos:\nrepo - Typically the tail part of your repo name (i.e fsil.runnable becomes runnable). topic - A unique topic name. If you are describing the architecture of a model, then the topic can be the name of that model (which is also typically the repo name). model - If your repo represents a model, then use that name (which is also typically the repo name). tool - The name of a tool or script that you are documenting. Hint: No need to over think it, just use your repo name as the stem for the name ofyour page bundle folder (Hugo term).\ndoc/ └── content/ └── apis/ \u003c-- *** mount point for apis content *** └── \u003crepo\u003e/... \u003c-- generated API documentation └── docs/ \u003c-- *** mount point for docs content *** └── arch/ └── \u003ctopic\u003e|\u003cmodel\u003e/ └── index.md \u003c-- documentation, primary content for leaf bundle └── image.png └── devel/ └── \u003crepo\u003e_\u003ctopic\u003e/ └── examples/ \u003c-- example code, belongs to the bundle └── index.md \u003c-- documentation └── image.png \u003c-- exported images (e.g. from yEd) └── examples/\u003crepo\u003e/... \u003c-- example code, alternative location └── user/ └── models/ └── \u003cmodel\u003e/ └── index.md \u003c-- documentation └── tools/ └── \u003ctool\u003e/ └── index.md \u003c-- documentation yed/ \u003c-- yEd image source files Makefile \u003c-- generate implementation Makefile \u003c-- generate target Mount Configuration Content from Git Repos is mounted into the documentation system using the hugo.toml file. Additionally the go.mod needs to be updated to reference the correct version of the Git Repo.\nFile: hugo.toml ... # DSE ModelC # ----------- [[module.imports]] path = \"github.com/boschglobal/dse.modelc\" disable = false ignoreConfig = true [[module.imports.mounts]] source = \"doc/content/apis\" target = \"content/apis\" [[module.imports.mounts]] source = \"doc/content/docs\" target = \"content/docs\" ... File: go.mod For repos with version 2+ it is necessary to manually update the go.mod file.\nNote: Modifications to go.mod will eventually be scripted.\nmodule github.com/boschglobal/dse.doc go 1.19 require ( github.com/boschglobal/dse.clib v1.0.5 // indirect github.com/boschglobal/dse.modelc v2.0.0+incompatible github.com/boschglobal/dse.schemas v1.1.4 // indirect github.com/boschglobal/dse.standards v1.0.3 // indirect // ... ) Generation Several Repos/Projects have generated documentation. This documentation is updated with the following generalised process:\nUpdate documentation in the source files.\nRun the make generate Makefile target to update the generated content.\nCommit the updated content and push the changes upstream.\nWhen the documentation is ready, tag a “patch” release on the Repo, the next time the documentation system updates, it will fetch the updated content.\nEach of the generated documentation formats/systems are explained in the following sections.\nC based API Documentation Markdown format documentation, embedded in C comment blocks. CDocGen toolchain for generation of documentation (tools/cdocgen). PlantUML images generated from embedded diagrams (tools/plantuml). Examples read from source files, and also included in build for quality assurance of example code. An example of API Doc Generation is available in this Makefile.\nYAML based Schema Documentation OpenAPI schema definition with embedded documentation (including examples). Validation (swagger) and generation (widdershins). Additional templating (adding Hugo metadata) with sed. An example of Schema Doc Generation is available in this Makefile.\nHugo / Docsy The documentation system is built using Hugo with the Docsy theme. Content is written in Markdown format. General information is available at these links:\nHugo Docsy Markdown : Basic Syntax Extended Syntax Markdown Cheatsheet with GitHub flavour Hugo Page Bundles Most of the content is pulled from other Git Repos and mounted into the content directory. Therefore, the same documentation may be reused in several documentation systems.\nHugo Content Organisation Warning: Hugo content organisation is not always explained well. For instance, “leaf means it has no children”, really does not explain what a leaf is … and since when do leaves have children? or not have them? This post is helpful if you suspect that the Hugo documentation seems to be missing the point.\nIn Hugo, content is organised as Page Bundles, which are, in turn collections of Page Resources. Page bundles are simply a collection of related files (i.e. page resources) all placed in the same directory. Page bundles may either be a Leaf Bundle (directory contains file index.md) or a Branch Bundle (directory contains file _index.md). A simple Page can be difficult to work with, especially if your content includes images.\ncontent/ └── docs ├── page.md \u003c-- page ├── leaf \u003c-- page bundle, specifically a leaf bundle │ ├── leaf.jpg │ └── index.md └── branch \u003c-- page bundle, specifically a branch bundle ├── page-1.md ├── page-2.md ├── branch.jpg └── _index.md In terms of arranging content, a Branch Bundle may contain other Bundles (Branch or Leaf), where as a Leaf Bundle may not contain other Bundles. This arrangement is reflected in the structure of the site.\n","categories":"","description":"","excerpt":"The documentation system is built by pulling content from individual …","ref":"/dse.doc/docs/devel/documentation/","tags":"","title":"Documentation Systems"},{"body":"Simulation Development Platform - Developer Documentation\nDebug Workflows Build the workflow container.\n~/git/working/dse.fmi$ make build fmi tools\nSet env to pickup the local container\nexport FMI_IMAGE=fmi 2009 export FMI_TAG=test 2010 export TASK_X_REMOTE_TASKFILES=1\nBuild the taskfile\nmake build or dse-parse2ast runnable.dse runnable.json dse-ast convert -input runnable.json -output runnable.yaml dse-ast resolve -input runnable.yaml dse-ast generate -input runnable.yaml -output .\nEdit the Taskfile uses to point to local versoin\ndse.fmi-v1.1.31: taskfile: ../../..//dse.fmi/Taskfile.yml\nRun task\ntask -y -v -f\n","categories":"","description":"","excerpt":"Simulation Development Platform - Developer Documentation\nDebug …","ref":"/dse.doc/docs/devel/sdp/","tags":"","title":"SDP Developer Documentation"},{"body":"Synopsis Containerised simulation run-time.\n# Run a simulation. $ simer path/to/simulation -stepsize 0.0005 -endtime 0.04 Simulation Setup Structure The structure of a simulation is flexible and can be arranged based on individual project needs. All paths used within a simulation configuration should be relative to the root of the simulation folder (i.e. the simulation path). The simer tool will search for YAML files contained within the simulation path and automatically configure, and then run, the contained simulation.\nThe following example simulation layout is generated by the SDP Builder.\nExample Simulation Structure path/to/simulation \u003c-- simulation path └── data └── simulation.yaml \u003c-- Simulation definition └── model └── input \u003c-- Model 'input' └── data └── model.yaml \u003c-- Model definition signalgroup.yaml \u003c-- Signal definitions input.csv \u003c-- Data used by the model └── lib/libcsv.so \u003c-- Model library └── linear \u003c-- Model 'linear' └── data/signalgroup.yaml \u003c-- Signal definitions └── lib/libfmimcl.so \u003c-- FMIMCL library (FMU loader) lib/fmu3linear.so \u003c-- FMU library Simulation Stacks A simulation can be further structured by using several Stack definitions in the simulation.yaml file. This enables parts of the simulation to be partitioned according to either structural, deployment or operational constraints. Simer can then be used to run the appropriate stacks (i.e. those that will use a Linux/Container runtime) while the remaining stacks are run in their appropriate ‘remote’ systems.\n32-Bit Models The Simer runtime supports two 32-bit Linux architectures:\nlinux-x86 - model runtime flag x32, compiler flags: -mx32 linux-i386 - model runtime flag i386, compiler flags: -m32 Models which should run with either of these architectures can be configured in a stack via either the runtime.x32 or runtime.i386 property of the model. Simer will then select the correct ModelC runtime to run these models.\nNote: Simulation stacks configured with either a stacked or sequential runtime are run by Simer in a single ModelC instance. Therefore all models in such a simulation stack must have the same runtime properties.\nExample Linux-x86 Stack simulation.yaml --- kind: Stack metadata: name: simulation spec: models: - name: x32_model_instance uid: 45 model: name: X32_Model runtime: x32: true channels: - name: signal_channel alias: signal Example Linux-i386 Stack with ‘stacked’ Runtime simulation.yaml --- kind: Stack metadata: name: simulation runtime: stacked: true spec: models: - name: foo uid: 1 model: name: I386_Model_Foo runtime: i386: true channels: - name: signal_channel alias: signal - name: bar uid: 2 model: name: I386_Model_Bar runtime: i386: true channels: - name: signal_channel alias: signal Remote Models Simulations which contain remote models, such as gateway models running in foreign simulation environments, or Windows based models, can be configured in a separate stack(s). When the simulation is run by the simer tool, only a selected list of stacks/models can be started. The remaining stacks and/or gateway models are then started in their own environment, and once started they can connect to the simulation running in the simer tool.\nHint: Models which need to be run with an older version of the simer tool can be defined in their own stack and run independently (i.e. using an older version of Simer).\nExample Remote Stack with Gateway Model simulation.yaml --- kind: Stack metadata: name: linux spec: models: - name: simbus model: name: simbus channels: - name: signal_channel expectedModelCount: 2 - name: model_instance uid: 1 model: name: Model channels: - name: signal_channel alias: signal --- kind: Stack metadata: name: remote spec: connection: transport: redispubsub: uri: redis://somehost:6379 timeout: 60 models: - name: gateway_instance uid: 2 model: name: GatewayModel channels: - name: signal_channel alias: signal # Start the simulation (excluding Remote models). $ simer path/to/simulation -stack linux -endtime 0.1 # Now start the Remote models ... Stacked Models Several models may be run stacked into a single ModelC runtime instance by setting the runtime:stacked property of their stack to true. The simer tool will start all models in that stack in a single instance of the ModelC runtime.\nExample Stacked Simulation with Loopback/Local SimBus simulation.yaml --- kind: Stack metadata: name: simulation spec: connection: transport: loopback: uri: loopback runtime: stacked: true models: - name: simbus model: name: simbus channels: - name: signal_channel expectedModelCount: 2 - name: foo uid: 1 model: name: Foo_Model channels: - name: signal_channel alias: signal - name: bar uid: 2 model: name: Bar_Model channels: - name: signal_channel alias: signal Environment \u0026 Files Environment variables may be specified in either the runtime:env property of a stack or model, or with the -env CLI option of the simer tool. Environment variables set by the -env CLI option of the simer tool can be set for all models in the simulation, or targeted to a specific model.\n# Set the SimBus transport to `redis` for all models in the simulation. $ simer path/to/simulation -env SIMBUS_TRANSPORT=redis # Set the log level for the 'simbus' model _only_. $ simer path/to/simulation -env simbus:SIMBUS_LOGLEVEL=2 Environment variables are passed by the simer tool to the ModelC runtime in the order that they are defined: stack environment variables first, and then model environment variables, and lastly those specified via the -env flag(s). Values set later will overwrite those set earlier.\nAdditional Files may be specified in the runtime:files property of a model. The path of each listed file should be relative to the simulation path or an absolute path.\nExample Stack with Environment \u0026 Files Specified simulation.yaml --- kind: Stack metadata: name: simulation spec: runtime: env: SIMBUS_LOGLEVEL: 4 models: - name: simbus model: name: simbus channels: - name: data_channel expectedModelCount: 2 - name: counter_A uid: 1 model: name: Counter runtime: env: COUNTER_NAME: counter_A COUNTER_VALUE: 100 files: - data/signalgroup.yaml channels: - name: data_channel alias: data - name: counter_B uid: 2 model: name: Counter runtime: env: SIMBUS_LOGLEVEL: 3 COUNTER_NAME: counter_B COUNTER_VALUE: 200 files: - data/signalgroup.yaml channels: - name: data_channel alias: data In this example the SIMBUS_LOGLEVEL is set to 4 for all models with the exception of the ‘counter_B’ model where this value is overridden and set to 3. Both models are configured to reference the same file data/signalgroup.yaml. This file will be located relative to the simulation path.\nSimer Tool Setup Simer is a containerised simulation run-time which can be operated using a number of techniques. The container is suitable for use in automated workflows.\nContainer images are available and released with each new version of the ModelC project.\n# Latest Simer Container: $ docker pull ghcr.io/boschglobal/dse-simer:latest # Specific versions of the Simer Container $ docker pull ghcr.io/boschglobal/dse-simer:2.0.7 $ docker pull ghcr.io/boschglobal/dse-simer:2.0 Shell Function # Define a shell function (or add to .profile file). $ export SIMER_IMAGE=ghcr.io/boschglobal/dse-simer:latest $ simer() { ( if test -d \"$1\"; then cd \"$1\" \u0026\u0026 shift; fi \u0026\u0026 \\ docker run -it --user $(id -u):$(id -g) --rm \\ -v $(pwd):/sim \\ -p 2159:2159 -p 6379:6379 \\ $SIMER_IMAGE \"$@\"; ) } # Run the simulation. $ simer path/to/simulation -endtime 0.04 Alias File / Function function simer() { ( if test -d \"$1\"; then cd \"$1\" \u0026\u0026 shift; fi \u0026\u0026 \\ docker run -it --user $(id -u):$(id -g) --rm \\ -v $(pwd):/sim \\ -p 2159:2159 -p 6379:6379 \\ $SIMER_IMAGE \"$@\"; \\ ) } export -f simer # Run the simulation. $ simer path/to/simulation -endtime 0.04 Makefile SIMER_IMAGE ?= ghcr.io/boschglobal/dse-simer:latest SIM_PATH := path/to/simulation SIM_ENDTIME := 0.04 .PHONY: simer simer: docker run -it --user $$(id -u):$$(id -g) --rm \\ -v $$(pwd)/$(SIM_PATH):/sim \\ $(SIMER_IMAGE) -endtime $(SIM_ENDTIME) # Run the simulation. $ make simer GitHub Workflow Action jobs: simulation: runs-on: ubuntu-latest steps: - name: Simer uses: boschglobal/dse.sdp/actions/simer with: path: path/to/simulation endtime: '0.04' Options $ simer -h SIMER (SIMulation runnER) Containerised simulation run-time. Part of the Dynamic Simulation Environment Core Platform. repo: https://github.com/boschglobal/dse.modelc doc: https://boschglobal.github.io/dse.doc/docs/user/simer Examples: simer -endtime 0.1 simer -stack minimal_stack -endtime 0.1 -logger 2 simer -stepsize 0.0005 -endtime 0.005 -transport redis -uri redis://redis:6379 simer -tmux -endtime 0.02 simer -gdb simbus -tmux -endtime 0.004 -logger 2 -timeout 5 Flags: -endtime *flag.float64Value simulation end time (0.002) -env *simer.listFlag environment modifier, in format '-env MODEL:NAME=VAL' -gdb *flag.stringValue run this model instance via GDB, use CSL in format '-gdb simbus,model' -gdbserver *flag.stringValue attach this model instance to GDB server -logger *flag.intValue log level (select between 0..4) (3) -modelcI386 *flag.stringValue path to ModelC i386 executable (/usr/local/bin/modelc32_i386) -modelcX32 *flag.stringValue path to ModelC x32 executable (/usr/local/bin/modelc32_x86) -stack *flag.stringValue run the named simulation stack(s) -stepsize *flag.float64Value simulation step size (0.0005) -timeout *flag.float64Value timeout (60) -tmux *flag.boolValue run simulation with TMUX user interface (false) -transport *flag.stringValue SimBus transport (redispubsub) -uri *flag.stringValue SimBus connection URI (redis://localhost:6379) -valgrind *flag.stringValue run this model instance via Valgrind, use CSL in format '-valgrind simbus,model' Tmux Interface $ simer path/to/simulation -endtime 0.04 -tmux The terminal multiplexer tmux is a technical CLI interface which makes it easy to observe the output of simulations which are comprised of several models. When using the tmux interface each Model is represented in its own terminal window, and it is possible to switch between terminal windows using tmux keyboard shortcuts. Some of these shortcuts are listed below.\nTmux Keyboard Shortcuts Ctrl+b c Create new window. Ctrl+b p Select previous window. Ctrl+b n Select next window. Ctrl+b 0..9 Switch between tmux windows. Ctrl+b w List windows. Ctrl+b [ Enter copy mode. Use VI keys to move cursor around the window (q to quit copy mode). Ctrl+b PgUp Enter copy mode and scroll up. Use VI keys to move cursor around the window (q to quit copy mode). In copy mode use:\nSpacebar Start selection. Esc Clear selection. Enter Copy selection. / Search forwards. ? Search backwards. Finally, use:\nCtrl+b d Detach from the tmux session (and exit the simulation!). GDB Debug GDB Models (and the SimBus) running in the simer tool can be interactively debugged using GDB. This method of debugging requires the use of the Tmux interface.\n# Start the simulation with the SimBus running under GDB. $ simer path/to/simulation -tmux -gdb model_inst -endtime 0.04 -timeout 5 # Start the simulation with a model and the SimBus running under GDB. $ simer path/to/simulation -tmux -gdb simbus,model_inst -endtime 0.04 -timeout 5 GDB Server (remote) Models running in a simulation can be debugged with GDB by indicating which model is being debugged via the option -gdbserver, and then connecting a GDB instance to that model running “remotely” in the Simer simulation.\n# Start the simulation and indicate the Model being debugged. $ simer path/to/simulation -endtime 0.04 -tmux -gdbserver gdb_inst # Start GDB (in a second terminal), and connect to the simulation. $ gdb dse/modelc/build/_out/bin/modelc (gdb) set solib-search-path path/to/simulation/lib (gdb) target remote localhost:2159 (gdb) continue (gdb) bt Definitions Channel Represents a grouping of signals which are exchanged between models. GDB A tool for debugging software and investigating bugs (typically segmentation faults). Model (Definition) The definition of a model, specifying the location of libraries (for all supported os/arch combinations) as well as possible channel configurations. Model (distribution/binary) A packaged version of a model (including binaries and related artifacts). Model Instance An instance of a particular Model. Will include runtime properties. ModelC An implementation of a Model Runtime (i.e. Importer). Redis A data service used by ModelC instances to communicate with a SimBus. Redis is packaged in the Simer Container and started automatically (disabled by setting hidden parameter -redis to \"\"). Remote Model A model configured in a simulation but which runs on a remote system. Signal Group A set, or subset, of signals which belong to a channel. SimBus (Simulation Bus) An implementation of a data exchange mechanism for scalar and binary signals. Simulation The structural arrangement of several Models, which, when connected via a Simulation Bus, form a simulation. Typically defined in a file simulation.yaml. Simulation Package (simulation path/folder) This folder contains all configuration, models and artifacts necessary to run a simulation. Stack Defines a list of models which should be run as a part of a simulation. Simulations may be defined by one or more stacks. Stacked Models A list/collection of models which are stacked into a single ModelC runtime instance. Valgrind A tool used to detect memory leaks. Run with valgrind as a part of a model QA strategy (i.e. as a part of E2E tests). x32 The linux x32 ABI architecture specifier, for models which must run as 32bit processes. i386 The linux i386 ABI architecture specifier, for models which must run as 32bit processes. ","categories":"","description":"","excerpt":"Synopsis Containerised simulation run-time.\n# Run a simulation. $ …","ref":"/dse.doc/docs/user/simer/","tags":["Simer","CLI"],"title":"Simer - Simulation Runner"},{"body":"The SDP builds simulations using Git repositories which contain both models and their associated workflows. The workflows are defined using Task, and implemented with containerized tool-chains. Additional metadata, embedded in the Taskfile, makes is possible for the SDP to automate the task of configuring and operating the workflows.\nLayout Go based Tools Models are typically written in the C Language using an established repository layout. Within that layout, workflow tools can be written in any programming language. For Go based workflow tools, the following layout is suggested:\nextra └── tools └── \u003ctool\u003e ├── build/package │ ├── Dockerfile │ └── entrypoint.sh \u003c-- entry point for container image ├── cmd/\u003ctool\u003e │ ├── main.go \u003c-- CLI configuration of commands │ └── main_test.go \u003c-- testscript interface (optional) ├── internal/app/ \u003c-- command implementation and tests ├── pkg/ \u003c-- reusable packages (optional) ├── test/testdata/ \u003c-- testscript (txtar) based tests ├── vendor/ \u003c-- vendored packages (optional) ├── Makefile ├── README.md ├── go.mod └── go.sum tests └── testscript └── e2e/ \u003c-- repo level end-to-end tests Makefile \u003c-- repo level Makefile Taskfile \u003c-- definition of workflows and related metadata Hint: Typically the tool name and repo name are identical.\nContainers The general preference is to have one workflow/tool container per repository which contains all necessary workflow tools. An additional entrypoint.sh script can be added to the container to facilitate command selection/execution.\nTaskfile Workflow automation is supported by Task which uses a Taskfile to define workflows, and those workflows use the containerized tools exclusively. A Taskfile will have features as described in the following sections, and working examples can be found at the root of most DSE repos.\nRepo Metadata Repo Metadata describes the following items:\nPackaging - Download URL for compiled models belonging to a repo. Container - The name of the repository containing images for the tool container. Models - a list of the models, and associated data for each model, that is included in the package. Name - The name of the model. Display Name - How the name of the model should be displayed in the SDP/DSL. Path - The relative path of the model in the package archive. Mcl - Indicates that this is an MCL model. Workflows - lists workflows that may be used with this model. Platforms - lists platforms this model supports. Channels - lists fixed/pre-configured channels of the model. Example Taskfile with Repo Metadata\r--- version: '3' metadata: package: download: '{{.REPO}}/releases/download/v{{.TAG}}/Fmi-{{.TAG}}-{{.PLATFORM_ARCH}}.zip' container: repository: ghcr.io/boschglobal/dse-fmi models: dse.fmi.mcl: name: fmimcl displayName: dse.fmi.mcl path: fmimcl mcl: true workflows: - generate-fmimcl - generate-fmimodelc - generate-fmigateway - patch-signalgroup platforms: - linux-amd64 - linux-x86 - linux-i386 - windows-x64 - windows-x86 channels: - alias: signal_channel - alias: network_channel Taskfile Global Vars The Taskfile global vars should include the following items:\nENTRYDIR - Necessary for operation of end-to-end tests. IMAGE - Specify the default location of the tool container repository. TAG - Specify the container image tag selection. Hint: Typically the tool name and repo name are identical.\nExample Taskfile with Global Vars --- version: '3' vars: # When running from E2E tests (i.e. Docker in Docker), the ENTRYDIR (for # Docker commands) must be set to the host relative path. ENTRYDIR: '{{if .SIM}}{{.ENTRYWORKDIR}}/{{.SIM}}{{else}}{{.PWD}}{{end}}' # Container image specification. FMI_IMAGE: '{{.FMI_IMAGE | default \"ghcr.io/boschglobal/dse-fmi\"}}' FMI_TAG: '{{if .FMI_TAG}}{{.FMI_TAG}}{{else}}{{if .IMAGE_TAG}}{{.IMAGE_TAG}}{{else}}latest{{end}}{{end}}' Workflow Task Definition Workflow Tasks are the interface used by the SDP and represent an API interface. They may call other tasks, as required, to implement a workflow. Workflow Tasks also include a Metadata object which is used by the SDP/DSL to assist in specifying variables when calling a Workflow Task.\nThe Metadata can include the following items:\nDefault - Indicate a default value for this variable (optional). Hint - A short description of the variable. For complex variables also consider including an example in the hint. Required - Indicates that this variable is required. Example Taskfile with a Task Definition\rtasks: patch-signalgroup: desc: Patch changes into a generated Signal Group. run: always dir: '{{.USER_WORKING_DIR}}' label: dse:fmi:patch-signalgroup vars: # INPUT: '{{.INPUT}}' # PATCH: '{{.PATCH}}' REMOVE_UNKNOWN: '{{if .REMOVE_UNKNOWN}}--remove-unknown{{else}}{{end}}' cmds: - docker run --rm -v {{.ENTRYDIR}}:/sim {{.FMI_IMAGE}}:{{.FMI_TAG}} patch-signalgroup --input {{.INPUT}} --patch {{.PATCH}} {{.REMOVE_UNKNOWN}} requires: vars: [INPUT, PATCH] metadata: vars: INPUT: required: true hint: Path identifying the Signal Group to be patched. PATCH: required: true hint: URI identifying the patch file to use. REMOVE_UNKNOWN: required: false hint: Remove unknown items (i.e. not in the patch file). default: false Note: The commented vars, necessary for the requires:vars to work, are retained for clarity/documentation.\nDeveloper Notes Vendoring Workflow tools that make use of private Go packages may need to be vendored (especially if the Workflows tools are in public repos).\nTesting Workflow tools should be unit tested. In some cases Testscript/Txtar tests may be a good alternative for writing tests. A repo should also include end-to-end tests where the focus in on the operation of the Models and Workflows together.\n","categories":"","description":"","excerpt":"The SDP builds simulations using Git repositories which contain both …","ref":"/dse.doc/docs/devel/sdp/workflows/","tags":"","title":"SDP Workflows"},{"body":"Documentation.\n","categories":"","description":"","excerpt":"Documentation.\n","ref":"/dse.doc/docs/","tags":"","title":"Documentation"},{"body":"Synopsis Containerized simulation validation tool for Simer based simulations.\n# Run the reports. $ dse-report path/to/simulation Report Tool Codespace The Codespace (aka Devcontainer) of the DSE Simulation Development Platform is pre-configured with a command for running the Report tool.\n# Run the reports. $ dse-report path/to/simulation Setup Report is a containerized tool which validates a simulation using a collection of report templates included in the Report container.\n# Latest Report Container: $ docker pull ghcr.io/boschglobal/dse-report:latest # Specific versions of the Report Container $ docker pull ghcr.io/boschglobal/dse-report:0.1.1 $ docker pull ghcr.io/boschglobal/dse-simer:0.1 Shell Function # Define a shell function for the report command. $ export DSE_REPORT_IMAGE=ghcr.io/boschglobal/dse-report:latest $ dse-report() { ( \\ if test -d \"$1\"; then cd \"$1\" \u0026\u0026 shift; fi \u0026\u0026 \\ docker run -t --rm \\ -v $(pwd):/sim \\ $DSE_REPORT_IMAGE /sim \"$@\"; ) } # Run the reports. $ dse-report path/to/simulation Options $ dse-report -h Running command: report Usage of report: -db string database connection string (default \"bolt://localhost:7687\") -list list all available reports and their tags -list-all list all available report details in tabular format -list-tags list all available tags from reports -name value run report with specified report name(s) -reports string run all reports form the specified reports folder -tag value run all reports with specified tag Examples Included Reports Run the Report Tool with all included reports.\n$ dse-report examples/graph/stack/sim_good ... === Summary =================================================================== [PASS] Duplicate Writes Check [PASS] ModelInstance Name Check [PASS] Model UID Check [PASS] Channel 'expectedModelCount' [PASS] Count 'ModelInst' in AST and SIM Ran 5 Reports | Passed: 5 | Failed: 0 Report Output $ dse-report examples/graph/stack/sim_good Running command: report Options: db : bolt://localhost:7687 list : false list-all : false list-tags : false log : 4 name : reports : tag : === Files =================================================================== sim/simulation.yaml === Report =================================================================== Name: Duplicate Writes Check Path: /home/memgraph/.local/share/dse-graph/reports/duplicate_writes.yaml Version: 0.0.0 Date: 2025-06-02 12:55:03 Query: Duplicate Write Signals Cypher: // Get output signals for each SimbusChannel. MATCH (sc:SimbusChannel)\u003c-[:Belongs]-(ch1:Channel) -[:Represents]-\u003e(:SignalGroup)-[:Contains]-\u003e(s1:Signal) WHERE s1.annotations.fmi_variable_causality = \"output\" WITH sc AS simbus_channel, collect(DISTINCT s1.name) AS output_signals // Get input signals from input model instance with matching selector.channel. MATCH (sc:SimbusChannel)\u003c-[:Belongs]-(ch2:Channel)\u003c-[:Alias]- (mi:ModelInst {name: \"input\"})-[:InstanceOf]-\u003e(:Model) MATCH (mi)-[:Has]-\u003e(sel:Selector)-[:Selects]-\u003e(:Label) \u003c-[:Has]-(:SignalGroup)-[:Contains]-\u003e(s2:Signal) WITH simbus_channel, output_signals, collect(DISTINCT s2.name) AS input_signal_list // Find intersection using UNWIND and WHERE. UNWIND input_signal_list AS individual_input_signal WITH simbus_channel, output_signals, input_signal_list, individual_input_signal WHERE individual_input_signal IN output_signals WITH simbus_channel, output_signals, input_signal_list, collect(individual_input_signal) AS common_signals RETURN simbus_channel, common_signals Results: Evaluation: Report Passed === Report =================================================================== Name: ModelInstance Name Check Path: /home/memgraph/.local/share/dse-graph/reports/stack.yaml Version: 0.0.0 Date: 2025-06-02 12:55:03 Query: Unique ModelInstance Name Cypher: MATCH (:Stack)-[:Has]-\u003e(mi:ModelInst) WHERE mi.name IS NOT NULL WITH mi.name AS name, count(*) AS count WHERE count \u003e 1 RETURN name, count Results: Evaluation: Report Passed === Report =================================================================== Name: Model UID Check Path: /home/memgraph/.local/share/dse-graph/reports/stack.yaml Version: 0.0.0 Date: 2025-06-02 12:55:03 Query: Unique Non-zero Model UID Cypher: MATCH (:Stack)-[:Has]-\u003e(mi:ModelInst) WHERE mi.uid IS NOT NULL WITH mi.uid AS uid, collect(mi.name) AS names, count(*) AS count WHERE uid = \"0\" OR count \u003e 1 RETURN uid, count, names Results: Evaluation: Report Passed === Report =================================================================== Name: Channel 'expectedModelCount' Path: /home/memgraph/.local/share/dse-graph/reports/static_validation.yaml Version: 0.0.0 Date: 2025-06-02 12:55:03 Query: Expected Count Cypher: MATCH (mi:ModelInst)-[:Alias]-\u003e(ch:Channel) WITH ch.name AS channelName, COUNT(DISTINCT mi) AS actualCount MATCH (:Stack)-[:Has]-\u003e(:Simbus)-[:Has]-\u003e(sc:SimbusChannel) WHERE sc.name = channelName RETURN channelName, sc.expectedModelCount AS expectedCount, actualCount, CASE WHEN sc.expectedModelCount = actualCount THEN \"PASS\" ELSE \"FAIL\" END AS result Results: +--------------+---------------+-------------+--------+ | CHANNELNAME | EXPECTEDCOUNT | ACTUALCOUNT | RESULT | +--------------+---------------+-------------+--------+ | data_channel | 4 | 4 | PASS | +--------------+---------------+-------------+--------+ Evaluation: Report Passed Query: Model to Channel Mapping Cypher: MATCH (st:Stack)-[:Has]-\u003e(mi:ModelInst)-[a:Alias]-\u003e(ch:Channel) WITH mi, a, ch RETURN mi.name AS modelInstName, a.name as alias, ch.name AS channelName Results: +---------------+-------+--------------+ | MODELINSTNAME | ALIAS | CHANNELNAME | +---------------+-------+--------------+ | counter_A | data | data_channel | | counter_B | data | data_channel | | counter_C | data | data_channel | | counter_D | data | data_channel | +---------------+-------+--------------+ === Report =================================================================== Name: Count 'ModelInst' in AST and SIM Path: /home/memgraph/.local/share/dse-graph/reports/static_validation.yaml Version: 0.0.0 Date: 2025-06-02 12:55:03 Query: Expected Count Cypher: MATCH (fl:File)-[:Contains]-\u003e(st:Stack)-[:Has]-\u003e(mi:ModelInst) WITH fl, COUNT(DISTINCT mi) AS countSim MATCH (fl)-[:Contains]-\u003e(sim:Simulation)-[:Has]-\u003e(st2:Stack)-[:Has]-\u003e(mi2:ModelInst) WITH countSim, COUNT(DISTINCT mi2) AS countAst RETURN countAst AS astModelInstCount, countSim AS simModelInstCount, CASE WHEN countAst = countSim THEN \"PASS\" ELSE \"FAIL\" END AS result Results: No records found Evaluation: Report Passed === Summary =================================================================== [PASS] Duplicate Writes Check [PASS] ModelInstance Name Check [PASS] Model UID Check [PASS] Channel 'expectedModelCount' [PASS] Count 'ModelInst' in AST and SIM Ran 5 Reports | Passed: 5 | Failed: 0 Definitions Cypher Declarative query language used to interact with graph databases. Report A YAML file that defines database queries and expected results, to check correctness of imported simulation data. Simulation The structural arrangement of several Models, which, when connected via a Simulation Bus, form a simulation. Typically defined in a file simulation.yaml. Simulation Package (simulation path/folder) This folder contains all configuration, models and artifacts necessary to run a simulation. ","categories":"","description":"","excerpt":"Synopsis Containerized simulation validation tool for Simer based …","ref":"/dse.doc/docs/user/report/","tags":["Graph","Report","CLI"],"title":"Report - Simulation Validation"},{"body":"Dynamic Simulation Environment - User Guide.\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - User Guide.\n","ref":"/dse.doc/docs/user/","tags":"","title":"User Guide"},{"body":"Schema documentation.\n","categories":"","description":"","excerpt":"Schema documentation.\n","ref":"/dse.doc/schemas/","tags":"","title":"Schemas"},{"body":"Synopsis Simulation Development Platform (SDP) using Codespaces or DevContainers to code, build, and run DSE Simulations.\nSetup GitHub Codespaces GitHub Codespaces provides a cloud-hosted development environment which is pre-configured for the SDP. This environment includes SDP Extensions and can be immediately used to build and run simulations.\nSteps to use Codespaces: Go to the repository on GitHub. Click the Code button and choose Open with Codespaces. If you don’t have an existing codespace, click New codespace to create one. After some moments your Codespace will be ready. Dev Containers VS Code Dev Containers can be configured to run the SDP within Visual Studio, and the SDP Extensions can also be installed. This approach requires a Docker environment (e.g. WSL2 or Docker Desktop).\nSteps to use a Dev Container: TODO: This section needs to be updated.\nConfigure the Dev Container.\nInstall the extension using VS Code GUI:\nOpen the Extensions view by pressing Ctrl+Shift+X. Click the ... (More Actions) menu in the top-right corner of the Extensions panel. Select Install from VSIX.... Navigate to the lsp/out/bin folder and select the generated dse.vsix file. Native Linux The SDP Builder and Report tool, as well as the Simer simulation run-time, are all containerized tools which can be configured and used in a Linux environment.\nUsage GitHub Workflows TODO: This section needs to be updated.\nVS Code Extension VS Code DSE Commands The following commands are available via the Command Palette (Ctrl+Shift+P) when the SDP extension is installed:\nCommand Description Build (DSE: Build) Generates simulation.yaml and Taskfile.yml from the active .dse file. This prepares the simulation environment. Check (DSE: Check) Analyzes the simulation graph and produces a report to help visualize and verify the structure of the simulation. Run (DSE: Run) Executes the simulation using the currently configured simulation definition. Clean (DSE: Clean) Performs a clean operation using task: clean, removing generated artifacts and build files. Cleanall (DSE: Cleanall) Performs a deep clean via task: cleanall, removing all outputs and intermediate data. Live AST View The extension supports live viewing of the models and channels derived from .dse files\nTo view the AST preview Open a supported .dse file in the VS Code editor. Click the Open Preview button in the upper-right corner of the editor window. Alternatively, you can use keyboard shortcuts Press Ctrl + K V to open preview in a side panel. Press Ctrl + Shift + V to open preview in the main panel. ","categories":"","description":"","excerpt":"Synopsis Simulation Development Platform (SDP) using Codespaces or …","ref":"/dse.doc/docs/user/sdp/","tags":["SDP"],"title":"SDP - Simulation Development Platform"},{"body":"Dynamic Simulation Environment - Architecture Documents\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - Architecture Documents\n","ref":"/dse.doc/docs/arch/","tags":"","title":"Architecture Documents"},{"body":"DSE Models ","categories":"","description":"","excerpt":"DSE Models ","ref":"/dse.doc/docs/user/models/","tags":"","title":"DSE Models"},{"body":"API Documentation.\n","categories":"","description":"","excerpt":"API Documentation.\n","ref":"/dse.doc/apis/","tags":"","title":"APIs"},{"body":"Dynamic Simulation Environment - Developer Documentation\n","categories":"","description":"","excerpt":"Dynamic Simulation Environment - Developer Documentation\n","ref":"/dse.doc/docs/devel/","tags":"","title":"Developer Documentation"},{"body":"ModelC API Reference ","categories":"","description":"","excerpt":"ModelC API Reference ","ref":"/dse.doc/apis/modelc/","tags":"","title":"ModelC API Reference"},{"body":"Synopsis AST Tools.\n$ dse-ast \u003ccommand\u003e [flags] The dse-ast toolchain provides commands for processing and transforming Abstract Syntax Trees (ASTs) in YAML format, based on input JSON.\nCommands convert Transform the JSON into a YAML-based Abstract Syntax Tree (AST).\n$ dse-ast convert -input \u003cjson_file_path\u003e -output \u003cyaml_ast_output_path\u003e resolve Resolve internal references within the AST to produce a fully linked version.\n$ dse-ast resolve -input \u003cyaml_ast_path\u003e -output \u003cyaml_ast_output_path\u003e generate Generate the final output simulation files based on the resolved AST.\n$ dse-ast generate -input \u003cyaml_ast_path\u003e -output \u003coutput_path\u003e ","categories":"","description":"","excerpt":"Synopsis AST Tools.\n$ dse-ast \u003ccommand\u003e [flags] The dse-ast toolchain …","ref":"/dse.doc/docs/user/tools/ast/","tags":["SDP","CLI"],"title":"AST - AST Tools"},{"body":"Synopsis DSL Tools.\n$ dse-parse2ast [args] Commands dse-parse2ast Convert a DSE file into an intermediate JSON representation.\n$ dse-parse2ast \u003cdse_file_path\u003e \u003cjson_output_file_path\u003e Keywords simulation Defines the simulation setup including architecture, stepsize, and endtime.\nsimulation arch=linux-amd64 stepsize=0.0005 endtime=0.005\rarch Specifies the architecture in simulation or stack or model level (default : linux-amd64 ).\nsimulation arch=linux-amd64\rstepsize Time increment for each simulation step (default : 0.0005).\nsimulation stepsize=0.0005\rendtime Total simulation duration step (default : 0.005).\nsimulation endtime=0.005\rchannel Declares a communication channel.\nchannel physical\rnetwork Defines a network interface.\nnetwork CAN 'application/x-automotive-bus;interface=stream;type=frame;bus=can;schema=fbs;bus_id=1'\ruses Imports external dependencies such as modules, FMUs, or files. The uses keyword supports both remote and local references.\nRemote references Dependencies can be fetched from external sources such as GitHub or artifact repositories.\nAuthentication (e.g., using a personal access token) may be required.\nuses\rdse.fmi https://github.com/boschglobal/dse.fmi v1.1.34\rexample https://github.boschdevcloud.com/fsil/fsil.runnable/releases/download/v1.1.2/example.zip token={{.GHE_PAT}}\rLocal references Dependencies can also be referenced directly from the local filesystem. Both absolute and relative paths are supported.\nuses\rexample1 /home/users/example.zip\rexample2 example.zip\rvar Declares variables, which may refer to other resources or contain static values.\nmodel runnable fsil.runnable uid=5\rchannel signal signal_channel\rchannel network network_channel\rworkflow unpack-runnable-target\rvar ROOT_DIR {{.OUTDIR}}\rvar ZIP uses example\rvar DIR {{.SIMDIR}}/{{.PATH}}\rmodel Defines a component in the simulation, such as an FMU or a gateway.\nmodel runnable fsil.runnable\rchannel signal signal_channel\rchannel network network_channel\ruid Assigns a unique ID to a model.\nmodel runnable fsil.runnable uid=5\rchannel signal signal_channel\rchannel network network_channel\renvar Declares an environment variable used at model or stack scope.\nmodel runnable fsil.runnable uid=5\rchannel signal signal_channel\rchannel network network_channel\renvar SIMBUS_LOGLEVEL 3\rworkflow Defines a processing or generation step applied to a model or stack.\nmodel runnable fsil.runnable uid=5\rchannel signal signal_channel\rchannel network network_channel\rworkflow unpack-runnable-target\rvar ROOT_DIR {{.OUTDIR}}\rvar ZIP uses example\rvar DIR {{.SIMDIR}}/{{.PATH}}\rstack Declares a group of models composed together for simulation.\nstack fmu-stack\rmodel FMU_S1 dse.fmi.mcl\rchannel physical scalar_vector\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_s1\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rmodel FMU_S2 dse.fmi.mcl\rchannel physical scalar_vector\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_s2\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rstacked A boolean flag that indicates if the models in a stack should be layered.\nstack fmu-stack stacked=true arch=linux-x86\rmodel FMU_S1 dse.fmi.mcl\rchannel physical scalar_vector\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_s1\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rmodel FMU_S2 dse.fmi.mcl\rchannel physical scalar_vector\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_s2\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rsequential A boolean flag for stacks that ensures models are executed one after another, in a defined order.\nstack fmu-stack stacked=true sequential=true arch=linux-x86\rmodel FMU_S1 dse.fmi.mcl\rchannel physical scalar_vector\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_s1\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rmodel FMU_S2 dse.fmi.mcl\rchannel physical scalar_vector\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_s2\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rfile Maps or includes external input/configuration files in the simulation.\nmodel FMU dse.fmi.mcl uid=42\rchannel physical scalar_vector\rfile input.csv uses input_file\rfile data/signalgroup.yaml sample/data/signalgroup.yaml\rworkflow generate-fmimcl\rvar FMU_DIR uses fmu_2\rvar MCL_PATH some/path\rvar OUT_DIR {{.model.name}}\rExample DSL File openloop.dse\rsimulation arch=linux-amd64\rchannel physical\ruses\rdse.modelc https://github.com/boschglobal/dse.modelc v2.1.23\rdse.fmi https://github.com/boschglobal/dse.fmi v1.1.23\rlinear_fmu https://github.com/boschglobal/dse.fmi/releases/download/v1.1.23/Fmi-1.1.23-linux-amd64.zip path=examples/fmu/linear/fmi2/linear.fmu\rmodel input dse.modelc.csv\rchannel physical signal_channel\renvar CSV_FILE model/input/data/input.csv\rfile input.csv input/openloop.csv\rfile signalgroup.yaml input/signalgroup.yaml\rmodel linear dse.fmi.mcl\rchannel physical signal_channel\renvar MEASUREMENT_FILE /sim/measurement.mf4\rworkflow generate-fmimcl\rvar FMU_DIR uses linear_fmu\rvar OUT_DIR {{.PATH}}/data\rvar MCL_PATH {{.PATH}}/lib/libfmimcl.so\rSyntax Diagram ","categories":"","description":"","excerpt":"Synopsis DSL Tools.\n$ dse-parse2ast [args] Commands dse-parse2ast …","ref":"/dse.doc/docs/user/tools/dsl/","tags":["SDP","CLI"],"title":"DSL - DSL Tools"},{"body":"Synopsis Graph Tools for static and dynamic analysis of Simulations.\n$ dse-graph report examples/graph/\u003csim-name\u003e/\u003csim-status\u003e Commands The Graph tool includes the following commands and options:\nDrop $ dse-graph drop \u003csim|ast|-all\u003e Import dse-graph import examples/graph/\u003csim-name\u003e/\u003csim-status\u003e Export $ dse-graph export export.cyp Report dse-graph report examples/graph/\u003csim-name\u003e/\u003csim-status\u003e Option Tag (-tag) dse-graph report -tag=tag_name examples/graph/\u003csim-name\u003e/\u003csim-status\u003e Option List (-list) dse-graph report \u003c-list|-list-all|-list-tags\u003e Option Name (-name) dse-graph report -name=\"Report1;Report2\" examples/graph/\u003csim-name\u003e/\u003csim-status\u003e Option Reports (-reports) dse-graph report -reports=path/to/reports examples/graph/\u003csim-name\u003e/\u003csim-status\u003e Report Appliance Usage # Start the memgraph container (using a make target). $ make graph # Build containerized graph tool. $ make docker # Run tests. $ make test # Define a shell function for the report command. $ dse-report() { docker run -t --rm \\ -v \"$(pwd)\":/sim \\ dse-report:test \"$@\" } # Run the reports on a simulation. $ dse-report examples/graph/static_validation/sim_good ... === Summary =================================================================== [PASS] Duplicate Writes Check [PASS] ModelInstance Name Check [PASS] Model UID Check [PASS] Channel 'expectedModelCount' [PASS] Count 'ModelInst' in AST and SIM Ran 5 Reports | Passed: 5 | Failed: 0 # Run specific reports by name. $ dse-report --name=\"Model UID Check;ModelInstance Name Check\" examples/graph/stack/sim_good ... === Summary =================================================================== [PASS] ModelInstance Name Check [PASS] Model UID Check Ran 2 Reports | Passed: 2 | Failed: 0 Reports Static Validation Performs a collection of static validation checks on simulation configuration files.\nStatic Validation - Simulation with no errors\r$ dse-report --name=\"Channel 'expectedModelCount';Count 'ModelInst' in AST and SIM\" examples/graph/static_validation/sim_good ... Pinging Memgraph... ... Running command: drop ... Running command: report Options: db : bolt://localhost:7687 list : false list-all : false list-tags : false name : reports : tag : 2025/05/22 20:05:59 INFO Connect to graph db=bolt://localhost:7687 Handler: yaml/kind=Stack Handler: yaml/kind=Model Handler: yaml/kind=Simulation simulation.yaml Stack simulation.yaml Model simulation.yaml Simulation === Report =================================================================== Name: Channel 'expectedModelCount' Path: /home/memgraph/.local/share/dse-graph/reports/static_validation.yaml Version: 0.0.0 Date: 2025-05-27 10:14:51 Query: Expected Count Cypher: MATCH (mi:ModelInst)-[:Alias]-\u003e(ch:Channel) WITH ch.name AS channelName, COUNT(DISTINCT mi) AS actualCount MATCH (:Stack)-[:Has]-\u003e(:Simbus)-[:Has]-\u003e(sc:SimbusChannel) WHERE sc.name = channelName RETURN channelName, sc.expectedModelCount AS expectedCount, actualCount, CASE WHEN sc.expectedModelCount = actualCount THEN \"PASS\" ELSE \"FAIL\" END AS result Results: +-------------+---------------+-------------+--------+ | CHANNELNAME | EXPECTEDCOUNT | ACTUALCOUNT | RESULT | +-------------+---------------+-------------+--------+ | Network | 1 | 1 | PASS | | physical | 2 | 2 | PASS | +-------------+---------------+-------------+--------+ Evaluation: Report Passed Query: Model to Channel Mapping Cypher: MATCH (st:Stack)-[:Has]-\u003e(mi:ModelInst)-[a:Alias]-\u003e(ch:Channel) WITH mi, a, ch RETURN mi.name AS modelInstName, a.name as alias, ch.name AS channelName Results: +---------------+-----------------+-------------+ | MODELINSTNAME | ALIAS | CHANNELNAME | +---------------+-----------------+-------------+ | input | scalar | physical | | linear | signal_channel | physical | | linear | network_channel | Network | +---------------+-----------------+-------------+ === Report =================================================================== Name: Count 'ModelInst' in AST and SIM Path: /home/memgraph/.local/share/dse-graph/reports/static_validation.yaml Version: 0.0.0 Date: 2025-05-27 10:14:51 Query: Expected Count Cypher: MATCH (fl:File)-[:Contains]-\u003e(st:Stack)-[:Has]-\u003e(mi:ModelInst) WITH fl, COUNT(DISTINCT mi) AS countSim MATCH (fl)-[:Contains]-\u003e(sim:Simulation)-[:Has]-\u003e(st2:Stack)-[:Has]-\u003e(mi2:ModelInst) WITH countSim, COUNT(DISTINCT mi2) AS countAst RETURN countAst AS astModelInstCount, countSim AS simModelInstCount, CASE WHEN countAst = countSim THEN \"PASS\" ELSE \"FAIL\" END AS result Results: +-------------------+-------------------+--------+ | ASTMODELINSTCOUNT | SIMMODELINSTCOUNT | RESULT | +-------------------+-------------------+--------+ | 2 | 2 | PASS | +-------------------+-------------------+--------+ Evaluation: Report Passed === Summary =================================================================== [PASS] Channel 'expectedModelCount' [PASS] Count 'ModelInst' in AST and SIM Ran 2 Reports | Passed: 2 | Failed: 0 Static Validation - Simulation with errors\r$ dse-report --name=\"Channel 'expectedModelCount';Count 'ModelInst' in AST and SIM\" examples/graph/static_validation/sim_with_error ... Pinging Memgraph... ... Running command: drop ... Running command: report Options: db : bolt://localhost:7687 list : false list-all : false list-tags : false name : reports : tag : 2025/05/22 20:10:03 INFO Connect to graph db=bolt://localhost:7687 Handler: yaml/kind=Stack Handler: yaml/kind=Model Handler: yaml/kind=Simulation simulation.yaml Stack simulation.yaml Model simulation.yaml Simulation === Report =================================================================== Name: Channel 'expectedModelCount' Path: /home/memgraph/.local/share/dse-graph/reports/static_validation.yaml Version: 0.0.0 Date: 2025-05-27 10:15:29 Query: Expected Count Cypher: MATCH (mi:ModelInst)-[:Alias]-\u003e(ch:Channel) WITH ch.name AS channelName, COUNT(DISTINCT mi) AS actualCount MATCH (:Stack)-[:Has]-\u003e(:Simbus)-[:Has]-\u003e(sc:SimbusChannel) WHERE sc.name = channelName RETURN channelName, sc.expectedModelCount AS expectedCount, actualCount, CASE WHEN sc.expectedModelCount = actualCount THEN \"PASS\" ELSE \"FAIL\" END AS result Results: +-------------+---------------+-------------+--------+ | CHANNELNAME | EXPECTEDCOUNT | ACTUALCOUNT | RESULT | +-------------+---------------+-------------+--------+ | Network | 1 | 1 | PASS | | physical | 2 | 2 | PASS | +-------------+---------------+-------------+--------+ Evaluation: Report Passed Query: Model to Channel Mapping Cypher: MATCH (st:Stack)-[:Has]-\u003e(mi:ModelInst)-[a:Alias]-\u003e(ch:Channel) WITH mi, a, ch RETURN mi.name AS modelInstName, a.name as alias, ch.name AS channelName Results: +---------------+-----------------+-------------+ | MODELINSTNAME | ALIAS | CHANNELNAME | +---------------+-----------------+-------------+ | input | scalar | physical | | linear | signal_channel | physical | | linear | network_channel | Network | +---------------+-----------------+-------------+ === Report =================================================================== Name: Count 'ModelInst' in AST and SIM Path: /home/memgraph/.local/share/dse-graph/reports/static_validation.yaml Version: 0.0.0 Date: 2025-05-27 10:15:29 Query: Expected Count Cypher: MATCH (fl:File)-[:Contains]-\u003e(st:Stack)-[:Has]-\u003e(mi:ModelInst) WITH fl, COUNT(DISTINCT mi) AS countSim MATCH (fl)-[:Contains]-\u003e(sim:Simulation)-[:Has]-\u003e(st2:Stack)-[:Has]-\u003e(mi2:ModelInst) WITH countSim, COUNT(DISTINCT mi2) AS countAst RETURN countAst AS astModelInstCount, countSim AS simModelInstCount, CASE WHEN countAst = countSim THEN \"PASS\" ELSE \"FAIL\" END AS result Results: +-------------------+-------------------+--------+ | ASTMODELINSTCOUNT | SIMMODELINSTCOUNT | RESULT | +-------------------+-------------------+--------+ | 1 | 2 | FAIL | +-------------------+-------------------+--------+ Evaluation: Report Failed Hint: The number of Model Instances in AST do not match the number of Model Instances in SIM. === Summary =================================================================== [PASS] Channel 'expectedModelCount' [FAIL] Count 'ModelInst' in AST and SIM Ran 2 Reports | Passed: 1 | Failed: 1 Duplicate Writes Check a simulation configuration for Signals which are written by multiple Models. In such instances the value of a signal becomes non-deterministic - such simulations may be incorrectly configured.\nDuplicate Writes - Simulation configuration check\r... Pinging Memgraph... ... Running command: drop ... $ dse-report --name=\"Duplicate Writes Check\" examples/graph/duplicate_writes/sim_with_error Running command: report Options: db : bolt://localhost:7687 list : false list-all : false list-tags : false name : reports : tag : 2025/05/22 20:12:27 INFO Connect to graph db=bolt://localhost:7687 Handler: yaml/kind=Stack Handler: yaml/kind=Model simulation.yaml Stack simulation.yaml Model Handler: yaml/kind=Model model.yaml Model Handler: yaml/kind=SignalGroup signalgroup.yaml SignalGroup Handler: yaml/kind=Model model.yaml Model Handler: yaml/kind=SignalGroup Handler: yaml/kind=SignalGroup signalgroup.yaml SignalGroup signalgroup.yaml SignalGroup 2025/05/27 10:15:48 Relationship created: Channel(ID: 7421) -\u003e Represents -\u003e SignalGroup(ID: 7439) 2025/05/27 10:15:48 Skipping channel ID 7428 (labelCount: 1, selectorCount: 2) 2025/05/27 10:15:48 Relationship created: Channel(ID: 7428) -\u003e Represents -\u003e SignalGroup(ID: 7455) 2025/05/27 10:15:48 Relationship created: Channel(ID: 7421) -\u003e Represents -\u003e SignalGroup(ID: 7448) 2025/05/27 10:15:48 Skipping channel ID 7421 (labelCount: 1, selectorCount: 2) === Report =================================================================== Name: Duplicate Writes Check Path: /home/memgraph/.local/share/dse-graph/reports/duplicate_writes.yaml Version: 0.0.0 Date: 2025-05-27 10:15:48 Query: Duplicate Write Signals Cypher: // Get output signals for each SimbusChannel. MATCH (sc:SimbusChannel)\u003c-[:Belongs]-(ch1:Channel) -[:Represents]-\u003e(:SignalGroup)-[:Contains]-\u003e(s1:Signal) WHERE s1.annotations.fmi_variable_causality = \"output\" WITH sc AS simbus_channel, collect(DISTINCT s1.name) AS output_signals // Get input signals from input model instance with matching selector.channel. MATCH (sc:SimbusChannel)\u003c-[:Belongs]-(ch2:Channel)\u003c-[:Alias]- (mi:ModelInst {name: \"input\"})-[:InstanceOf]-\u003e(:Model) MATCH (mi)-[:Has]-\u003e(sel:Selector)-[:Selects]-\u003e(:Label) \u003c-[:Has]-(:SignalGroup)-[:Contains]-\u003e(s2:Signal) WITH simbus_channel, output_signals, collect(DISTINCT s2.name) AS input_signal_list // Find intersection using UNWIND and WHERE. UNWIND input_signal_list AS individual_input_signal WITH simbus_channel, output_signals, input_signal_list, individual_input_signal WHERE individual_input_signal IN output_signals WITH simbus_channel, output_signals, input_signal_list, collect(individual_input_signal) AS common_signals RETURN simbus_channel, common_signals Results: +-------------------------------------------------------------------------+----------------+ | SIMBUS_CHANNEL | COMMON_SIGNALS | +-------------------------------------------------------------------------+----------------+ | {7418 7418 [Sim SimbusChannel] map[expectedModelCount:2 name:physical]} | [factor] | +-------------------------------------------------------------------------+----------------+ Evaluation: Report Failed === Summary =================================================================== [FAIL] Duplicate Writes Check Ran 1 Reports | Passed: 0 | Failed: 1 Stack Check that a simulation configuration contains only unique ModelInstance names and that all Model UIDs are unique and non-zero.\nStack - Simulation configuration check\r... Pinging Memgraph... ... Running command: drop ... $ dse-report --name=\"ModelInstance Name Check;Model UID Check\" examples/graph/stack/sim_with_error Running command: report Options: db : bolt://localhost:7687 list : false list-all : false list-tags : false name : reports : tag : 2025/05/22 20:18:33 INFO Connect to graph db=bolt://localhost:7687 Handler: yaml/kind=Stack Handler: yaml/kind=Stack Handler: yaml/kind=Stack Handler: yaml/kind=Model simulation.yaml Stack simulation.yaml Stack simulation.yaml Stack simulation.yaml Model === Report =================================================================== Name: ModelInstance Name Check Path: /home/memgraph/.local/share/dse-graph/reports/stack.yaml Version: 0.0.0 Date: 2025-05-27 10:16:31 Query: Unique ModelInstance Name Cypher: MATCH (:Stack)-[:Has]-\u003e(mi:ModelInst) WHERE mi.name IS NOT NULL WITH mi.name AS name, count(*) AS count WHERE count \u003e 1 RETURN name, count Results: +-----------+-------+ | NAME | COUNT | +-----------+-------+ | counter_A | 2 | +-----------+-------+ Evaluation: Report Failed === Report =================================================================== Name: Model UID Check Path: /home/memgraph/.local/share/dse-graph/reports/stack.yaml Version: 0.0.0 Date: 2025-05-27 10:16:31 Query: Unique Non-zero Model UID Cypher: MATCH (:Stack)-[:Has]-\u003e(mi:ModelInst) WHERE mi.uid IS NOT NULL WITH mi.uid AS uid, collect(mi.name) AS names, count(*) AS count WHERE uid = \"0\" OR count \u003e 1 RETURN uid, count, names Results: +-----+-------+-----------------------+ | UID | COUNT | NAMES | +-----+-------+-----------------------+ | 43 | 2 | [counter_B counter_C] | | 0 | 1 | [counter_A] | +-----+-------+-----------------------+ Evaluation: Report Failed === Summary =================================================================== [FAIL] ModelInstance Name Check [FAIL] Model UID Check Ran 2 Reports | Passed: 0 | Failed: 2 ","categories":"","description":"","excerpt":"Synopsis Graph Tools for static and dynamic analysis of Simulations.\n$ …","ref":"/dse.doc/docs/user/tools/graph/","tags":["SDP","CLI"],"title":"Graph - Graph Tools"},{"body":"Synopsis LSP Tools.\nLive AST View The extension supports live viewing of the models and channels derived from .dse files\nTo view the AST preview Open a supported .dse file in the VS Code editor. Click the Open Preview button in the upper-right corner of the editor window. Alternatively, you can use keyboard shortcuts Press Ctrl + K V to open preview in a side panel. Press Ctrl + Shift + V to open preview in the main panel. Important: One-Time Setup for Local Environments If you’re working locally in VS Code (not in GitHub Codespaces), you may need to manually install required global dependencies the first time:\ncd dse.sdp/dsl npm install -g --force This will ensure that all necessary global dependencies are installed properly.\nCommands The following commands are available via the Command Palette (Ctrl+Shift+P) when the SDP extension is installed:\nCommand Description Build (DSE: Build) Generates simulation.yaml and Taskfile.yml from the active .dse file. This prepares the simulation environment. Check (DSE: Check) Analyzes the simulation graph and produces a report to help visualize and verify the structure of the simulation. Run (DSE: Run) Executes the simulation using the currently configured simulation definition. Clean (DSE: Clean) Performs a clean operation using task: clean, removing generated artifacts and build files. Cleanall (DSE: Cleanall) Performs a deep clean via task: cleanall, removing all outputs and intermediate data. ","categories":"","description":"","excerpt":"Synopsis LSP Tools.\nLive AST View The extension supports live viewing …","ref":"/dse.doc/docs/user/tools/lsp/","tags":["SDP","CLI"],"title":"LSP - LSP Tools"},{"body":"Synopsis Simulation trace tool.\n# Create the trace folder. $ mkdir examples/binary/data/trace # Collect a SimBus trace from a simulation run. $ docker run --name simer -i --rm \\ --volume ./examples/binary:/sim \\ --env SIMBUS_TRACEFILE=data/trace/simbus.bin \\ ghcr.io/boschglobal/dse-simer:latest # Print a long-form summary of the trace file. $ docker run --name simer -i --rm \\ --volume ./examples/binary:/sim \\ --entrypoint /usr/local/bin/trace \\ ghcr.io/boschglobal/dse-simer:latest summary -long data/trace/simbus.bin Commands The Trace tool includes the following commands and options:\nTrace tools for working with SimBus trace files. Usage: trace \u003ccommand\u003e [option] \u003ctrace file\u003e trace summary [--short, --long] \u003ctrace file\u003e summary Options: -long *flag.boolValue generate a long summary (default: false) -short *flag.boolValue generate a short summary (default: true) Note: The trace command is included with the Simer container image (installed to location /usr/local/bin/trace).\nSummary Prints a summary of the SimBus trace messages contained in a trace file to the console. Several options are available to control the message formatting.\nOption Short (-short) Print a short summary of messages contained in a SimBus trace file.\nExample $ trace summary -short data/trace/simbus.bin scalar_channel:42:1:0::ModelRegister binary_channel:42:1:0::ModelRegister scalar_channel:42:2:0::ModelRegister binary_channel:42:2:0::ModelRegister scalar_channel:42:0:0::SignalIndex binary_channel:42:0:0::SignalIndex scalar_channel:42:0:0::SignalRead binary_channel:42:0:0::SignalValue scalar_channel:42:0:0::SignalIndex binary_channel:42:0:0::SignalIndex scalar_channel:42:0:0::SignalRead binary_channel:42:0:0::SignalValue Notify:0.000000:0.000000:0.000000 (S)\u003c--(M) (42) Notify:0.000000:0.000000:0.000500 (S)--\u003e(M) (0) Notify:0.000500:0.000000:0.000000 (S)\u003c--(M) (42) Notify:0.000500:0.000000:0.001000 (S)--\u003e(M) (0) Notify:0.001000:0.000000:0.000000 (S)\u003c--(M) (42) Notify:0.001000:0.000000:0.001500 (S)--\u003e(M) (0) Notify:0.001500:0.000000:0.000000 (S)\u003c--(M) (42) Notify:0.001500:0.000000:0.002000 (S)--\u003e(M) (0) Notify:0.002000:0.000000:0.000000 (S)\u003c--(M) (42) Notify:0.002000:0.000000:0.002500 (S)--\u003e(M) (0) scalar_channel:42:0:0::ModelExit scalar_channel:42:0:0::ModelExit Option Long (-long) Print a longer summary of messages contained in a SimBus trace file.\nExample $ trace summary -long data/trace/simbus.bin scalar_channel:42:1:0::ModelRegister binary_channel:42:1:0::ModelRegister ... [0.000000] Notify:0.000000:0.000000:0.000000 (S)\u003c--(M) (42) [0.000000] Notify[42]:SignalVector:scalar_channel [0.000000] Notify[42]:SignalVector:scalar_channel:Signal:counter=42.000000 [0.000000] Notify[42]:SignalVector:binary_channel [0.000000] Notify:0.000000:0.000000:0.000500 (S)--\u003e(M) (0) [0.000000] Notify[8000008]:SignalVector:scalar_channel [0.000000] Notify[8000008]:SignalVector:scalar_channel:Signal:counter=42.000000 [0.000000] Notify[8000008]:SignalVector:binary_channel [0.000500] Notify:0.000500:0.000000:0.000000 (S)\u003c--(M) (42) [0.000500] Notify[42]:SignalVector:scalar_channel [0.000500] Notify[42]:SignalVector:scalar_channel:Signal:counter=43.000000 [0.000500] Notify[42]:SignalVector:binary_channel [0.000500] Notify[42]:SignalVector:binary_channel:Signal:message=len(12) [0.000500] Notify:0.000500:0.000000:0.001000 (S)--\u003e(M) (0) [0.000500] Notify[8000008]:SignalVector:scalar_channel [0.000500] Notify[8000008]:SignalVector:scalar_channel:Signal:counter=43.000000 [0.000500] Notify[8000008]:SignalVector:binary_channel [0.000500] Notify[8000008]:SignalVector:binary_channel:Signal:message=len(12) ... scalar_channel:42:0:0::ModelExit scalar_channel:42:0:0::ModelExit Go Package The Trace tool implements a Visitor API which can be used to implement custom trace commands. An example of a custom Visitor is as follows:\npackage count import \"github.com/boschglobal/dse.modelc/extra/tools/trace/pkg/trace\" type CountVisitor struct { msgCount uint32 notifyCount uint32 } func (c *CountVisitor) VisitChannelMsg(cm trace.ChannelMsg) { c.msgCount += 1 } func (c *CountVisitor) VisitNotifyMsg(nm trace.NotifyMsg) { c.msgCount += 1 c.notifyCount += 1 } ","categories":"","description":"","excerpt":"Synopsis Simulation trace tool.\n# Create the trace folder. $ mkdir …","ref":"/dse.doc/docs/user/tools/trace/","tags":["trace","CLI"],"title":"Trace - Simulation Trace Tool"},{"body":"C Lib API Reference ","categories":"","description":"","excerpt":"C Lib API Reference ","ref":"/dse.doc/apis/clib/","tags":"","title":"C Lib API Reference"},{"body":"ModelC Debug Methods ","categories":"","description":"","excerpt":"ModelC Debug Methods ","ref":"/dse.doc/docs/devel/debug/","tags":"","title":"Debug Methods"},{"body":"Synposis FMI Gateway FMU\nSimulation Setup Structure Example Simulation Setup DOC: Provide description of Gateway Taskfile workflows.\nOperation The configuration and operation of the gateway is done in the stack.yaml that is to be loaded by the gateway. The stack follows the following schema with some additional, gateway specific annotations/ additions.\nStack Metadata Name Type Required Description metadata object true none » name string true This field is required to be named “gateway” » annotation object false none »» start_redis boolean true Set to false with no redis instance should be started on windows, can be controlled via environment variable »» create_logfiles boolean false Set to true to create Logfiles of the started models, can be controlled via environment variable »» show_redis boolean false Set to true if the redis process should be shown as terminal window, can be controlled via environment variable »» show_simbus boolean false Set to true if the simbus process should be shown as terminal window, can be controlled via environment variable »» show_models boolean false Set to true if the model processes should be shown as terminal windows, can be controlled via environment variable »» model_stack string false Name of the Stack.yaml containing the model descriptions. Required for session handling --- kind: Stack metadata: name: gateway annotations: redis_show: true simbus_show: true models_show: true model_stack: stack_models_parser.yaml Runtime Name Type Required Description spec object true none » runtime object false none »» env object false none »»» REDIS_EXE_PATH string false Path to the redis executable. If set, redis is handled by the gateway »»» SIMBUS_EXE_PATH string false Path to the simbus executable. Required if simbus is handled by the gateway »»» MODELC_EXE_PATH string false Path to the modelc executable. Required if models are handled by the gateway --- kind: Stack metadata: name: gateway spec: runtime: env: REDIS_EXE_PATH: redis.exe SIMBUS_EXE_PATH: simbus.exe MODELC_EXE_PATH: modelc.exe Simbus If the simbus should be handled by the gateway, the simbus description must be part of the stack.yaml loaded by the gateway. For the handling additional information must be set as follows:\nName Type Required Description spec object true none » models object true none »» annotations object false none »»» cli object false none »»»» step_size float64 false Simbus step size. Default 0.0005 »»»» end_time float64 false Simbus end size. Default 10min (36000), do not set if gateway end time is variable »»»» log_level int false Simbus log level. Default 6 (lower equals to more information) »»»» timeout float64 false Simbus timeout. Default 60 »» runtime object true none »»» files object true This part contains a list of yaml files that are to be loaded by the simbus --- kind: Stack metadata: name: gateway spec: models: - name: simbus model: name: simbus annotations: cli: step_size: 0.005 end_time: 0.02 log_level: 4 timeout: 600.0 runtime: files: - stack.yaml channels: - name: E2M_M2E expectedModelCount: 2 - name: com_phys expectedModelCount: 2 Gateway The gateway description requires additional information in the stack.yaml loaded by the gateway as follows:\nName Type Required Description spec object true none » models object true none »» annotations object false none »»» step_size float64 false Gateway step size. Default 0.0005 »»» end_time float64 false Gateway end size. Default 10min (36000), do not set if gateway end time is variable »»» log_level int false Gateway log level. Default 6 (lower equals to more information) »»» log_location string false Path to where the log files of the models have to be saved »»» cmd_envvars object false This part contains a list of environment variales that should be part of the fmi interface »» runtime object false none »»» env object false none »»»» GATEWAY_INIT_CMD string false path to the script/ cmd that is to be run before the simulation starts (in relation to the resource directory of the fmu) »»»» GATEWAY_SHUTDOWN_CMD string false path to the script/ cmd that is to be run after the simulation ends (in relation to the resource directory of the fmu) --- kind: Stack metadata: name: gateway spec: models: - name: gateway uid: 40004 model: name: Gateway annotations: step_size: 0.0050 end_time: 0.0200 log_level: 4 log_location: \"./here\" cmd_envvars: - envar0 - envar1 - envar2 runtime: env: # Gateway scripts. GATEWAY_INIT_CMD: \"init_cmd\" GATEWAY_SHUTDOWN_CMD: \"shutdown_cmd\" channels: - name: E2M_M2E alias: E2M_M2E selectors: channel: E2M_M2E - name: com_phys alias: com_phys selectors: channel: com_phys Session handling of models Models that should be handled (started \u0026 stopped) by the gateway are defined in an additional stack.yaml file that is referenced as described in this section. Additional information required is as follows:\nName Type Required Description spec object true none » runtime object false none »» env object false none »»» cli object false none » models object true none »» annotations object false none »»» timeout float64 false Timeout definition for all models »»»» step_size float64 false Model step size. Default 0.0005 »»»» end_time float64 false Model end size. Default 10min (36000), do not set if gateway end time is variable »»»» log_level int false Model log level. Default 6 (lower equals to more information) »»»» timeout float64 false Model timeout. Default 60 »»»» exe string false Model executable. This can be set in case the executable differs from the runtime modelc exe »» runtime object true none »»» files object true This part contains a list of yaml files that are to be loaded by the model --- kind: Stack metadata: name: stack_models spec: connection: transport: redispubsub: uri: redis://localhost:6379 timeout: 60 runtime: env: timeout: 600 models: - name: Model_1 uid: 42 model: name: Model_1 annotations: cli: step_size: 0.0005 end_time: 20.0 log_level: 1 timeout: 600.0 exe: \"different.exe\" runtime: files: - stack.yaml - model.yaml - signalgroup.yaml channels: - name: E2M_M2E alias: signal_channel selectors: model: Model_1 channel: signal_vector Examples Complete examples of stack.yaml and stack_models.yaml for the gateway and its session handling.\nComplete Example Stack.yaml --- kind: Stack metadata: name: gateway annotations: redis_show: true simbus_show: true models_show: true model_stack: stack_models.yaml spec: connection: transport: redispubsub: uri: redis://localhost:6379 timeout: 60 runtime: env: REDIS_EXE_PATH: redis.exe SIMBUS_EXE_PATH: simbus.exe MODELC_EXE_PATH: modelc.exe models: - name: simbus model: name: simbus annotations: cli: step_size: 0.005 end_time: 0.02 log_level: 4 timeout: 600.0 runtime: env: SIMBUS_LOGLEVEL: 6 files: - stack.yaml channels: - name: E2M_M2E expectedModelCount: 2 - name: com_phys expectedModelCount: 2 - name: gateway uid: 40004 model: name: Gateway annotations: step_size: 0.0050 end_time: 0.0200 log_level: 4 log_location: \"./here\" cmd_envvars: - envar0 - envar1 - envar2 runtime: env: # Gateway scripts. GATEWAY_INIT_CMD: \"init_cmd\" GATEWAY_SHUTDOWN_CMD: \"shutdown_cmd\" channels: - name: E2M_M2E alias: E2M_M2E selectors: channel: E2M_M2E - name: com_phys alias: com_phys selectors: channel: com_phys Complete Example Stack_models.yaml --- kind: Stack metadata: name: stack_models spec: connection: transport: redispubsub: uri: redis://localhost:6379 timeout: 60 models: - name: Model_1 uid: 42 model: name: Model_1 annotations: cli: step_size: 0.0005 end_time: 20.0 log_level: 1 timeout: 600.0 exe: \"different.exe\" runtime: files: - stack.yaml - model.yaml - signalgroup.yaml channels: - name: E2M_M2E alias: signal_channel selectors: model: Model_1 channel: signal_vector - name: Model_2 uid: 45 model: name: Model_2 runtime: files: - stack.yaml - model.yaml - signalgroup.yaml channels: - name: com_phys alias: signal_channel selectors: model: Model_2 channel: signal_vector Toolchains The required files for the FMI gateway can be generated using a toolchain included in the FMI GO tools. This operation with generate the required modelDescription.xml, model.yaml and fmu.yaml.\nName Required Description VERSION false Version of the Gateway FMU FMI_VERSION false FMI Version of the Gateway FMU (Default 2) STACK false stack.yaml file to be loaded by the gateway SIGNAL_GROUPS true List of yaml files to generate the required files for the Gateway FMU OUT_DIR false Path to the generated files UUID false UUID of the Gateway FMU $ task generate-fmigateway \\ VERSION=0.01 \\ FMI_VERSION=2 \\ STACK=stack.yaml \\ SIGNAL_GROUPS=\"extra/tools/fmi/test/testdata/fmigateway/SG1.yaml,extra/tools/fmi/test/testdata/fmigateway/SG2.yaml\" \\ OUT_DIR=./out \\ UUID=2f9f2b62-0718-4e66-8f40-6735e03d4c08 ","categories":"","description":"","excerpt":"Synposis FMI Gateway FMU\nSimulation Setup Structure Example Simulation …","ref":"/dse.doc/docs/user/models/fmi/fmigateway/","tags":["FMI","Gateway","Model"],"title":"FMI Gateway FMU"},{"body":"DSE FMI API Reference ","categories":"","description":"","excerpt":"DSE FMI API Reference ","ref":"/dse.doc/apis/fmi/","tags":"","title":"DSE FMI API Reference"},{"body":"DSE FMI Models ","categories":"","description":"","excerpt":"DSE FMI Models ","ref":"/dse.doc/docs/user/models/fmi/","tags":"","title":"FMI - FMI Models"},{"body":"Synposis FMI Model Compatibility Library\nSimulation Setup Structure Example Simulation Setup DOC: Provide description of FMI MCL Taskfile workflows.\nOperation Measurement The FMI MCL can be configured to produce an MDF measurement file for scalar signals of the FMUs interface, including FMI Variables with ’local’ causality.\nNote: the path of the measurement file is relative to the simulation path (i.e. /sim/…).\n# Using Simer; enable measurement on the FMU represented by 'fmu_inst'. $ simer path/to/simulation \\ -env fmu_inst:MEASUREMENT_FILE=/sim/fmu_measurement.mf4 \\ -stepsize 0.0005 -endtime 0.005 $ ls path/to/simulation/fmu_measurement.mf4 path/to/simulation/fmu_measurement.mf4 ","categories":"","description":"","excerpt":"Synposis FMI Model Compatibility Library\nSimulation Setup Structure …","ref":"/dse.doc/docs/user/models/fmi/fmimcl/","tags":["FMI","MCL","Model"],"title":"FMI Model Compatibility Library"},{"body":"ModelC Testing Methods ","categories":"","description":"","excerpt":"ModelC Testing Methods ","ref":"/dse.doc/docs/devel/testing/","tags":"","title":"Testing Methods"},{"body":"Synposis FMI ModelC FMU\nSimulation Setup Structure Example Simulation FMU Setup DOC: Provide description of FMI ModelC FMU Taskfile workflows.\nFMU Operation DOC: Operation.\n","categories":"","description":"","excerpt":"Synposis FMI ModelC FMU\nSimulation Setup Structure Example Simulation …","ref":"/dse.doc/docs/user/models/fmi/fmimodelc/","tags":["FMI","ModelC","Model"],"title":"FMI ModelC FMU"},{"body":"Tool Specific Environment Variables ModelC Variable CLI Option Default NCODEC_TRACE_LOG N/A None NCODEC_TRACE_{bus}_{bus_id} N/A None NCODEC_TRACE_PDU_{swc_id} N/A None SIMBUS_LOGLEVEL --logger 4 (LOG_NOTICE) SIMBUS_TRANSPORT --transport redispubsub SIMBUS_URI --uri redis://localhost:6379 SIMBUS_TIMEOUT --timeout 60 (seconds) SimBus Variable CLI Option Default SIMBUS_LOGLEVEL --logger 4 (LOG_NOTICE) SIMBUS_TRACEFILE N/A None (trace disabled, path to trace file) SIMBUS_TRANSPORT --transport redispubsub SIMBUS_URI --uri redis://localhost:6379 SIMBUS_TIMEOUT --timeout 60 (seconds) Examples Benchmark Variable CLI Option Default MODEL_ID N/A 1 SIGNAL_CHANGE N/A 5 STARTUP_ANNO N/A 1 STARTUP_IDX N/A 1 TAG N/A None (a log prefix, configure as a string) Block Variable CLI Option Default MODEL_COUNT N/A 1 MODEL_ID N/A 1 CSV Variable CLI Option Default CSV_FILE N/A None (path to CSV file) ","categories":"","description":"","excerpt":"Tool Specific Environment Variables ModelC Variable CLI Option Default …","ref":"/dse.doc/docs/user/envars/modelc/","tags":["Envar"],"title":"ModelC Environment Variables"},{"body":"Network Codec The Model C Library integrates the DSE Network Codec implementation of the Automotive Bus schemas.\nConfiguration of Binary Signals IMPORTANT: It is recommended to specify a SignalGroup for each individual Model Instance in a Simulation. This is so that the MIMEtype of each Binary Signal can be completely configured (especially bus_id,node_id and interface_id). Models may implement supplemental configuration options (such as annotations on the Model Instance definition) which can further adjust or augment the MIMEtype parameters.\nBinary signals are configured with a MIME Type. The Signal Vector integration with the Network Codec will automatically open codec objects for each supported MIME Type that is supported (by the codec). Additional configuration of the codec objects can be done with the ncodec_config() API function.\nkind: SignalGroup metadata: name: network labels: channel: network_vector annotations: vector_type: binary spec: signals: - signal: can_bus annotations: mime_type: application/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=2; interface_id=3 - signal: pdu_exc annotations: mime_type: application/x-automotive-bus; interface=stream; type=pdu; schema=fbs; swc_id=4; ecu_id=5 Additional configuration information is available here. Especially the behaviour of bus_id,node_id, interface_id, swc_id and ecu_id configuration items are described.\nConfiguration items can also be set at runtime with the ncodec_config() API as the following example shows:\n#include \u003cstring.h\u003e #include \u003cdse/logger.h\u003e #include \u003cdse/modelc/model.h\u003e #include \u003cdse/ncodec/codec.h\u003e #include \u003cdse/ncodec/interface/frame.h\u003e void configure_codec(ModelDesc* m, SignalVector* sv, uint32_t idx) { NCODEC* nc = sv-\u003evtable.codec(sv, idx); const char* node_id = NULL; for (int i = 0; i \u003e= 0; i++) { NCodecConfigItem nci = ncodec_stat(nc, \u0026i); if (strcmp(nci.name, \"node_id\") == 0) { node_id = nci.value; break; } } if (node_id == NULL) { node_id = model_instance_annotation(m, \"node_id\"); if (node_id == NULL) log_fatal(\"No node_id configuration found!\"); ncodec_config(nc, (struct NCodecConfigItem){ .name = \"node_id\", .value = node_id, }); } } NCodec Logging NCodec logging is enabled by setting the environment variable NCODEC_TRACE_LOG (to any value).\nTracing NCodec Frames The ModelC runtime can enable tracing for selected (or all) frames being sent or received by a Model Instance. This tracing is enabled via environment variables.\nExample Trace for CAN For the Binary Signal described by the following MIMEtype:\napplication/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=2; interface_id=3 The ModelC command would be (setting the environment variable directly):\nNCODEC_TRACE_CAN_1=0x3ea,0x3eb modelc --name=ncodec_inst ... or\nNCODEC_TRACE_CAN_1=* modelc --name=ncodec_inst ... Example Trace for PDU For the Binary Signal described by the following MIMEtype:\napplication/x-automotive-bus; interface=stream; type=pdu; schema=fbs; swc_id=4; ecu_id=5 The ModelC command would be (setting the environment variable directly):\nNCODEC_TRACE_PDU_4=0x3ea,0x3eb modelc --name=ncodec_inst ... or\nNCODEC_TRACE_PDU_4=* modelc --name=ncodec_inst ... Usage in Model Code The Network Codec integration is fairly easy to use. The general approach is as follows:\n#include \u003cdse/modelc/model.h\u003e #include \u003cdse/ncodec/codec.h\u003e #include \u003cdse/ncodec/interface/frame.h\u003e extern int put_rx_frame_to_queue(uint32_t, uint8_t*, size_t); extern int get_tx_frame_from_queue(uint32_t*, uint8_t**, size_t*); typedef struct { ModelDesc model; NCODEC* nc; } ExtendedModelDesc; int model_step(ModelDesc* model, double* model_time, double stop_time) { ExtendedModelDesc* m = (ExtendedModelDesc*)model; NCodecCanMessage msg = {}; /* Message RX. */ while (1) { if (ncodec_read(m-\u003enc, \u0026msg) \u003c 0) break; put_rx_frame_to_queue(msg.frame_id, msg.buffer, msg.len); } /* Message TX. */ ncodec_truncate(m-\u003enc); /* Clear the codec buffer (i.e. Rx data). */ while (get_tx_frame_from_queue(\u0026msg.frame_id, \u0026msg.buffer, \u0026msg.len)) { ncodec_write(m-\u003enc, \u0026msg); } ncodec_flush(m-\u003enc); /* Progress the Model time. */ *model_time = stop_time; return 0; } For most use cases, the call sequence during a simulation step will be:\nncodec_seek() - Models typically do not call this method! This call sets up the Binary Signal for reading and will be called automatically by the ModelC runtime. ncodec_read() - Models call ncodec_read() to read messages. Repeat calls until the function returns -ENOMSG. ncodec_truncate() - Models call ncodec_truncate() to prepare the Binary Signal for writing. Mandatory, call even if not intending to write frames to the NCodec in the current simulation step. ncodec_write() - Models call ncodec_write() to write messages. Can be called several times. ncodec_flush() - Models call ncodec_flush() to copy the buffered writes to the Binary Signal. Typically called at the end of a simulation step, however ncodec_flush() can be called many times; each time its called the accrued content from prior calls to ncodec_write() are appended to the Binary Signal. Usage in Test Cases When developing Test Cases its possible to use an existing Network Codec object to send or receive messages with the objects owner (usually a model). This is particularly useful for testing messaging behaviour of a model under specific circumstances. When doing this its necessary to circumvent the node_id filtering of that codec, as the following example illustrates.\n#include \u003cdse/testing.h\u003e #include \u003cdse/modelc/runtime.h\u003e #include \u003cdse/ncodec/codec.h\u003e #include \u003cdse/ncodec/interface/frame.h\u003e typedef struct ModelCMock { SimulationSpec sim; ModelInstanceSpec* mi; } ModelCMock; char* get_ncodec_node_id(NCODEC* nc) { assert_non_null(nc); int index = 0; const char* node_id = NULL; while (index \u003e= 0) { NCodecConfigItem ci = ncodec_stat(nc, \u0026index); if (strcmp(ci.name, \"node_id\") == 0) { node_id = ci.value; break; } index++; } if (node_id) return strdup(node_id); return NULL; } void set_ncodec_node_id(NCODEC* nc, const char* node_id) { assert_non_null(nc); ncodec_config(nc, (struct NCodecConfigItem){ .name = \"node_id\", .value = node_id, }); } void test_message_sequence(void** state) { ModelCMock* mock = *state; SignalVector* sv = mock-\u003emi-\u003emodel_desc-\u003esv; NCODEC* nc = sv-\u003evtable.codec(sv, 2); const char* buffer = \"hello world\"; // ... // Modify the node_id. char* node_id_save = get_ncodec_node_id(nc); set_ncodec_node_id(nc, \"42\"); // Send a message (which will not be filtered). ncodec_write(nc, \u0026(struct NCodecCanMessage){ .frame_id = 42, .buffer = (uint8_t*)buffer, .len = strlen(buffer), }); ncodec_flush(nc); // Restore the existing node_id. set_ncodec_node_id(nc, node_id_save); free(node_id_save); // ... } Build Integration The Network Codec integration repackages the necessary include files with the Model C Library packages. No additional build integration is required. A typical CMake configuration might look like this:\nFetchContent_Declare(dse_modelc_lib URL ${MODELC_LIB__URL} SOURCE_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.modelc.lib\" ) FetchContent_MakeAvailable(dse_modelc_lib) set(DSE_MODELC_INCLUDE_DIR \"${dse_modelc_lib_SOURCE_DIR}/include\") # ... dynamic linked Model (ModelC.exe provides objects) ... target_include_directories(some_target PRIVATE ${DSE_MODELC_INCLUDE_DIR} ../.. ) # ... static linked target (typical CMocka test application) ... set(MODELC_BINARY_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.modelc.lib\") find_library(MODELC_LIB NAMES libmodelc_bundled.a PATHS ${MODELC_BINARY_DIR}/lib REQUIRED NO_DEFAULT_PATH ) add_library(modelc STATIC IMPORTED GLOBAL) set_target_properties(modelc PROPERTIES IMPORTED_LOCATION \"${MODELC_LIB}\" INTERFACE_INCLUDE_DIRECTORIES \"${MODELC_BINARY_DIR}\" ) set(DSE_MODELC_LIB_INCLUDE_DIR \"${MODELC_BINARY_DIR}/include\") add_executable(test_mstep mstep/__test__.c mstep/test_mstep.c ) target_include_directories(test_mstep PRIVATE ${DSE_MODELC_LIB_INCLUDE_DIR} ./ ) target_link_libraries(test_mstep PUBLIC -Wl,-Bstatic modelc -Wl,-Bdynamic ${CMAKE_DL_LIBS} PRIVATE cmocka dl m ) ","categories":"","description":"","excerpt":"Network Codec The Model C Library integrates the DSE Network Codec …","ref":"/dse.doc/docs/devel/ncodec/","tags":["Developer","ModelC","NCodec","Codec"],"title":"Model C with Network Codec"},{"body":"Container Specific Environment Variables Tool Specific Variable Default SIMER_IMAGE ghcr.io/boschglobal/dse-simer:latest BUILDER_IMAGE ghcr.io/boschglobal/dse-builder:latest REPORT_IMAGE ghcr.io/boschglobal/dse-report:latest Workflow Specific Variable Default FMI_IMAGE ghcr.io/boschglobal/dse-fmi FMI_TAG latest Note: this pattern of IMAGE and TAG is repeated for all repos which contain workflows.\n","categories":"","description":"","excerpt":"Container Specific Environment Variables Tool Specific Variable …","ref":"/dse.doc/docs/user/envars/sdp/","tags":["Envar"],"title":"SDP Environment Variables"},{"body":"DSE Network API Reference ","categories":"","description":"","excerpt":"DSE Network API Reference ","ref":"/dse.doc/apis/network/","tags":"","title":"DSE Network API Reference"},{"body":"Synposis Network Model of a Communication Stack representing the connection between Physical Signals and Network Messages.\n# Build a network model. $ cd path/to/simulation; $ task generate \\ DBCFILE=networks/can_1/can_1.dbc \\ SIGNAL=can_1 \\ MIMETYPE=\"application/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=1; interface_id=0\" $ cd - # Run the simulation. $ simer path/to/simulation -stepsize 0.0005 -endtime 0.04 Simulation Setup Structure Network Example Simulation # Example Source Code: L- dse/network/examples/brake-by-wire L- simulation.yaml Stack definitions. L- model.yaml Model definitions. L- brake/ Brake model source code. L- driver/ Driver model source code. L- network/ L- brake/brake.dbc Brake network definition. L- vehicle/vehicle.dbc Vehicle network definition. L- pedal/ Pedal model source code. L- safety/ Safety model source code. L- CMakeLists.txt Build script. # Packaged Simulation: L- dse/network/build/_out/examples/brake-by-wire \u003c== simulation path L- simulation.yaml Simulation definition. L- models L- brake Brake model. L- driver Driver model. L- network L- data/model.yaml Network model definition (common to all networks). L- lib/network.so Network model library (common to all networks). L- pedal Pedal model. L- safety Safety model. L- networks L- brake L- brake.dbc Brake network definition. L- model.yaml Model definition. L- network.yaml Network definition. L- signalgroup.yaml Signal definitions. L- message.so Network network library. L- vehicle L- vehicle.dbc Vehicle network definition. L- model.yaml Model definition. L- network.yaml Network definition. L- signalgroup.yaml Signal definitions. L- message.so Vehicle network library. Network Setup CAN DBC Conversion DOC: Provide description of network Taskfile workflows.\nNetwork Functions DOC: Provide description of network functions.\nNetwork Codec DOC: Provide description of network codec configuration.\nNetwork Operation Network Tracing Network messages can be traced by setting environment variables for a specific model.\n# Trace for the MIMEtype: # application/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=2; interface_id=3 # bus=CAN # bus_id=1 # Trace individual frames: $ simer path/to/simulation \\ -env network_inst:NCODEC_TRACE_CAN_1=0x3ea,0x3eb \\ -stepsize 0.0005 -endtime 0.04 # Trace all frames: $ simer path/to/simulation \\ -env network_inst:NCODEC_TRACE_CAN_1=* \\ -stepsize 0.0005 -endtime 0.04 ","categories":"","description":"","excerpt":"Synposis Network Model of a Communication Stack representing the …","ref":"/dse.doc/docs/user/network/","tags":["Network","Model"],"title":"Network - Network Model"},{"body":"Overview The following Simulation Framework Benchmarks give an understanding of how the Dynamic Simulation Environment performs for a variety of simulation topologies. This information can be used to decide on a deployment strategy for a simulation that takes into account:\nThe total number of signals in a simulation. How many models are configured in a simulation. The expected amount of signal exchange per simulation step (throughput). Each of these benchmarks are evaluated across a subset of recommended simulation topologies. These topologies include:\nModel Runtime - Stacked model instance (single process) / Loopback SimBus Stacked w. Redis - Stacked model instance (single process) / Redis SimBus Distributed w. Redis - Distributed model instances (process per model) / Redis SimBus All benchmark simulations are executed using the Simer docker appliance with a Co-Simulation step size of 0.5mS. Each simulation runs for 1 “simulation” minute (i.e. a total of 2000 simulation steps).\nBenchmark (Core i7-1370P) Host system is a ThinkPad T16 G2 (Intel Core i7-1370P, 1900 Mhz, 14 Core, 32 GB Memory) with Linux running in WSL2. All binaries are compiled for amd64 architecture with optimization -03. Values are presented relative to realtime operation.\nSignal Count Variable Value SIGNAL_COUNT Increasing range (count = 1000 * 2^N for N=0,1,2,3,4,5) SIGNAL_CHANGE Constant at 200 signals per simulation step, distributed evenly over all models MODEL_COUNT Constant at 5 Signal Throughput Variable Value SIGNAL_COUNT Constant at 4000 SIGNAL_CHANGE Increasing range (change per model = 25 50 100 200 400 800**), distributed evenly over all models MODEL_COUNT Constant at 5 Note: **Represents saturation with 4000 signal changes per simulation step.\nModel Count Variable Value SIGNAL_COUNT Constant at 4000 SIGNAL_CHANGE Constant at 400, distributed evenly over all models MODEL_COUNT Increasing range (count = 1 2 3 4 6 8 12 16) Benchmark (Codespace 4 vCPU) Host system is a Codespace 4 core virtual machine. Reports CPU as Xeon Platinum 8370C (Intel(R) Xeon(R) Platinum 8370C CPU, 2.80GHz, 4 Core, 16 GB Memory) with Linux. All binaries are compiled for amd64 architecture with optimization -03. Values are presented relative to realtime operation.\nSignal Count Variable Value SIGNAL_COUNT Increasing range (count = 1000 * 2^N for N=0,1,2,3,4,5) SIGNAL_CHANGE Constant at 200 signals per simulation step, distributed evenly over all models MODEL_COUNT Constant at 5 Signal Throughput Variable Value SIGNAL_COUNT Constant at 4000 SIGNAL_CHANGE Increasing range (change per model = 25 50 100 200 400 800**), distributed evenly over all models MODEL_COUNT Constant at 5 Note: **Represents saturation with 4000 signal changes per simulation step.\nModel Count Variable Value SIGNAL_COUNT Constant at 4000 SIGNAL_CHANGE Constant at 400, distributed evenly over all models MODEL_COUNT Increasing range (count = 1 2 3 4 …) ","categories":"","description":"","excerpt":"Overview The following Simulation Framework Benchmarks give an …","ref":"/dse.doc/docs/arch/benchmark/","tags":["Architecture","ModelC","Simer"],"title":"Simulation Framework Benchmark"},{"body":"Overview The Dynamic Simulation Environment provides several simulation topologies, all of which support distributed simulations, that may incorporate models running on multiple OS/Arch combinations or running in multiple simulation environments.\nThese topologies include:\nStandalone - Stacked model instances running in a single process. Uses a Loopback SimBus. Distributed - Distributed model instances, multi process, multi OS, optionally stacked. Uses a Redis SimBus. Gateway - Remote simulation systems are connected with a gateway model. Uses a Redis SimBus. MCL - Foreign models are imported via a Model Compatibility Library. Realtime - Stacked model instances which may operate either Standalone or Distributed (i.e. Loopback or Redis based SimBus). Embedded - External models and sensors and connected with a POP model / TCP These topologies are supported by the Simer docker appliance (Linux) and ModelC runtime (Linux/Windows). The underlying messaging protocol used by the Dynamic Simulation Environment is implemented with Flatbuffers and may be implemented in any programming language or operating system.\nStandalone Several Models are stacked in a single model runtime. For example, the runtime may be packaged as an FMU using the FMI ModelC FMU wrapper.\nStacked w. Loopback Characteristics:\nSingle Process - Sequential execution of models within a single process using the ModelC model runtime. Performance limited by CPU clock speed. Co-Simulation - Phase shift for signal exchange between model steps (i.e. output to input). Phase shift is equal to one simulation step. Loopback SimBus - Low latency execution with no external/network signal exchange. Limited deployment - Use of Loopback SimBus means that only single process deployment is possible. Note: Models may be stacked in any deployment topology (i.e. with Redis).\nSequence Diagram @startuml topology-standalone-stacked title \"Standalone - Stacked Models with Loopback\\n\" box \"Model Runtime\" #LightSteelBlue participant Loopback as l control Controller as c participant Model as m1 participant Model as m2 participant Model as m3 loop CoSim Step l -\u003e c : step(signals) activate c c -\u003e m1 : step(signals) activate m1 #gold return result(signals') c -\u003e m2 : step(signals) activate m2 #gold return result(signals') c -\u003e m3 : step(signals) activate m3 #gold return result(signals') return result(signals'') hnote over l,c : Signals'' is combined\\n result from all models. end end box center footer Dynamic Simulation Environment - ModelC @enduml Configuration CLI / Environment Variable CLI Option (ModelC/Simer) Value SIMBUS_TRANSPORT --transport loopback SIMBUS_URI --uri loopback Simulation Stack simulation.yaml --- kind: Stack spec: connection: transport: loopback: uri: loopback runtime: stacked: true Stacked Sequential Co-Sim Characteristics:\nSingle Process - Sequential execution of models within a single process using the ModelC model runtime. Performance limited by CPU clock speed. Co-Simulation - Sequential Co-Simulation resulting in no phase shift of scalar signals exchanged between models in the stack. Limited deployment - Used to compose models from several “component” models where the resultant model does not exhibit phase shift between its input and output scalar signals for any simulation step. Sequence Diagram @startuml topology-standalone-sequential title \"Standalone - Stacked Sequential Co-Sim\\n\" box \"Model Runtime\" #LightSteelBlue participant Loopback as l control Controller as c participant Model as m1 participant Model as m2 participant Model as m3 loop CoSim Step l -\u003e c : step(signals) activate c c -\u003e m1 : step(signals) activate m1 #gold m1 -\u003e m2 : step(signals') deactivate activate m2 #gold m2 --\u003e m3 : result(signals'') deactivate activate m3 #gold m3 --\u003e c : result(signals'') deactivate return result(signals'') end end box center footer Dynamic Simulation Environment - ModelC @enduml Configuration CLI / Environment Variable CLI Option (ModelC/Simer) Value SIMBUS_TRANSPORT --transport loopback SIMBUS_URI --uri loopback Simulation Stack simulation.yaml --- kind: Stack spec: connection: transport: loopback: uri: loopback runtime: stacked: true sequential: true Distributed Models are distributed in several instances of a model runtime. Model runtimes may run on several computers, use different operating systems, and execute in other Simulation Environments. Models can also be stacked, and those stacks can be configured to operate in Sequential Co-Sim mode.\nDistributed w. Redis Characteristics:\nMulti Process - Parallel execution of models using a Simer/ModelC model runtime. Performance limited by number of CPU Cores and Processing Nodes (e.g. VMs/Workstations). Co-Simulation - Phase shift for signal exchange between model steps (i.e. output to input). Phase shift is equal to one simulation step. Redis w. SimBus - Low latency signal exchange when running with a Simer deployment, medium latency when operating cross-platform simulation (latency depends on network performance). Flexible deployment - The Simer Container Runtime can be used for high performance, scaled, Linux deployments. The underlying model runtime ModelC is available for Windows deployments. Both can be combined to create distributed simulations. Sequence Diagram @startuml topology-distributed-redis !pragma teoz true title \"Distributed Simulation w. Redis\\n\" box \"Model Runtime (Simer/Linux)\" #LightSteelBlue participant Model as m0 control Controller as c0 box \"SimBus\" participant SimBus as s participant Redis as r end box end box box \"Model Runtime (Windows)\" #LightSteelBlue control Controller as c1 participant Model as m1 participant Model as m2 end box group Co-Sim Step s o-[#Blue]-\u003e r : step(signals) r -[#Blue]-\u003e c0 : step(signals) activate c0 r -[#Blue]-\u003e c1 : step(signals) activate c1 c0 -\u003e m0 : step(signals) activate m0 #gold group Sequential Co-Sim c1 -\u003e m1 : step(signals) activate m1 #gold m1 -\u003e m2 : step(signals') deactivate m1 activate m2 #gold m2 --\u003e c1 : result(signals'') deactivate m2 end c1 -[#Blue]-\u003e r : result(signals'') deactivate c1 m0 --\u003e c0 : result(signals''') deactivate m0 c0 -[#Blue]-\u003e r : result(signals''') deactivate c0 r -[#Blue]-\u003eo s : result(signals'') r -[#Blue]-\u003eo s : result(signals''') end center footer Dynamic Simulation Environment - ModelC @enduml Configuration CLI / Environment Variable CLI Option (ModelC/Simer) Value SIMBUS_TRANSPORT --transport redis SIMBUS_URI --uri redis://localhost:6379 Note: There are several variations of Redis transports, redispubsub being the most common (and original). The newer redis transport has the best performance and is suggested for new simulation projects.\nSimulation Stack simulation.yaml --- kind: Stack spec: connection: transport: redis: uri: redis://localhost:6379 Gateway Remote Simulations are connected to a DSE/Simer based Simulation using a Gateway Model. The Gateway Model is implemented in the Remote Simulations framework/environment which then connects to the DSE/Simer Simulation. The connection may be established with either an existing integration (i.e. the DSE ModelC Library), or a direct implementation of the underlying DSE messaging protocols.\nModelC based Gateway Sequence Diagram @startuml topology-gateway-modelc !pragma teoz true title \"Distributed Simulation w. Redis\\n\" box \"Model Runtime (Simer/Linux)\" #LightSteelBlue participant Model as m1 participant Model as m2 control Controller as c0 box \"SimBus\" participant SimBus as s participant Redis as r end box end box box \"Remote Simulation (Windows)\" #LightSteelBlue participant Gateway as g1 control Controller as c1 participant Model as m3 end box group Co-Sim Step activate c1 s o-[#Blue]-\u003e r : step(signals) r -[#Blue]-\u003e c0 : step(signals) activate c0 c0 -\u003e m2 : step(signals) activate m2 #gold c1 -\u003e g1 : step(signals) activate g1 #gold r -[#Green]-\u003e g1 : step(signals) m2 --\u003e c0 : result(signals) deactivate m2 g1 -[#Green]-\u003e r : result(signals) g1 --\u003e c1 : result(signals) deactivate g1 c0 -\u003e m1 : step(signals) activate m1 #gold c1 -\u003e m3 : step(signals) activate m3 #gold r -[#Green]-\u003eo s : result(signals) m1 --\u003e c0 : result(signals) deactivate m1 m3 --\u003e c1 : result(signals) deactivate m3 c0 -[#Blue]-\u003e r : result(signals) deactivate c0 r -[#Blue]-\u003eo s : result(signals) deactivate c1 hnote over c0,g1 : Synchronization end center footer Dynamic Simulation Environment - ModelC @enduml MCL Foreign models are imported to a simulation using a Model Compatibility Library which may be implemented for any model standard (e.g. FMI MCL).\nRealtime A simulation is deployed in a realtime simulation environment (e.g. HIL) with a combination of distributed and stacked model instances, using a Redis based SimBus, to ensure consistent realtime operation.\nEmbedded External models, sensors and ECUs are connected via native protocols (e.g. TCP) to a Point-of-Presence model running within a Simer based simulation.\n","categories":"","description":"","excerpt":"Overview The Dynamic Simulation Environment provides several …","ref":"/dse.doc/docs/arch/topology/","tags":["Architecture","ModelC","Simer"],"title":"Simulation Topology"},{"body":"Overview A Simulation Transport specifies how data-exchange between Models is facilitated by a simulation environment. Each transport has its own specific properties and the selection of a transport will be determined by the planned operational deployment of a simulation.\nTransport Latency Status Loopback Fastest Available, stacked simulations (single process). TCP Fastest Planned. Redis Faster Recommended. Redis PubSub Fast Available, stable. RESP Fast Under consideration, for cloud connectivity (tunnelling). gPPC Fast Under consideration, for cloud connectivity (HTTP). Redis Async Slower Available, experimental. MsgQueue Slowest Discontinued, poor performance at scale. Usage A simulation transport can be specified in a number of ways, however typically a transport will be configured in a Stack Configuration (YAML) or via an Environment Variable.\nStack Configuration Example Simulation Stack simulation.yaml --- kind: Stack metadata: name: example spec: connection: transport: redis: uri: redis://localhost:6379 timeout: 60 Environment Variables Variable CLI Option (ModelC/Simer) Default SIMBUS_TRANSPORT --transport redispubsub SIMBUS_URI --uri redis://localhost:6379 N/A --timeout 60 (seconds) Note: Simer parameters have only a single - prefix (i.e. -transport). Environment variables can be specified with the -env parameter.\nTransports Loopback @startuml transport-loopback skinparam nodesep 55 skinparam ranksep 40 skinparam componentStyle rectangle skinparam FrameBorderColor #c0c0c0 skinparam FrameFontColor #c0c0c0 skinparam FrameFontStyle italic frame \"Stack (single process)\" { component \"Model\" as m1 component \"Model\" as m2 interface \"Loopback\" as SBif m1 -left-\u003e SBif m2 -right-\u003e SBif } @enduml The loopback transport implements a limited SimBus algorithm which makes it possible to run a model, or a stack of models, without connecting to a SimBus. Because the messaging associated with connecting to a SimBus is removed (or internalised) by the loopback, this is the fastest transport available when building simulations, however it is only suitable for particular deployment scenarios and when developing models.\nNote: The loopback transport is only suitable for stacked simulations (i.e. models are arranged within single process).\nConfiguration Parameters Parameter Example transport (name) loopback uri loopback timeout (seconds) 60 Redis @startuml transport-redis skinparam nodesep 55 skinparam ranksep 40 skinparam componentStyle rectangle component \"Model\" as m1 component \"Model\" as m2 component \"SimBus\" as sb interface \"Redis\" as red m1 -left-\u003e red m2 -right-\u003e red sb \u003c-down-\u003e red @enduml The redis transport is recommended for connecting models in a simulation. It uses blocking Redis commands and simple data types to implement a message exchange mechanism.\nConfiguration Parameters Parameter Example transport (name) redis uri redis://localhost:6379 timeout (seconds) 60 Redis Async @startuml transport-redisasync skinparam nodesep 55 skinparam ranksep 40 skinparam componentStyle rectangle component \"Model\" as m1 component \"Model\" as m2 component \"SimBus\" as sb interface \"Redis Async\" as red m1 -left-\u003e red m2 -right-\u003e red sb \u003c-down-\u003e red @enduml An experimental transport which uses and asynchronous Redis library. The performance was slower than expected; its still fast, however the redis transport is faster; and development has stopped.\nConfiguration Parameters Parameter Example transport (name) redis uri redisasync://localhost:6379 timeout (seconds) 60 Redis PUB/SUB @startuml transport-redispubsub skinparam nodesep 55 skinparam ranksep 40 skinparam componentStyle rectangle component \"Model\" as m1 component \"Model\" as m2 component \"SimBus\" as sb interface \"Redis PubSub\" as red m1 -left-\u003e red m2 -right-\u003e red sb \u003c-down-\u003e red @enduml The redispubsub transport is the original, and reference, implementaion. Migration to the newer redis transport is recommended.\nNote: In some deployment scenarios, particularly clould environments, the redispubsub transport might not work. In such cases the newer redis transport will operate correctly.\nConfiguration Parameters Parameter Example transport (name) redispubsub uri redis://localhost:6379 timeout (seconds) 60 ","categories":"","description":"","excerpt":"Overview A Simulation Transport specifies how data-exchange between …","ref":"/dse.doc/docs/arch/transport/","tags":["ModelC","Architecture","SimBus","Simer"],"title":"Simulation Transports"},{"body":"Synopsis The Model Compatibility Library (MCL) of the Dynamic Simulation Environment (DSE) is a representation of an Architectural Pattern for supporting 3rd-party model interfaces in a DSE Simulation. To support a model interface an implementation will need to implement the MCL API (i.e. MclVTable) and may also optionally use the Marshal API to manage signal/variable exchange with the model being interfaced.\nDesign Deployment Configuration References MCL API Marshal API FMI MCL - An MCL implementation for the Modelica FMI Standard. ","categories":"","description":"","excerpt":"Synopsis The Model Compatibility Library (MCL) of the Dynamic …","ref":"/dse.doc/docs/arch/mcl/","tags":["ModelC","Architecture","MCL"],"title":"Model Compatibility Library"},{"body":"Synopsis The Dynamic Simulation Environment (DSE) presents models with a simple vector interface for the exchange of signals. Those signals can be either:\nscalar : Internally represented as a 64bit storage container (double). These values are transparently exchanged between models. Models may cast/convert these scalar values to other types as required. binary : Binary strings, which may container embedded NULL values, can be exchanged between models. Additionally a binary signal may be annotated with a MIME type which describes the content of a binary signal. Tip Binary signals with an associated MIME type may be supported by a Network Codec which has an API that simplifies interactions with binary data and can be used to realise network simulations (e.g. CAN bus messaging). Scalar Signal Vector Scalar signal vectors are used by models to exchange signal values. Those values of a scalar signal vector are represented internally as 64bit storage container (double), and they are transparently exchanged between models. Models can cast these values to any scalar data type as required.\nTip When casting scalar values, use a signal annotation to describe the type cast which should be used. That way, simulation integrators and other model developers will be aware of how the signal value should be interpreted. API Methods /* Access signal annotations. */ const char* value = sv-\u003eannotation(sv, i, \"name\"); Configuration Scalar signal vectors are represented by a SignalGroup YAML document. Individual signals may have additional annotations which can be used to describe the behaviour or properties of the signal - those annotations may be interpreted by a model which uses those signals.\nScalar Signal Vector :\nkind: SignalGroup metadata: name: scalar spec: signals: - signal: foo - signal: bar annotations: type-cast: int32 Binary Signal Vector Binary signal vectors are used by models to exchange binary data, the effect of which is to create binary data streams between models. When associated with a MIME type, complex communication protocols can be realised (e.g. CAN Bus simulation). When several models exchange binary data values for the same signal, each of those values will be consolidated into a single value which represents a binary stream, and that consolidated value is exchanged between all models.\nBecause the binary signals may represent variable length data objects, there are a collection of API Methods available to reliably interface with this vector type.\nAPI Methods /* Work with a binary signal. */ sv-\u003ereset(sv, i); /* Reset the binary signal (i.e. length = 0). */ sv-\u003eappend(sv, i, data, length); /* Append data to the signal. */ sv-\u003erelease(sv, i); /* Free the memory buffer of a binary signal. */ /* Access signal annotations. */ const char* value = sv-\u003eannotation(sv, i, \"name\"); Tip Using a Network Codec simplifies operations with binary signals. Configuration Binary signal vectors are represented by a SignalGroup YAML document with a metadata annotation vector_type: binary. Each signal of a binary signal vector should also have an annotation mime_type which describes the binary data. The default value provided by the Signal Vector API is application/octet-stream (which, from a system integration perspective, is almost totally useless).\nIndividual signals may have additional annotations which can be used to describe the behaviour or properties of the signal - those annotations may be interpreted by a model which uses those signals.\nBinary Signal Vector :\nkind: SignalGroup metadata: name: binary annotations: vector_type: binary spec: signals: - signal: foo annotations: mime_type: 'application/octet-stream; interface=parameter; file=calibration.csv' - signal: bar annotations: mime_type: 'application/x-automotive-bus; interface=stream; type=frame; schema=fbs' Transformations A scalar signal may be associated with a transformation by the transform node located alongside the signal node in a SignalGroup definition. The following transformations are supported:\nTransform Description linear S~model~ = S~vector~ * factor + offset When signals are set by a model, all defined transformations are applied in the reverse direction before those signal values are exchanged with other models in a simulation. Therefore a transformed signal value is only observable by a model which is associated with such a signal definition.\nConfiguration Transformations are configured for individual signals in a SignalGroup YAML document.\nScalar Signal Vector with Transformations :\nkind: SignalGroup metadata: name: scalar spec: signals: - signal: foo - signal: bar transform: linear: factor: 20 offset: -100 API Examples Using the Model API (definied in dse/modelc/model.h)\nSignal vectors are located on the ModelDesc object (model-\u003esv) as a NTL (Null terminated list) and can be indexed with the model-\u003eindex function of the same object.\nint model_step(ModelDesc* model, double* model_time, double stop_time) { // Find a signal using the index method. ModelSignalIndex counter = model-\u003eindex(m, \"data\", \"counter\"); if (counter.scalar == NULL) return -EINVAL; *(counter.scalar) += 1; // Find a signal vector using the index method. ModelSignalIndex data_sv = model-\u003eindex(m, \"data\", NULL); if (data_sv.sv == NULL) return -EINVAL; ... } Using the Runtime API (definied in dse/modelc/runtime.h)\nThe Runtime API can be used to access signal vectors and is of particular use to tool developers and integrators who need access to runtime objects.\n#include \u003cdse/modelc/model.h\u003e int model_function(ModelInstanceSpec* mi) { SignalVector* sv = model_sv_create(mi); while (sv \u0026\u0026 sv-\u003ename) { for (uint i = 0; i++; i \u003c sv-\u003ecount) { if (sv-\u003eis_binary) { sv-\u003ereset(sv, i); sv-\u003eappend(sv, i, \"hello world\", 12); printf(\"%s = %f (%s)\\n\", sv-\u003esignal[i], sv-\u003ebinary[i], sv-\u003emime_type[i]); } else { printf(\"%s = %f\\n\", sv-\u003esignal[i], sv-\u003escalar[i]); } } /* Next signal vector. */ sv++; } } References dse/modelc/model.h - definition of Signal Vector API. SignalGroup schema definition. DSE Model C examples: Binary Model NCodec Model Transform Model Binary Codecs: Network Codec from DSE Model C which implements a stream interface to the Network Codec API by using binary signals and associated MIME type annotations. Network Codec API generalised codec library with an example binary stream implementation. ","categories":"","description":"","excerpt":"Synopsis The Dynamic Simulation Environment (DSE) presents models with …","ref":"/dse.doc/docs/arch/signalvector/","tags":["ModelC","Architecture"],"title":"Signal Vectors"},{"body":"Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway API which can be used to connect remote simulations, via a gateway model, to a running DSE simulation. A gateway model takes care of signal exchange and time synchronisation between the remote simulation and the DSE simulation. Signals can be either scalar values or binary strings, the latter enabling virtual bus connections between simulation environments.\nThe gateway model runs in the remote simulation, and is written in that systems native language (or modelling construct). Connections from the gateway model to the DSE simulation are implemented with platform independent protocols, the resultant distributed simulation may combine any number of operating systems and processor architectures.\n#include \u003cdse/modelc/gateway.h\u003e /* Setup the gateway. */ ModelGatewayDesc gw; model_gw_setup(\u0026gw, \"gateway\", yaml_files, LOG_INFO, step_size, end_time); /* Run the simulation. */ while (model_time \u003c= end_time) { marshal_signal_vectors_out(gw-\u003esv); int rc = model_gw_sync(\u0026gw, model_time); marshal_signal_vectors_in(gw-\u003esv); ... } /* Exit the simulation. */ model_gw_exit(\u0026gw); Design Deployment A generalised deployment showing how a remote simulation is connected to a DSE simulation using a gateway model. Each simulation has several models, synchronisation and signal exchange are achieved via the gateway model.\nGateway Model Deployment\nSequence Diagram The following diagram shows how a gateway model running in a remote simulation interacts with a DSE simulation.\nGateway Model Sequence Diagram\nReferences dse/modelc/gateway.h - Gateway API header file. dse/modelc/model/gateway.c - Gateway API implementation and documentation. dse/modelc/examples/gateway - Example gateway model. ","categories":"","description":"","excerpt":"Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway …","ref":"/dse.doc/docs/arch/gateway/","tags":["ModelC","Architecture"],"title":"Gateway Models"},{"body":"DSE Environment Variables ","categories":"","description":"","excerpt":"DSE Environment Variables ","ref":"/dse.doc/docs/user/envars/","tags":"","title":"Environment Variables"},{"body":"DSE Additional Tools ","categories":"","description":"","excerpt":"DSE Additional Tools ","ref":"/dse.doc/docs/user/tools/","tags":"","title":"Additional Tools"},{"body":" Dynamic Simulation Environment The Dynamic Simulation Environment is a message based distributed simulation platform which defines the interface between models as signal vectors. Signal vectors are a logical grouping of either scalar or binary data which are exchanged between models at discrete points in time. Models may be developed in any programming language and may run on any operating system or hardware platform.\nSimulations are constructed using models with a compositional approach, where system elements represented by the simulation are decomposed/recomposed from a collection of models according the broader simulation objectives. This compositional approach to simulation, called Functional Simulation (FSIL), supports the development of a variety of simulation strategies.\nThe Dynamic Simulation Environment (DSE) can be used to integrate legacy tools into a simulation, such integration techniques include; Gateway models which connect remote systems to a DSE simulation; and Model Compatibility Libraries which import foreign models into a DSE simulation. Several Gateway and Model Compatibility Libraries are available alongside the Model C Library, our C based implementation of the Dynamic Simulation Environment.\nMessages The Dynamic Simulation Environment uses a distributed algorithm, based upon a small set of messages, which facilitate control and execution of simulations. Using those messages (and the associated distributed algorithm) a variety of simulation capabilities can be realised, including: Co-simulation, Federated (distributed) simulations, Cross-Platform simulations.\nThe Messages of the Dynamic Simulation Environment are used to:\nProgress time in a Simulation: the synchronisation algorithm which drives the Dynamic Simulation Environment is implemented with 3 messages; two of which are used to implement the Co-simulation algorithm, and a third message which is used for event driven progression of time.\nFacilitate the exchange of Signals between Models: signal values are first delta encoded (i.e. only changed values), and then embedded as a payload within messages. These messages are then exchanged with, and processed by, a Simulation Bus which implements the distributed algorithm of the Dynamic Simulation Environment.\nImplementation of Model Interfaces: the messages of the Dynamic Simulation Environment are defined using cross platform serialization libraries (Flatbuffers, MsgPack and gRPC). Model interfaces can therefore be written for any combination of operating System, architecture or programming language.\nSignal Vectors The Model C Library presents signals to a model developer as Signal Vectors; simple vector objects, either holding scalar or binary signals, and a collection of supporting methods. Typically, the only interactions a Model Developer will have with the Dynamic Simulation Environment will be related to Signal Vectors.\nIn the Dynamic Simulation Environment, when using the Model C Library, Signal Vectors are used to:\nProvide a simple Model API: only 2 functions are required to implement a Model in the Dynamic Simulation Environment.\nRepresent Signals: all scalar types (bool, int8, float, double etc.) can represented in a scalar Signal Vector, and complex or streaming data types can be represented with a binary Signal Vector. A binary signal may also be annotated with a MIMEtype to further describe additional schemas or properties of the binary data.\nEncapsulate Models from other modelling standards: a Model Compatibility Layer may be implemented to extend the Model C Library to support a foreign modelling tool or framework. In that case, the native data types of the foreign model may be marshalled into either scalar or binary Signal Vectors as required, and then interact seamlessly with other models present in the simulation.\nConnect to external simulations: a Gateway Model allows remote/legacy simulation tools to be connected to a Dynamic Simulation Environment and exchange signals using Signal Vectors. Gateway models are written in the same programming language or framework as that of the remote/legacy simulation tool, and also run in that same environment.\nThe Core Platform The Dynamic Simulation Environment Core Platform is a collection of schemas, libraries and tools which can be used to design and implement simulations using the compositional approach.\nContributing Want to contribute? Great! Each project repository has contribution instructions, however the general recommendation is to open an Issue or Pull Request. If your planning a larger contribution, get in contact first (e.g. open an Issue) and discuss the changes.\nMore Information Check out the docs, or open an issue on one of the repos.\n","categories":"","description":"","excerpt":" Dynamic Simulation Environment The Dynamic Simulation Environment is …","ref":"/dse.doc/about/","tags":"","title":"About the Dynamic Simulation Environment"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/architecture/","tags":"","title":"Architecture"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/builder/","tags":"","title":"Builder"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/categories/","tags":"","title":"Categories"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/cli/","tags":"","title":"CLI"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/cmocka/","tags":"","title":"CMocka"},{"body":"CMocka Testing for C Code The DSE Projects use CMocka for both Unit and Integration testing. This document introduces the typical CMocka Test Project and explains the testing features which are most often used when developing.\nCode Layout and Test Organisation L- tests/cmocka Directory containing CMocka tests. L- target An individual test target (single test executable). L- __tests__.c Entry point for the test target (runs test groups). L- test_foo.c Contains a test group (e.g. related tests). L- CMakeLists.txt Make definitions for all test targets. L- Makefile CMake automation. L- Makefile High-level build automation. Example Test Files tests/cmocka/target/__test__.c // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cdse/testing.h\u003e extern int run_foo_tests(void); int main() { int rc = 0; rc |= run_foo_tests(); return rc; } tests/cmocka/target/test_foo.c // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cdse/testing.h\u003e #define UNUSED(x) ((void)x) #define ARRAY_SIZE(x) (sizeof(x) / sizeof(x[0])) typedef struct FooMock { int foo_value; } FooMock; static int test_setup(void** state) { FooMock* mock = calloc(1, sizeof(FooMock)); mock-\u003efoo_value = 4; *state = mock; return 0; } static int test_teardown(void** state) { FooMock* mock = *state; if (mock) free(mock); return 0; } typedef struct FooTest { int test_value; int remainder; } void test_foo__data_driven(void** state) { FooMock* mock = *state; FooTest tests[] = { { .test_value = 5, .remainder = 1 }, { .test_value = 8, .remainder = 4 }, { .test_value = 2, .remainder = -2 }, }; for (size_t i = 0; i \u003c ARRAY_SIZE(tests); i++) { int remainder = tests[i].test_value - mock-\u003efoo_value; assert_int_equal(remainder, tests[i].remainder); } } int run_foo_tests(void) { void* s = test_setup; void* t = test_teardown; const struct CMUnitTest tests[] = { cmocka_unit_test_setup_teardown(test_foo__data_driven, s, t), }; return cmocka_run_group_tests_name(\"FOO\", tests, NULL, NULL); } tests/cmocka/CMakeLists.txt cmake_minimum_required(VERSION 3.21) project(test_project) include(FetchContent) include(GNUInstallDirs) set(CMAKE_INSTALL_PREFIX ${CMAKE_BINARY_DIR}/_out) set(CMAKE_ENABLE_EXPORTS ON) set(CMAKE_C_STANDARD 99) set(CMAKE_C_STANDARD_REQUIRED TRUE) set(CMAKE_POSITION_INDEPENDENT_CODE ON) set(CMAKE_BUILD_TYPE Debug) set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -O3 -ggdb\") list(APPEND C_CXX_WARNING_FLAGS -Wall -W -Wwrite-strings -Wno-missing-field-initializers -Wno-misleading-indentation ) add_compile_options(${C_CXX_WARNING_FLAGS}) FetchContent_Declare(dse_clib URL https://github.com/boschglobal/dse.clib/archive/refs/tags/v1.0.5.tar.gz SOURCE_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.clib\" ) FetchContent_MakeAvailable(dse_clib) set(DSE_CLIB_SOURCE_DIR ${dse_clib_SOURCE_DIR}/dse/clib) set(DSE_CLIB_INCLUDE_DIR \"${DSE_CLIB_SOURCE_DIR}/../..\") add_executable(test_target runnable/__test__.c runnable/test_foo.c ) target_include_directories(test_target PRIVATE ${DSE_CLIB_INCLUDE_DIR} ./ ) target_compile_definitions(test_target PUBLIC CMOCKA_TESTING ) target_link_libraries(test_target PRIVATE cmocka dl m ) install(TARGETS test_target) tests/cmocka/Makefile GDB_CMD ?= valgrind -q --leak-check=yes # GDB_CMD ?= gdb -q -ex='set confirm on' -ex=run -ex=quit default: build setup: mkdir build; cd build; cmake .. build: # Build from scratch if no build dir. if [ ! -d \"build\" ]; then make setup; fi # Build. cd build; make cd build; make install .PHONY: run run: cd build/_out; $(GDB_CMD) bin/test_target .PHONY: clean clean: rm -rf build .PHONY: cleanall cleanall: clean Makefile export NAMESPACE = fsil export MODULE = runnable export PROJECT_URL ?= $(GITHUB_ORG)/$(NAMESPACE).$(MODULE).git export DOCKER_REPO ?= ghcr.io/boschglobal export EXTERNAL_BUILD_DIR ?= /tmp/$(NAMESPACE).$(MODULE) export PACKAGE_ARCH ?= linux-amd64 export CMAKE_TOOLCHAIN_FILE ?= $(shell pwd -P)/extra/cmake/$(PACKAGE_ARCH).cmake export PACKAGE_VERSION ?= 0.0.2 export GCC_BUILDER_IMAGE ?= $(DOCKER_REPO)/dse-gcc-builder:latest ifneq ($(CI), true) DOCKER_BUILDER_CMD := docker run -it --rm \\ --volume $$(pwd):/tmp/repo \\ --volume $(EXTERNAL_BUILD_DIR):$(EXTERNAL_BUILD_DIR) \\ --volume ~/.ccache:/root/.ccache \\ --env CMAKE_TOOLCHAIN_FILE=/tmp/repo/extra/cmake/$(PACKAGE_ARCH).cmake \\ --env EXTERNAL_BUILD_DIR=$(EXTERNAL_BUILD_DIR) \\ --env PACKAGE_ARCH=$(PACKAGE_ARCH) \\ --env HTTP_PROXY=$(http_proxy) \\ --env HTTPS_PROXY=$(https_proxy) \\ --env NO_PROXY=$(no_proxy) \\ --env AR_USER=$(AR_USER) \\ --env AR_TOKEN=$(AR_TOKEN) \\ --env GHE_USER=$(GHE_USER) \\ --env GHE_TOKEN=$(GHE_TOKEN) \\ --env DOCKER_REPO=$(DOCKER_REPO) \\ --env PROJECT_URL=$(PROJECT_URL) \\ --env GDB_CMD=\"$(GDB_CMD)\" \\ --env PACKAGE_VERSION=$(PACKAGE_VERSION) \\ --env NAMESPACE=$(NAMESPACE) \\ --env MODULE=$(MODULE) \\ --workdir /tmp/repo \\ $(GCC_BUILDER_IMAGE) endif do-test_cmocka-build: $(MAKE) -C tests/cmocka build do-test_cmocka-run: $(MAKE) -C tests/cmocka run .PHONY: test_cmocka test_cmocka: @${DOCKER_BUILDER_CMD} $(MAKE) do-test_cmocka-build @${DOCKER_BUILDER_CMD} $(MAKE) do-test_cmocka-run .PHONY: test test: test_cmocka Testing Features and Integrations DSE Testing Headers The DSE C Lib includes a header file dse/testing.h which can be used to include the required set of CMocka headers and other testing related adaptations. The functionality of the header is enabled with build defines as follows:\nCMOCKA_TESTING - enables the set of CMocka include files. Typically used in CMocka test projects.\nUNIT_TESTING - enables the set of CMocka include files and also enables the extended memory testing functionality in CMocka.\nWhen these defines are not used (i.e. during testing), the dse/testing.h header file has no effect. It can be safely included by any source code.\nTip : Valgrind is an easier form of memory testing than that offered by CMocka. In general, CMocka memory testing requires instrumentation of all code included in a test target (via dse/testing.h). This becomes troublesome when integrating external libraries as the CMocka techniques do not work well when all code is not similarly instrumented (as is the case with external libraries). In short, Valgrind is easier.\nValgrind Memory Checks Valgrind memory checks can be enabled within the build environments by setting the environment variable GDB_CMD before running a test target.\n$ export GDB_CMD=\"valgrind -q --leak-check=full --track-origins=yes --error-exitcode=808\" $ make test ... This is the default setting for many DSE Projects.\nGDB Based Debugging Runtime exceptions (e.g. segmentation faults) can be quickly debugged by enabling GDB within the build environments by setting the environment variable GDB_CMD before running a test target.\n$ export GDB_CMD=\"gdb -q -ex='set confirm on' -ex=run -ex=quit\" $ make test ... More information about using GDB is available at Model C Debug Techniques.\nTesting Techniques Data Driven Tests An especially powerful technique for writing tests which uses tabular data to execute and test a variety of conditions. A data driven test typically has two parts:\nThe table (an array) containing data which will be fed, row by row, into the function being tested. Each row of the table will contain both arguments and expected responses (or other evaluation criteria).\nThe evaluation which, for each row of the table, will call the functions being tested and evaluate the results.\nExample Data Driven Test Example data driven test. #include \u003cdse/testing.h\u003e typedef struct TestRow { int value; int result; } void test_foo__data_driven(void** state) { Mock* mock = *state; TestRow tests[] = { { .value = 5, .result = 10 }, { .value = 8, .result = 16 }, { .value = 2, .result = 4 }, }; for (size_t i = 0; i \u003c ARRAY_SIZE(tests); i++) { int result = double(tests[i].value); assert_int_equal(result, tests[i].result); } } Integration Testing Integration testing is possible by creating a test which directly links against the DSE Model C Library and uses its “MStep” API to load, configure and step a model. With this technique it is possible to verify the following:\nConfiguration files are correctly parsed. Model configuration and initialisation. Model operation, externally observed via changes to signals (i.e. Signal Vectors). Detection of memory leaks (using Valgrind). Example MStep Test Example MStep test loading and stepping a model. #include \u003cdlfcn.h\u003e #include \u003cdse/testing.h\u003e #include \u003cdse/logger.h\u003e #include \u003cdse/modelc/model.h\u003e #include \u003cdse/restbus/restbus.h\u003e void test_mstep(void** state) { char* argv[] = { (char*)\"test_mstep\", (char*)\"--name=stub_inst\", (char*)\"--logger=5\", // QUIET (char*)\"examples/stub/data/stack.yaml\", (char*)\"../../../../tests/cmocka/mstep/model_mstep.yaml\", (char*)\"../../../../tests/cmocka/mstep/restbus_mstep.yaml\", }; int argc = ARRAY_SIZE(argv); int rc; ModelCArguments args; SimulationSpec sim; ModelInstanceSpec* mi; /* Setup the ModelC interfaces. */ modelc_set_default_args(\u0026args, \"test\", 0.0005, 0.0010); modelc_parse_arguments(\u0026args, argc, argv, \"MStep Test\"); rc = modelc_configure(\u0026args, \u0026sim); assert_int_equal(rc, 0); mi = modelc_get_model_instance(\u0026sim, args.name); assert_non_null(mi); /* Directly load the Restbus Model. */ void* handle = dlopen(mi-\u003emodel_definition.full_path, RTLD_NOW | RTLD_LOCAL); assert_non_null(handle); ModelSetupHandler model_setup_func = dlsym(handle, MODEL_SETUP_FUNC_STR); ModelExitHandler model_exit_func = dlsym(handle, MODEL_EXIT_FUNC_STR); assert_non_null(model_setup_func); assert_non_null(model_exit_func); /* Call the Model Setup. */ rc = model_setup_func(mi); assert_int_equal(rc, 0); SignalVector* sv = model_sv_create(mi); /* Locate the restbus and network vectors. */ SignalVector* sv_restbus = NULL; SignalVector* sv_network = NULL; while (sv \u0026\u0026 sv-\u003ename) { if (strcmp(sv-\u003ename, \"restbus\") == 0) sv_restbus = sv; if (strcmp(sv-\u003ename, \"network\") == 0) sv_network = sv; /* Next signal vector. */ sv++; } assert_non_null(sv_restbus); assert_string_equal(sv_restbus-\u003ename, \"restbus\"); assert_int_equal(sv_restbus-\u003ecount, 3); assert_non_null(sv_restbus-\u003escalar); assert_non_null(sv_network); assert_string_equal(sv_network-\u003ename, \"network\"); assert_int_equal(sv_network-\u003ecount, 1); assert_non_null(sv_network-\u003ebinary); assert_non_null(sv_network-\u003elength); assert_non_null(sv_network-\u003ebuffer_size); /* Check the initial values. */ assert_double_equal(sv_restbus-\u003escalar[0], 1.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[1], 0.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[2], 265.0, 0.0); assert_null(sv_network-\u003ebinary[0]); assert_int_equal(sv_network-\u003elength[0], 0); assert_int_equal(sv_network-\u003ebuffer_size[0], 0); /* Step the model - ensure no can_tx based on setting initial values. */ rc = modelc_step(mi, args.step_size); assert_int_equal(rc, 0); assert_double_equal(sv_restbus-\u003escalar[0], 1.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[1], 0.0, 0.0); assert_double_equal(sv_restbus-\u003escalar[2], 265.0, 0.0); assert_null(sv_network-\u003ebinary[0]); assert_int_equal(sv_network-\u003elength[0], 0); assert_int_equal(sv_network-\u003ebuffer_size[0], 0); sv_network-\u003ereset(sv_network, 0); /* Call the Model Exit. */ rc = model_exit_func(mi); assert_int_equal(rc, 0); } CMake file (partial) with linking to DSE Model C Library. ... # External Project - DSE ModelC Library (for linking to mstep) # ------------------------------------- set(MODELC_BINARY_DIR \"$ENV{EXTERNAL_BUILD_DIR}/dse.modelc.lib\") find_library(MODELC_LIB NAMES libmodelc_bundled.a PATHS ${MODELC_BINARY_DIR}/lib REQUIRED NO_DEFAULT_PATH ) add_library(modelc STATIC IMPORTED GLOBAL) set_target_properties(modelc PROPERTIES IMPORTED_LOCATION \"${MODELC_LIB}\" INTERFACE_INCLUDE_DIRECTORIES \"${MODELC_BINARY_DIR}\" ) ... # Target - MSTEP # -------------- add_executable(test_mstep ) target_include_directories(test_mstep PRIVATE ./ ) target_compile_definitions(test_mstep PUBLIC CMOCKA_TESTING PRIVATE PLATFORM_OS=\"${CDEF_PLATFORM_OS}\" PLATFORM_ARCH=\"${CDEF_PLATFORM_ARCH}\" ) target_link_libraries(test_mstep PUBLIC -Wl,-Bstatic modelc -Wl,-Bdynamic ${CMAKE_DL_LIBS} PRIVATE cmocka dl m ) install(TARGETS test_mstep) Mocking Functions Mock functions are used to adjust (or mimic) the behaviour of real functions in situations where the normal behaviour of a real function is not desired; either because the real function might not operate normally (missing dependencies), or when a particular behaviour needs to be injected (to test a related behaviour). CMocka provides a stack based mocking system which makes it possible to implement and inject mocked functional behaviours.\nThese mocking features are:\nexpect_value() - indicate that the mock function should be called with this parameter set to the specified value. Useful when the mock function is called indirectly from the code being tested.\ncheck_expected() - the mock function checks that the provided parameter matched the expected value (set by expect_value()).\nwill_return() - push a value onto the mock stack before the mocked function is called (i.e. called in test code). Expected to be called in a pair with mock().\nmock() - pop a value from the mock stack. Called inside the mock function.\nExample Mock Example mocked function and test case. #include \u003cdse/testing.h\u003e /* The real function to be mocked. */ int test_function(int a, int b); /* The mock function, prefixed with '__wrap_'. */ int __wrap_test_function(int a, int b) { /* Test that the correct parameters were passed to the mock. */ check_expected(a); check_expected(b); /* mock() - Pop values from the stack of test values. */ int a_wrap = mock_type(int); int b_wrap = mock_type(int); /* Condition/behaviour being mocked. */ if (a_wrap == 1 \u0026\u0026 b_wrap == 2) return 3; return 0; } /* Test functions. */ void test_success(void **state) { /* Push expect values to the mock stack. */ expect_value(__wrap_test_function, a, 1); expect_value(__wrap_test_function, b, 2); /* Push values to the mock stack. */ will_return(__wrap_test_function, 1); will_return(__wrap_test_function, 2); /* Call the original function, and evaluate the mocked behaviour. */ assert_int_equal(test_function(1, 2), 3); } int main(void) { const struct CMUnitTest tests[] = { cmocka_unit_test(test_success), }; return cmocka_run_group_tests(tests, NULL, NULL); } Inline Python with Cog Info : Cog usage is experimental in DSE Test Projects.\nCog is a useful technique for preprocessing Python scripts embedded in C code. Interesting use cases include:\nCreation of “here documents” (text documents embedded in code files). Generation of C code, using cog.outl() to write code into the same file during cog processing. Example Cog Integration Embedded Cog Heredoc. #include \u003cdse/testing.h\u003e #define UNUSED(x) ((void)x) /* Cog Heredoc. */ /*[[[cog yaml=\"\"\" kind: SignalGroup metadata: name: network_signals spec: signals: - signal: RAW \"\"\" with open('sg.yaml', 'w') as f: f.write(yaml) ]]]*/ /*[[[end]]]*/ int main(void) { /* Test implementation ... */ } CMake integration. # Setup preprocessing to generate output files at configuration stage. execute_process(COMMAND cog.py ${CMAKE_CURRENT_BINARY_DIR}/../../util/test.c) # GLOB the generated files and install. file (GLOB GENERATED_YAML_FILES ${CMAKE_CURRENT_BINARY_DIR}/../*.yaml ) install( FILES ${GENERATED_YAML_FILES} DESTINATION data/yaml ) # Setup a custom command to invoke cog. add_custom_command( OUTPUT SYMBOLIC test COMMAND cog.py ${CMAKE_CURRENT_BINARY_DIR}/../../util/test.c DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/../../util/test.c COMMENT \"Creating symbolic file and running cog\" ) Installing Cog. $ pip install cogapp References and Further Reading CMocka assert macros CMocka API - links to checking paramters and mock objects functions. CMocka project page Test Driven Development for Embedded C - very good reference on TDD and C. Cog, Inline Python - An introduction to cog. ","categories":"","description":"","excerpt":"CMocka Testing for C Code The DSE Projects use CMocka for both Unit …","ref":"/dse.doc/docs/devel/testing/cmocka/","tags":["Developer","Testing","CMocka"],"title":"Testing with CMocka"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/codec/","tags":"","title":"Codec"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/developer/","tags":"","title":"Developer"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/dselang/","tags":"","title":"DSELang"},{"body":" Learn More Git Hub The Dynamic Simulation Environment is a message based distributed simulation platform which defines the interface between models as signal vectors. Signal vectors are a logical grouping of either scalar or binary data which are exchanged between models at discrete points in time. Models may be developed in any programming language and may run on any operating system or hardware platform.\nSimulations are constructed using models with a compositional approach, where system elements represented by the simulation are decomposed/recomposed from a collection of models according the broader simulation objectives. This compositional approach to simulation, called Functional Simulation (FSIL), supports the development of a variety of simulation strategies.\nThe Dynamic Simulation Environment (DSE) can be used to integrate legacy tools into a simulation, such integration techniques include; Gateway models which connect remote systems to a DSE simulation; and Model Compatibility Layers which import foreign models into a DSE simulation. Several Gateway and Model Compatibility Layers are available alongside the Model C Library, our C based implementation of the Dynamic Simulation Environment.\nGetting Started Get started with the DSE.\nRead more\nContributions welcome! We do a Pull Request contributions workflow on GitHub.\nRead more\nGitHub Discussions Ask technical questions.\nRead more\n","categories":"","description":"","excerpt":" Learn More Git Hub The Dynamic Simulation Environment is a message …","ref":"/dse.doc/","tags":"","title":"Dynamic Simulation Environment"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/envar/","tags":"","title":"Envar"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/fmi/","tags":"","title":"FMI"},{"body":"fmi2GetString Get values for the provided list of value references.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to retrieve. nvr (int) The number of value references to retrieve. value (fmi2String[]) Storage for the retrieved values. Returns fmi2OK (fmi2Status) The requested variables are retrieved (where available). fmi2SetReal Set values for the provided list of value references and values.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to set. nvr (int) The number of value references to set. value (fmi2Real[]) Storage for the values to be set. Returns fmi2OK (fmi2Status) The requested variables have been set (where available). fmi2FreeInstance Free memory and resources related to the provided FMU instance.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. FMU API The FMU API provides a simplified FMU inteface with an abstracted variable interface (indexing and storage). The FMU Interface includes the methods:\nImplemented by FMU developer: [fmu_create()](#fmu_create) [fmu_init()](#fmu_init) [fmu_step()](#fmu_step) [fmu_destroy()](#fmu_destroy) Additional provided functions: [fmu_log()](#fmu_log) - logging function Supporting Variable Table mechanism: [fmu_register_var()](#fmu_register_var) [fmu_register_var_table()](#fmu_register_var_table) [fmu_var_table()](#fmu_var_table) An additional FMU Signal Interface is available for more complex integrations:\n[fmu_signals_reset()](#fmu_signals_reset) [fmu_signals_setup()](#fmu_signals_setup) [fmu_signals_remove()](#fmu_signals_remove) FMUs implemented using this simplified FMU API can be built for both FMI 2 and FMI 3 standards by linking to the relevant implementations:\nfmi2fmu.c for and FMI 2 FMU fmi3fmu.c for and FMI 3 FMU Binary variables are supported for FMI 3 and FMI 2 standards. In FMUs built to the FMI 2 standard, binary variables are implemented via FMI String Variables and an associated encoding. See Dynamic Simulation Environment - FMI Layered Standard Binary Codec Selection for details.\nComponent Diagram @startuml fmu-component skinparam nodesep 55 skinparam ranksep 40 skinparam roundcorner 10 skinparam componentTextAlignment center title FMU Component Diagram component \"Importer\" as importer interface \"FMI I/F\" as fmi package \"FMU Library\" { component \"FMI FMU\\n(fmiXfmu.c)\" as fmiXfmu component \"**FMU**\\n(fmu.c)\" as fmu interface \"FmuVTable\" as fmuVt component \"Index\\n(signal.c)\" as index interface \"FmuSignalVTable\" as signalVt component \"Encoder\\n(ascii85.c)\" as encoder component \"Network\\n(ncodec.c)\" as network interface \"NCodecVTable\" as ncodec note as N_fmu Contains FMU functional implementation/models. end note fmu .up. N_fmu } importer -down-( fmi fmi --down- fmiXfmu fmiXfmu -left-( fmuVt fmuVt -left- fmu fmiXfmu -down-( signalVt signalVt -down- index stream .up.\u003e index encoder .up.\u003e index network .right.\u003e stream fmu -down-( ncodec ncodec --- network center footer Dynamic Simulation Environment @enduml Example The following example demonstrates an FMU which implements an incrementing counter.\n// Copyright 2024 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cdse/fmu/fmu.h\u003e typedef struct { double counter; } VarTable; FmuInstanceData* fmu_create(FmuInstanceData* fmu) { VarTable* v = malloc(sizeof(VarTable)); *v = (VarTable){ .counter = fmu_register_var(fmu, 1, false, offsetof(VarTable, counter)), }; fmu_register_var_table(fmu, v); return fmu; } int fmu_init(FmuInstanceData* fmu) { UNUSED(fmu); return 0; } int fmu_step(FmuInstanceData* fmu, double CommunicationPoint, double stepSize) { UNUSED(CommunicationPoint); UNUSED(stepSize); VarTable* v = fmu_var_table(fmu); /* Increment the counter. */ v-\u003ecounter += 1; return 0; } int fmu_destroy(FmuInstanceData* fmu) { UNUSED(fmu); return 0; } void fmu_reset_binary_signals(FmuInstanceData* fmu) { UNUSED(fmu); } fmi2ExitInitializationMode Initialise the Model Runtime (of the ModelC library) and in the process establish the simulation that this ModelC FMU is wrapping/operating.\nThis function will generate indexes to map between FMI Variables and ModelC Signals; both scaler signals (double) and binary signals (string/binary).\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. Returns fmi2OK (fmi2Status) The simulation that this FMU represents is ready to be operated. fmi2GetReal Get values for the provided list of value references.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to retrieve. nvr (int) The number of value references to retrieve. value (fmi2Real[]) Storage for the retrieved values. Returns fmi2OK (fmi2Status) The requested variables are retrieved (where available). fmi2SetString Set values for the provided list of value references and values. String/Binary variables are always appended to the ModelC Binary Signal.\nNote: If several variables are indexed against the same ModelC Binary Signal, for instance in a Bus Topology, then each variable will be appended to that ModelC Binary Signal.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to set. nvr (int) The number of value references to set. value (fmi2String[]) Storage for the values to be set. Returns fmi2OK (fmi2Status) The requested variables have been set (where available). fmi2DoStep Set values for the provided list of value references and values. String/Binary variables are always appended to the ModelC Binary Signal.\nNote: If several variables are indexed against the same ModelC Binary Signal, for instance in a Bus Topology, then each variable will be appended to that ModelC Binary Signal.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. currentCommunicationPoint (fmi2Real) The model time (for the start of this step). communicationStepSize (fmi2Real) The model step size. noSetFMUStatePriorToCurrentPoint (fmi2Boolean) Not used. Returns fmi2OK (fmi2Status) The step completed. fmi2Error (fmi2Status) An error occurred when stepping the ModelC Simulation. default_log Default logging function in case the FMU caller does not provide any logger.\nfmi2Instantiate Create an instance of this FMU, allocate/initialise a FmuInstanceData object which should be used for subsequent calls to FMI methods (as parameter fmi2Component c).\nNote: This implementation does not use memory related callbacks provided by the Importer (e.g. malloc() or free()).\nReturns fmi2Component (pointer) An FmuInstanceData object which represents this FMU instance. Typedefs FmuInstanceData typedef struct FmuInstanceData { struct { char* name; int type; int version; char* resource_location; char* guid; bool log_enabled; void* logger; void* environment; char* save_resource_location; } instance; struct { struct { int input; int output; } scalar; struct { int input; int output; } string; struct { int rx; int tx; int encode_func; int decode_func; int free_list; } binary; FmuSignalVTable vtable; bool signals_reset; } variables; void* data; struct { void* table; int var_list; FmuVarTableMarshalItem* marshal_list; } var_table; } FmuSignalVTable typedef struct FmuSignalVTable { FmuSignalsResetFunc reset; FmuSignalsSetupFunc setup; FmuSignalsRemoveFunc remove; } FmuSignalVector typedef struct FmuSignalVector { int index; uint32_t count; char** signal; uint32_t* uid; double* scalar; void** binary; uint32_t* length; uint32_t* buffer_size; char** mime_type; void** ncodec; } FmuSignalVectorIndex typedef struct FmuSignalVectorIndex { FmuSignalVector* sv; uint32_t vi; } FmuVTable typedef struct FmuVTable { FmuCreateFunc create; FmuInitFunc init; FmuStepFunc step; FmuDestroyFunc destroy; } FmuVarTableMarshalItem typedef struct FmuVarTableMarshalItem { double* variable; double* signal; } Functions fmu_create This method creates a FMU specific instance which will be used to operate the FMU. It is called in the Instantiate() method of the FMI standard.\nFault conditions can be communicated to the caller by setting variable errno to a non-zero value.\nImplemented by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns NULL The FMU was configured. (FmuInstanceData*) Pointer to a new, or mutilated, version of the Fmu Descriptor object. The original Fmu Descriptor object will be released by the higher layer (i.e. don’t call free()). errno \u003c\u003e 0 (indirect) Indicates an error condition. fmu_destroy Releases memory and system resources allocated by FMU. It is called in the FreeInstance() Method of the FMU.\nImplemented by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns 0 (int32_t) The FMU data was released correctly. fmu_init This method initializes all FMU relevant data that is represented by the FMU. It is called in the ExitInitializationMode() Method of the FMU.\nImplemented by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns 0 (int32_t) The FMU was created correctly. fmu_load_signal_handlers This method assigns the signal handler function to a vtable.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_log Write a log message to the logger defined by the FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. status (const int) The status of the message to be logged. category (const char*) The category the message belongs to. message (const char*) The message to be logged by the FMU. fmu_lookup_ncodec Lookup and existing NCODEC object which represents a binary (or string) variable of the FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. vref (uint32_t) Variable reference of the variable with an associated NCODEC object. input (bool) Set true for input, and false for output variable causality. Returns void* (NCODEC pointer) A valid NCODEC object for the underlying variable. fmu_register_var Register a variable with the FMU Variable Table mechanism.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. vref (uint32_t) Variable reference of the variable being registered. input (bool) Set true for input, and false for output variable causality. offset (size_t) Offset of the variable (type double) in the FMU provided variable table. Returns start_value (double) The configured FMU Variable start value, or 0. fmu_register_var_table Register the Variable Table. The previously registered variables, via calls to fmu_register_var, are configured and the FMU Variable Table mechanism is enabled.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. table (void*) Pointer to the Variable Table being registered. fmu_signals_remove This method will remove any buffers used to provide storage for FMU variables. If those buffers were allocated (e.g by an implementation of fmu_signals_setup()) then those buffers should be freed in this method.\nIntegrators may provide their own implementation of this method.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_signals_reset This method will reset any binary variables which where used by an FMU in the previous step. Typically this will mean that indexes into the buffers of binary variables are set to 0, however the buffers themselves are not released (i.e. free() is not called).\nIntegrators may provide their own implementation of this method.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_signals_setup This method will setup the buffers which provide storage for FMU variables. Depending on the implementation buffers may be mapped to existing buffers in the implementation, or allocated specifically. When allocating buffers the method fmu_signals_setup() should also be implemented to release those buffers when the FmuInstanceData() is freed.\nIntegrators may provide their own implementation of this method.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_step This method initializes all FMU relevant data that is represented by the FMU. It is called in the DoStep() Method of the FMU.\nImplemented by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. communication_point (double) The current model time of the FMU in seconds. step_size (double) The step size of the FMU in seconds. Returns 0 (int32_t) The FMU step was performed correctly. fmu_var_table Return a reference to the previously registered Variable Table.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns table (void*) Pointer to the Variable Table. ","categories":"","description":"","excerpt":"fmi2GetString Get values for the provided list of value references. …","ref":"/dse.doc/apis/fmi/fmu/","tags":"","title":"FMU API Reference"},{"body":"Example Network Functions Example implementation of Network Functions.\nTypedefs InstanceData typedef struct InstanceData { int position; } Functions counter_inc_uint8 Increment an 8-bit counter in the message packet.\nNote: in the encode path, changes to the counter are not reflected in the corresponding signal. Subsequent calls to network_message_recalculate may overwrite the modified counter.\nParameters data (void**) Pointer reference for instance data. payload (uint8_t*) The payload that this function will modify. payload_len (size_t) The length of the payload. Returns 0 Counter incremented. ENOMEM Instance data could not be established. EPROTO A required annotation was not located. Annotations position The position of the counter in the message packet. crc_generate Calculate a CRC based on the message packet. The CRC is written into the specified position in the message packet.\nThe CRC algorithm is a simple summation of all bytes in the message packet.\nNote: in the encode path (TX), changes to the counter are not reflected in the corresponding signal.\nParameters data (void**) Pointer reference for instance data. payload (uint8_t*) The payload that this function will modify. payload_len (size_t) The length of the payload. Returns 0 CRC generated. ENOMEM Instance data could not be established. EPROTO A required annotation was not located. Annotations position The position of the CRC in the message packet. crc_validate Validate the CRC of a message packet. The CRC is included in the message packet.\nNote: in the decode path (RX), bad messages (function returns EBADMSG) will not change corresponding signals.\nParameters data (void**) Pointer reference for instance data. payload (uint8_t*) The payload that this function will modify. payload_len (size_t) The length of the payload. Returns 0 The CRC passed validation. EBADMSG The CRC failed validation. The message will not be decoded. ENOMEM Instance data could not be established. EPROTO A required annotation was not located. Annotations position The position of the CRC in the message packet. ","categories":"","description":"","excerpt":"Example Network Functions Example implementation of Network Functions. …","ref":"/dse.doc/apis/network/functions/","tags":"","title":"Example Network Function API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/gateway/","tags":"","title":"Gateway"},{"body":"Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.\nComponent Diagram @startuml gateway-model title Gateway Model node \"Dynamic Simulation Environment\" { component \"Model\" as m1 component \"Model\" as m2 interface \"SimBus\" as SBif m1 -left-\u003e SBif m2 -right-\u003e SBif } package \"Gateway Model\" { component \"ModelC Lib\" as ModelC component \"Model\" } SBif \u003c-down- ModelC Model -up-\u003e ModelC :model_gw_setup() Model -up-\u003e ModelC :model_gw_sync() Model -up-\u003e ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cstdlib.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003cdse/modelc/gateway.h\u003e #include \u003cdse/logger.h\u003e /** * Gateway Model. * * A normal gateway would exchange signals with the host simulation, however * in this example a simple conversion is applied to each signal (to * demonstrate the effect). * * Example * ------- * ./gateway 0.005 0.02 gateway.yaml */ int main(int argc, char** argv) { if (argc \u003c 4) { log_fatal( \"Missing arguments! (gateway \u003cstep_size\u003e \u003cend_time\u003e [yaml ...])\"); } double model_time = 0.0; double step_size = atof(argv[1]); double end_time = atof(argv[2]); const char** yaml_files = calloc(argc - 3 + 1, sizeof(char*)); memcpy(yaml_files, \u0026argv[3], ((argc - 3) * sizeof(char*))); /* Setup the gateway. */ ModelGatewayDesc gw; model_gw_setup(\u0026gw, \"gateway\", yaml_files, LOG_INFO, step_size, end_time); /* Run the simulation. */ while (model_time \u003c= end_time) { int rc = model_gw_sync(\u0026gw, model_time); if (rc == ETIME) { log_notice( \"Gateway is behind simulation time, advancing gateway time.\"); model_time += step_size; continue; } /* Process the signal vectors. */ SignalVector* sv = gw.sv; while (sv \u0026\u0026 sv-\u003ename) { if (sv-\u003eis_binary) { /* Binary vector. */ for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_info(\"[%f] %s[%d] = \u003c%d:%d\u003e%s (%s)\", model_time, sv-\u003ename, i, sv-\u003elength[i], sv-\u003ebuffer_size[i], sv-\u003ebinary[i], sv-\u003esignal[i]); /* Exchange/update the gateway signal. */ uint8_t buffer[100]; snprintf((char*)buffer, sizeof(buffer), \"st=%f,index=%d\", model_time, i); signal_reset(sv, i); signal_append(sv, i, buffer, strlen((char*)buffer) + 1); } } else { /* Scalar vector. */ for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_info(\"[%f] %s[%d] = %f (%s)\", model_time, sv-\u003ename, i, sv-\u003escalar[i], sv-\u003esignal[i]); /* Exchange/update the gateway signal. */ sv-\u003escalar[i] = sv-\u003escalar[i] + ((i + 1) \u003c\u003c 2); } } /* Next signal vector. */ sv++; } /* Next step. */ model_time += step_size; } /* Exit the simulation. */ model_gw_exit(\u0026gw); free(yaml_files); return 0; } Typedefs ModelGatewayDesc typedef struct ModelGatewayDesc { int* sim; int* mi; int* sv; const char** argv; char* name_arg; double clock_epsilon; uint64_t [4] __reserved__; } Functions model_gw_exit Terminates the Gateway Model and releases all objects referenced by the ModelGatewayDesc object. The object itself is not affected and should be released by the caller (if necessary).\nParameters gw (ModelGatewayDesc*) A gateway descriptor object, holds references to various ModelC objects. Returns 0 Success. +ve Failure, inspect errno for the failing condition. model_gw_setup Parameters gw (ModelGatewayDesc*) A gateway descriptor object, holds references to various ModelC objects. name (const char*) Name of the gateway model. Used when parsing the provided YAML files to select the relevant configuration items (i.e. Model and SignalGroup schemas). yaml_files (const char*) A list of YAML files where the relevant gateway configuration objects should be found. log_level (int) The log level to apply to the gateway model. Common values include; LOG_NOTICE (default), LOG_INFO, LOG_QUIET (only errors) or LOG_DEBUG. Set to a negative number to use the default log level. step_size (double) Step size for interactions with the Simbus. end_time (double) End time for the simulation (acts as guard against “forever” simulations). Returns 0 Success. +ve Failure, inspect errno for the failing condition. model_gw_sync Parameters gw (ModelGatewayDesc*) A gateway descriptor object, holds references to various ModelC objects. model_time (double) The current simulation time of the gateway model for which the Gateway API should synchronise with. Returns 0 Success. E_GATEWAYBEHIND The specified model_time is behind the simulation time. The time should be advanced by the caller and then retry this call until the condition clears. +ve Failure, inspect errno for the failing condition. ","categories":"","description":"","excerpt":"Gateway Model When implemented, a Gateway Model makes it possible for …","ref":"/dse.doc/apis/modelc/gateway/","tags":"","title":"Gateway API Reference"},{"body":"fmu_init In this method the required yaml files are parsed and the session is configured, if required. The gateway is set up and connected to the simbus. After a sucessfull connection has been established, the fmu variables are indexed to their corresponding simbus signals.\nRequired by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns 0 (int32_t) The FMU was created correctly. fmu_step This method executes one step of the gateway model and signals are exchanged with the other simulation participants.\nRequired by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. communication_point (double) The current model time of the FMU in seconds. step_size (double) The step size of the FMU in seconds. Returns 0 (int32_t) The FMU step was performed correctly. fmu_destroy Releases memory and system resources allocated by gateway.\nRequired by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns 0 (int32_t) The FMU data was released correctly. FMI ModelC Gateway Component Diagram @startuml fmigateway-component title FMI Gateway FMU center footer Dynamic Simulation Environment @enduml Example fmu_create This method allocates the necessary gateway models. The location of the required yaml files is set and allocated.\nFault conditions can be communicated to the caller by setting variable errno to a non-zero value.\nRequired by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns NULL The FMU was configured. (FmuInstanceData*) Pointer to a new, or mutilated, version of the Fmu Descriptor object. The original Fmu Descriptor object will be released by the higher layer (i.e. don’t call free()). errno \u003c\u003e 0 (indirect) Indicates an error condition. Typedefs FmiGateway typedef struct FmiGateway { int* model; struct { int* doc_list; const char** yaml_files; double step_size; double end_time; int log_level; const char* log_location; FmiGatewaySession* session; } settings; int binary_signals_reset; } FmiGatewayEnvvar typedef struct FmiGatewayEnvvar { const char* name; const char* type; char* vref; char* default_value; } FmiGatewaySession typedef struct FmiGatewaySession { const char* model_stack; int* model_stack_files; WindowsModel* w_models; WindowsModel* simbus; WindowsModel* transport; struct { int models; int simbus; int transport; } visibility; const char* init_cmd; const char* shutdown_cmd; FmiGatewayEnvvar* envar; double last_step; } WindowsModel typedef struct WindowsModel { const char* exe; const char* args; char* name; double step_size; double end_time; int log_level; char* yaml; double current_step; double timeout; int stacked; FmiGatewayEnvvar* envar; void* w_process; } Functions fmigateway_parse This method loads the required yaml files from the resource location of the fmu. The loaded yaml files are parsed into the fmu descriptor object.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmigateway_session_configure If session parameters were parsed from the model description, this method configures and starts the additional models, or executes the given command.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmigateway_session_end If session parameters were parsed from the model description, this method shuts down the additional models, or executes the given command.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmigateway_session_windows_end Termiantes all previously started windows processes. After sending the termination signals, one additionally step is made by the gateway to close the simulation.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmigateway_session_windows_start Creates windows processes based on the parameters configured in a yaml file. Process informations are stored for later termination.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. ","categories":"","description":"","excerpt":"fmu_init In this method the required yaml files are parsed and the …","ref":"/dse.doc/apis/fmi/fmigateway/","tags":"","title":"FMI Gateway FMU API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/gdb/","tags":"","title":"GDB"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/graph/","tags":"","title":"Graph"},{"body":"INI File API Simple INI File API for reading and modifying INI files.\nExample The following example demonstrates how to use the INI File API.\n// Copyright 2025 Robert Bosch GmbH #include \u003cstdio.h\u003e #include \u003cdse/clib/ini/ini.h\u003e #define INI_FILE \"dse_clib.ini\" int main(void) { // Open and read an INI file (if it exists). IniDesc ini = ini_open(INI_FILE); // Get an INI value. printf(\"foo (initial value) = %s\\n\", ini_get_val(\u0026ini, \"foo\")); // Set an INI value. ini_set_val(\u0026ini, \"foo\", \"fubar\", true); /* Overwrite existing value. */ ini_set_val(\u0026ini, \"bar\", \"bar\", false); /* Only if not already set. */ printf(\"foo (updated value) = %s\\n\", ini_get_val(\u0026ini, \"foo\")); printf(\"bar (default value) = %s\\n\", ini_get_val(\u0026ini, \"bar\")); // Expand an environment var. ini_set_val(\u0026ini, \"user\", \"${USER}\", true); ini_expand_vars(\u0026ini); printf(\"user (env value) = %s\\n\", ini_get_val(\u0026ini, \"user\")); // Delete a value. ini_delete_key(\u0026ini, \"user\"); printf(\"user (deleted) = %s\\n\", ini_get_val(\u0026ini, \"user\")); // Save the INI file. ini_write(\u0026ini, INI_FILE); // Close the desc object (and release used memory). ini_close(\u0026ini); return 0; } Typedefs IniDesc typedef struct IniDesc { int lines; } Functions ini_close Release any resources allocated by the INI File object.\nParameters ini (IniDesc*) INI File object. ini_delete_key Delete the specified key from the INI File object.\nParameters ini (IniDesc*) INI File object. key (const char*) The key to delete. ini_expand_vars Expand environment variables contained within the INI File values.\nExample INI File user=${USER:-default-user}` Parameters ini (IniDesc*) INI File object. ini_get_val Set a key-value pair on the INI File object.\nParameters ini (IniDesc*) INI File object. key (const char*) The key to get. overwrite (bool) When true, if the key already exists then overwrite with the provided value. Returns char* The corresponding value of key, or NULL if key is was not found. ini_open Configure and load an INI File object.\nParameters path (const char*) Path to an INI File to load. If NULL or missing no error will occur. Returns IniDesc (struct) INI File object. ini_set_val Set a key-value pair on the INI File object.\nParameters ini (IniDesc*) INI File object. key (const char*) The key to set. val (const char*) The corresponding value to set. overwrite (bool) When true, if the key already exists then overwrite with the provided value. ini_write Write the key-value pair of the INI File object to the named file.\nParameters ini (IniDesc*) INI File object. path (const char*) The file to write the key-value pairs to. ","categories":"","description":"","excerpt":"INI File API Simple INI File API for reading and modifying INI files. …","ref":"/dse.doc/apis/clib/ini/","tags":"","title":"INI FIle API Reference"},{"body":"(v0.0.1)\nManifest kind: Manifest metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: repos: - name: string repo: string path: string registry: string user: string token: string tools: - name: string version: string repo: string arch: - string schema: string models: - name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 simulations: - name: string parameters: transport: redispubsub environment: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true models: - name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 files: - name: string uri: string repo: string processing: string generate: string modelc: true documentation: - name: string uri: string repo: string processing: string generate: string modelc: true This schema object defines a Manifest kind. A Manifest kind is used to describe a compositional simulation in terms of Tools, Models, Configuration and other Files. The manifest can then be used to generate the simulation system.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec ManifestSpec true none Enumerated Values Property Value kind Manifest ManifestSpec repos: - name: string repo: string path: string registry: string user: string token: string tools: - name: string version: string repo: string arch: - string schema: string models: - name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 simulations: - name: string parameters: transport: redispubsub environment: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true models: - name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 files: - name: string uri: string repo: string processing: string generate: string modelc: true documentation: - name: string uri: string repo: string processing: string generate: string modelc: true Properties Name Type Required Description repos [Repo] true List of repositories where artifacts used by this simulation may be located. tools [Tool] true List of tools used by this simulation. models [ModelDefinition] true List of model libraries used by this simulation. simulations [Simulation] true List of individual simulations which comprise this compositional simulation. documentation [File] false List of documentation files supporting this simulation. Repo name: string repo: string path: string registry: string user: string token: string Define a repository where artifacts might be located. When a repository is referenced by a Tool, Model or File, that object will have the repository properties available as Task Variables which may be used to define a custom URI schema.\nProperties Name Type Required Description name string true Name of the repository definition. repo string false Repository URI (e.g. as used by the curl command). path string false Repository path to the root location of artifacts. registry string false Registry name/path as used by docker. user string true User for authentication with the repository. token string true Token for authentication with the repository. Tool name: string version: string repo: string arch: - string schema: string Define a tool which will be used by the simulation.\nProperties Name Type Required Description name string true Name of the tool. version string true Version of the tool. repo string false The name of the repo where this tool can be downloaded from. arch [string] false Architectures of the tool that should be downloaded. schema string false Define the URI schema for the tool. ModelDefinition name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 Define a model library which will be used by the simulation. A model library may be referenced by one or more model instances (which themselves are defined in individual simulations).\nProperties Name Type Required Description name string true Name of the model. version string true Version of the model. repo string true The name of the repository definition where this model can be downloaded from. arch string false Architecture of the model that should be downloaded. If more than one architecture of a model should be downloaded, then an additional model (with a different name) can be defined for each architecture. schema string false Define the URI schema for the model. channels [object] false Some models (i.e. Simbus) require specification of channels. » name string false The name of the channel, used when connecting this channel to the SimBus. » alias string false The alias of the channel, used when the channel name will be determined elsewhere. » expectedModelCount integer false Indicates how many models are expected to connect to this channel (used by SimBus only). » selectors object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none File name: string uri: string repo: string processing: string generate: string modelc: true Define a file which will be used by a model of the composed simulation. File processing follows the sequence; all uri nodes are processed (e.g. downloaded/copied), all processing commands are executed, finally all generate commands are executed.\nProperties Name Type Required Description name string true Path of the file relative to the root of the simulation package. This is the final path, after download or generation. When no processing or generate node is specified, the uri is downloaded/copied directly to the specified name. uri string false The URI where the file (or source for the file) is located. The uri may be a URL or local file. If a URL requires authentication, then include a repo in the file definition and the authentication will be taken from that referenced repo definition. repo string false The name of the repository definition where authentication details for this file are located. processing string false Processing commands for the downloaded/copied file. generate string false Generate commands that produce the (final) file. modelc boolean false When set to true this file is included as a parameter to the ModelC command. ModelInstanceDefinition name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 files: - name: string uri: string repo: string processing: string generate: string modelc: true Define a model instance, which belongs to a simulation.\nProperties Name Type Required Description name string true Name of the model instance. model string true The model library used by this model instance. channels [ModelDefinition/properties/channels/items] true Indicates how channels are mapped to the model instance. files [File] false List of files used by the model instance. Simulation name: string parameters: transport: redispubsub environment: property1: string property2: string files: - name: string uri: string repo: string processing: string generate: string modelc: true models: - name: string model: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 files: - name: string uri: string repo: string processing: string generate: string modelc: true Define ain individual simulation.\nProperties Name Type Required Description name string true Name of the simulation. parameters object false Parameters used to configure the simulation. » transport string true Select from the supported transports. » environment object false Dictionary of environment variables which control the simulation. The name of each element will be capitalized before being injected into the simulation environment. »» additionalProperties string false none files [File] false List of files used by the simulation and/or shared between model instances. models [ModelInstanceDefinition] true List of model instance definitions included in the simulation. Enumerated Values Property Value transport redispubsub undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nManifest kind: Manifest metadata: name: string labels: …","ref":"/dse.doc/schemas/yaml/manifest/","tags":["Schema"],"title":"Schema: Manifest"},{"body":"Marshal API The Marshal API supports two modes of operation:\nMarshalling of intrinsic data types between source and target where the target represents externally defined data structures. Marshalling of signal maps between a signal interface and the source data objects (of the marshalling sub-system). When these operations are combined it becomes possible to map signals to externally defined data structures (i.e. C style structs).\nComponent Diagram @startuml data-marshal-interface skinparam nodesep 55 skinparam ranksep 40 title Marshal Interface interface \"Signals\" as sig package \"Controller\" { component \"Source\" as sou component \"Target\" as tar } sig -right-\u003e sou : out sig \u003c-right- sou : in sou -right-\u003e tar : out sou \u003c-right- tar : in center footer Dynamic Simulation Environment @enduml Typedefs MarshalGroup typedef struct MarshalGroup { char* name; int count; MarshalKind kind; MarshalDir dir; MarshalType type; struct { uint32_t* ref; struct { int32_t* _int32; uint64_t* _uint64; double* _double; char** _string; void** _binary; void* ptr; } _binary_len; } target; struct { int offset; struct { double* scalar; void** binary; } binary_len; } source; struct { MarshalStringEncode* string_encode; MarshalStringDecode* string_decode; } functions; uint64_t [4] __reserved__; } MarshalMapSpec typedef struct MarshalMapSpec { const char* name; int count; bool is_binary; const char** signal; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; uint64_t [4] __reserved__; } MarshalSignalMap typedef struct MarshalSignalMap { char* name; int count; bool is_binary; struct { int* index; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; } signal; struct { int* index; struct { double* scalar; void** binary; } binary_len; } source; uint64_t [4] __reserved__; } MarshalStruct typedef struct MarshalStruct { char* name; int count; void* handle; MarshalKind kind; MarshalDir dir; struct { MarshalType* type; int* offset; int* length; } target; struct { int* index; void** pdata; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; } source; uint64_t [4] __reserved__; } Functions marshal_generate_signalmap Creates a signal map between signals (i.e. the external signal interface) and the source (i.e. the internal interface to the target).\nParameters signal (MarshalMapSpec) A map spec for the signals to be mapped (i.e. the representation of the signal interface). source (MarshalMapSpec) A map spec for the source values to be mapped (i.e. the representation of the target). ex_signals (SimpleSet*) A set used to keep track of signals between calls (to this function) and prevent duplicate mappings. is_binary (bool) The signal map represents binary signals (i.e. signal and source are binary signals). Returns MarshalSignalMap A MarshalSignalMap object. marshal_group_destroy Release resources associated with a MarshalGroup table, and the table itself.\nParameters mg_table (MarshalGroup*) A MarshalGroup list (Null-Terminated-List, indicated by member name). marshal_group_in Marshal a MarshalGroup inwards (from the marshal target).\nParameters mg_table (MarshalGroup*) A MarshalGroup list (Null-Terminated-List, indicated by member name). marshal_group_out Marshal a MarshalGroup outwards (towards the marshal target).\nParameters mg_table (MarshalGroup*) A MarshalGroup list (Null-Terminated-List, indicated by member name). marshal_signalmap_destroy Release resources associated with a MarshalSignalMap table, and the table itself.\nParameters map (MarshalSignalMap*) A MarshalSignalMap list (Null-Terminated-List, indicated by member name). marshal_signalmap_in Marshal a MarshalGroup inwards (from the marshal target).\nSignal \u003c-[marshal_signalmap_in()]- Source -\u003e Target\nParameters map (MarshalSignalMap*) A MarshalSignalMap list (Null-Terminated-List, indicated by member name). marshal_signalmap_out Marshal a MarshalSignalMap outwards (towards the marshal target).\nSignal -[marshal_signalmap_out()]-\u003e Source -\u003e Target\nParameters map (MarshalSignalMap*) A MarshalSignalMap list (Null-Terminated-List, indicated by member name). marshal_type_size Return the size of a MarshalType (in bytes).\nParameters type (MarshalType*) A marshal type. Returns size_t The size of the type (in bytes). ","categories":"","description":"","excerpt":"Marshal API The Marshal API supports two modes of operation: …","ref":"/dse.doc/apis/clib/marshal/","tags":"","title":"Marshal API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/mcl/","tags":"","title":"MCL"},{"body":"FMI Model Compatibility Library The FMI Model Compatibility Library provides an interfaces for loading and operating FMUs.\nSequence Diagram @startuml fmimcl-sequence title FMI MCL - Sequence actor User participant ModelC participant MCL participant MARSHAL participant FMIMCL participant ENGINE participant ADAPTER participant COMPONENT User -\u003e ModelC : model_create() activate ModelC ModelC -\u003e MCL : MCL_create() activate MCL MCL -\u003e FMIMCL : fmimcl_parse() activate FMIMCL FMIMCL -\u003e FMIMCL : parse yaml FMIMCL -\u003e MCL deactivate FMIMCL MCL -\u003e FMIMCL : fmimcl_adapter_create() activate FMIMCL FMIMCL -\u003e ADAPTER : adapter_create() activate ADAPTER ADAPTER -\u003e ADAPTER : set adapter functions ADAPTER -\u003e FMIMCL deactivate ADAPTER FMIMCL -\u003e MCL deactivate FMIMCL MCL-\u003e ENGINE: fmimcl_allocate_scalar_source() activate ENGINE ENGINE-\u003e MCL deactivate ENGINE MCL-\u003e ENGINE: fmimcl_generate_marshal_table() activate ENGINE ENGINE-\u003e MCL deactivate ENGINE MCL -\u003e ModelC deactivate MCL ModelC -\u003e MCL : MCL_load() activate MCL group Generate MarshalSignalMap list ||| MCL -\u003e MCL++ loop for each SignalVector MCL -\u003e MARSHAL : marshal_generate_signalmap() activate MARSHAL MARSHAL -\u003e MCL deactivate MARSHAL end return NTL ||| end MCL -\u003e ADAPTER : adapter_load() activate ADAPTER ADAPTER -\u003e COMPONENT : load_functions() activate COMPONENT COMPONENT -\u003e ADAPTER deactivate COMPONENT ADAPTER -\u003e MCL deactivate ADAPTER MCL -\u003e ModelC deactivate MCL ModelC -\u003e MCL : mcl_init() activate MCL MCL -\u003e ADAPTER : adapter_init() activate ADAPTER ADAPTER -\u003e COMPONENT : do_init() activate COMPONENT COMPONENT -\u003e ADAPTER deactivate COMPONENT ADAPTER -\u003e MCL deactivate ADAPTER MCL -\u003e ModelC deactivate MCL ModelC -\u003e User deactivate ModelC User -\u003e ModelC : model_step() activate ModelC ModelC -\u003e MCL : mcl_marshal_out() activate MCL MCL -\u003e MARSHAL : marshal_signalmap_out() activate MARSHAL MARSHAL -\u003e MCL deactivate MARSHAL MCL -\u003e ADAPTER : adapter_marshal_out() activate ADAPTER ADAPTER -\u003e MARSHAL : marshal_group_out() activate MARSHAL MARSHAL -\u003e ADAPTER deactivate MARSHAL ADAPTER -\u003e COMPONENT : set_variables() activate COMPONENT COMPONENT -\u003e ADAPTER deactivate COMPONENT ADAPTER -\u003e MCL deactivate ADAPTER MCL -\u003e ModelC deactivate MCL ModelC -\u003e MCL : mcl_step() activate MCL MCL -\u003e ADAPTER : adapter_step() activate ADAPTER ADAPTER -\u003e COMPONENT : do_step() activate COMPONENT COMPONENT -\u003e ADAPTER deactivate COMPONENT ADAPTER -\u003e MCL deactivate ADAPTER MCL -\u003e ModelC deactivate MCL ModelC -\u003e MCL : mcl_marshal_in() activate MCL MCL -\u003e ADAPTER : adapter_marshal_in() activate ADAPTER ADAPTER -\u003e COMPONENT : get_variables() activate COMPONENT COMPONENT -\u003e ADAPTER deactivate COMPONENT ADAPTER -\u003e MARSHAL : marshal_group_in() activate MARSHAL MARSHAL -\u003e ADAPTER deactivate MARSHAL ADAPTER -\u003e MCL deactivate ADAPTER MCL -\u003e MARSHAL : marshal_signalmap_in() activate MARSHAL MARSHAL -\u003e MCL deactivate MARSHAL MCL -\u003e ModelC deactivate MCL ModelC -\u003e User deactivate ModelC User -\u003e ModelC : model_destroy() activate ModelC ModelC -\u003e MCL : mcl_unload() activate MCL MCL -\u003e ADAPTER : adapter_unload() activate ADAPTER ADAPTER -\u003e MCL deactivate ADAPTER MCL -\u003e ModelC deactivate MCL ModelC -\u003e MCL : MCL_destroy() activate MCL MCL -\u003e FMIMCL: fmimcl_destroy() activate FMIMCL FMIMCL-\u003e MCL deactivate FMIMCL MCL -\u003e ModelC deactivate MCL ModelC -\u003e User deactivate ModelC center footer Dynamic Simulation Environment @enduml mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.\nParameters model (ModelDesc*) Model descriptor object. Returns MclDesc (pointer) Object representing the MCL Model, an extended ModelDesc type (derived from parameter model). NULL The MCL Model could not be created. Inspect errno for more details. Error Conditions Available by inspection of errno.\nmcl_destroy Releases memory and system resources allocated by mcl_create().\nParameters model (ModelDesc*) Model descriptor object. Typedefs FmuData typedef struct FmuData { int count; const char** name; struct { double* scalar; void** binary; } binary_len; int* kind; int* mg_table; } FmuModel typedef struct FmuModel { int mcl; const char* name; const char* version; int cosim; const char* guid; const char* resource_dir; const char* path; const char* handle; FmuSignal* signals; void* m_doc; void* adapter; FmuData data; struct { char* file_name; void* file; int* cg; int mdf; } measurement; } FmuSignal typedef struct FmuSignal { const char* name; uint32_t variable_vref; const char* variable_name; int variable_kind; int variable_dir; int variable_type; const char* variable_annotation_encoding; } Functions fmimcl_adapter_create This method creates an adapter object based on the configuration in the FMU Model object.\nParameters fmu_model (FmuModel*) FMU Model descriptor object. Returns 0 (int32_t) The related adapter was loaded by the fmimcl. -EINVAL (-22) No matching adapter found. fmimcl_allocate_source For each Signal parsed from the Signalgroup, this function creates an intermediate signal object for mapping between SignalVector and FMU Variable.\nParameters fmu_model (FmuModel*) FMU Model descriptor object. fmimcl_destroy Releases memory and system resources allocated by FMI Model Compatibility Library.\nParameters fmu_model (FmuModel*) FMU Model descriptor object. fmimcl_generate_marshal_table The FMU Signals are sorted according to the marshal groups. A source vector is already allocated of N signals. This function will create a marshal table, which is a mapping from the vector to a sequential list of signal blocks, each representing a marshal group.\nParameters fmu_model (FmuModel*) FMU Model descriptor object. fmimcl_load_encoder_funcs Parse the MarshalGroup NTL and for each Kind which supports an encoder function attempt to load the configured encoder functions to:\n.functions.string_encode .functions.string_decode Parameters fmu_model (FmuModel*) FMU Model descriptor object. fmimcl_parse This function parses the given yaml files into a FMU Model descriptor object and into a mapping list between the signals and FMU variables.\nParameters fmu_model (FmuModel*) FMU Model descriptor object. ","categories":"","description":"","excerpt":"FMI Model Compatibility Library The FMI Model Compatibility Library …","ref":"/dse.doc/apis/fmi/fmimcl/","tags":"","title":"FMI MCL API Reference"},{"body":"Model Compatibility Library API A Model Compatibility Library provides an interface for supporting 3rd-party model interfaces in a DSE Simulation.\nComponent Diagram @startuml mcl-interface skinparam nodesep 55 skinparam ranksep 40 title MCL Interface component \"Model\" as m1 component \"Model\" as m2 interface \"SimBus\" as SBif m1 -left-\u003e SBif m2 -right-\u003e SBif package \"MCL\" { component \"Runtime\" as ModelC component \"MCL\" as Mcl interface \"ModelVTable\" as MVt interface \"MclVTable\" as MclVt component \"MCL Lib\" as MclLib } MclLib -up- MclVt MclLib -up- MVt SBif \u003c-down- ModelC MVt )-up- ModelC MclVt )-up- Mcl component \"Model\" as MclModel interface \"Model I/F\" as ModelIf MclModel -up- ModelIf ModelIf )-up- MclLib center footer Dynamic Simulation Environment @enduml Typedefs MclDesc typedef struct MclDesc { int model; const char* adapter; const char* version; MclVTable vtable; double step_size; double model_time; double model_time_correction; struct { int count; const char** signal; struct { double* scalar; void** binary; } binary_len; int* kind; } source; int* msm; uint64_t [4] __reserved__; } MclVTable typedef struct MclVTable { MclLoad load; MclInit init; MclStep step; MclMarshalOut marshal_out; MclMarshalIn marshal_in; MclUnload unload; void *[2] __reserved__; } Functions mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.\nImplemented by MCL.\nParameters model (ModelDesc*) Model descriptor object. Returns MclDesc (pointer) Object representing the MCL Model, an extended ModelDesc type (derived from parameter model). NULL The MCL Model could not be created. Inspect errno for more details. Error Conditions Available by inspection of errno.\nmcl_destroy Releases memory and system resources allocated by mcl_create().\nImplemented by MCL.\nParameters model (ModelDesc*) Model descriptor object. mcl_init This method calls the MCL init() method which initialises the Model being represented by this MCL instance.\nParameters model (MclDesc*) The MCL Descriptor object representing an instance of the MCL Model. Returns 0 (int32_t) The represented model was initialised by the MCL. -EINVAL (-22) Bad model argument. mcl_load This method calls the MCL load() method which in turn loads the Model being represented by this MCL instance.\nParameters model (MclDesc*) The MCL Descriptor object representing an instance of the MCL Model. Returns 0 (int32_t) The related model was loaded by the MCL. -EINVAL (-22) Bad model argument. mcl_marshal_in This method calls the MCL marshal_in() method which in turn marshals signals inwards, from the Model represented by this MCL instance.\nParameters model (MclDesc*) The MCL Descriptor object representing an instance of the MCL Model. Returns 0 (int32_t) Signals were marshalled inwards from the Model represented by the MCL. -EINVAL (-22) Bad model argument. mcl_marshal_out This method calls the MCL marshal_out() method which in turn marshals signals outwards, towards the Model represented by this MCL instance.\nParameters model (MclDesc*) The MCL Descriptor object representing an instance of the MCL Model. Returns 0 (int32_t) Signals were marshalled outwards to the Model represented by the MCL. -EINVAL (-22) Bad model argument. mcl_step This method calls the MCL step() method to advance the Model represented by this MCL instance to the simulation time specifed by the parameter end_time.\nParameters model (MclDesc*) The MCL Descriptor object representing an instance of the MCL Model. Returns 0 (int32_t) The represented model was stepped by the MCL to the specified end_time. -1 The model time is advanced beyond the current simulation time. -EINVAL (-22) Bad model argument. mcl_unload This method calls the MCL unload() method which unloads the Model represented by this MCL instance.\nParameters model (MclDesc*) The MCL Descriptor object representing an instance of the MCL Model. Returns 0 (int32_t) The represented model was unloaded by the MCL. -EINVAL (-22) Bad model argument. ","categories":"","description":"","excerpt":"Model Compatibility Library API A Model Compatibility Library provides …","ref":"/dse.doc/apis/modelc/mcl/","tags":"","title":"MCL API Reference"},{"body":"MDF API The MDF API (a part of the DSE C Lib) provides methods for creating an MDF4 data stream. Data is saved according to the ASAM Standards.\nBecause of the streaming design the exact number of samples written to an MDF file is not known when the MDF file is initially created. Accordingly, to indicate this condition, the follwing flags are set in the MDF file:\nUpdate of cycle counters for CG-/CABLOCK required. Update of length for last DTBLOCK required. Block Order Diagram Note: Repeating elements are marked in blue.\nExample The following example demonstrates how to use the MDF API for a simple arrays based data source.\n// Copyright 2024 Robert Bosch GmbH #include \u003cstdint.h\u003e #include \u003cstdio.h\u003e #include \u003cdse/clib/mdf/mdf.h\u003e #define ARRAY_SIZE(x) (sizeof((x)) / sizeof((x)[0])) void mdf_api_example(void) { const char* signal[] = { \"SigA\", \"SigB\", \"SigC\", \"SigD\" }; double scalar[] = { 0, 1, 2, 3 }; // Configure the MDF Channel Groups. MdfChannelGroup groups[] = { { .name = \"Physical\", .signal = signal, .scalar = scalar, .count = ARRAY_SIZE(signal), }, }; // Open a file stream for writing MDF data. FILE* f = fopen(\"tsetfile.MF4\", \"w\"); // Create the MDF Descriptor. MdfDesc mdf = mdf_create(f, groups, ARRAY_SIZE(groups)); // Write a number of samples to the MDF file stream. mdf_start_blocks(\u0026mdf); for (double timestamp = 0.0; timestamp \u003c 0.010; timestamp += 0.0005) { for (size_t i = 0; i \u003c ARRAY_SIZE(scalar); i++) { scalar[i] += 1; } mdf_write_records(\u0026mdf, timestamp); } // Close the file stream. fclose(f); } Typedefs MdfChannelGroup typedef struct MdfChannelGroup { const char* name; size_t count; int record_count; const char** signal; double* scalar; int record_id; } MdfDesc typedef struct MdfDesc { FILE* file; size_t offset; struct { MdfChannelGroup* list; size_t count; } channel; } Functions mdf_create Create and configure an MdfDesc object to represent an MDF stream.\nParameters file (void*) File stream pointer. list (MdfChannelGroup*) Pointer to a list of MdfChannelGroup objects which specifies the MDF channel and signal source. count (size_t) Number of objects in the list. Returns MdfDesc (struct) MdfDesc object. mdf_start_blocks Write the start blocks of an MDF4 file to the MDF file stream.\nParameters mdf (MdfDesc*) MdfDesc object. mdf_write_records Write the current channel samples to the MDF file stream.\nParameters mdf (MdfDesc*) MdfDesc object. timestamp (double) Timestamp to apply for this set of samples. ","categories":"","description":"","excerpt":"MDF API The MDF API (a part of the DSE C Lib) provides methods for …","ref":"/dse.doc/apis/clib/mdf/","tags":"","title":"MDF API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/model/","tags":"","title":"Model"},{"body":"Model API The Model API allows model developers and integrators to implement models which can be connected to a Simulation Bus. Models are able to exchange signals with other models via this connection to a Simulation Bus. A runtime environment, such as the ModelC Runtime/Importer, will load the model and also manages the connection with the Simulation Bus.\nThe Model API provides two simple interfaces which facilitate the development of models; the Model Interface which is concerned with the model lifecycle; and the Signal Interface which facilitates signal exchange.\nModel Interface The Model Interface provides the necessary types, methods and objects required for implementing a model. Such a model can easily participate in a simulation by being connecting to a Simulation Bus (using the ModelC Importer) and then exchanging signals with other models in that simulation by using the provided SignalVector objects (which represent those signals).\nAdditionally, model implementers may extend or modify the Model Interface to support more complex integrations.\nSignal Vector Interface Models exchange signals via the Simulation Bus using a Signal Vector. Signal Vectors represent a logical grouping of signals (e.g. a collection of signals belonging to an ECU interface or bus). They are defined by a SignalGroup schema kind and may be configured to represent either either scalar (double, int, bool) or binary values.\nComponent Diagram @startuml model-interface skinparam nodesep 55 skinparam ranksep 40 title Model Interface component \"Model\" as m1 component \"Model\" as m2 interface \"SimBus\" as SBif m1 -left-\u003e SBif m2 -right-\u003e SBif package \"Model\" { component \"Runtime\" as ModelC interface \"ModelVTable\" as Mvt component \"Model\" as Mdl } SBif \u003c-down- ModelC Mdl -up- Mvt Mvt )-up- ModelC center footer Dynamic Simulation Environment @enduml Example (Model Interface) #include \u003cerrno.h\u003e #include \u003cstddef.h\u003e #include \u003cdse/modelc/model.h\u003e #define UNUSED(x) ((void)x) ModelDesc* model_create(ModelDesc* m) { return (ModelDesc*)m; } int model_step(ModelDesc* m, double* model_time, double stop_time) { ModelSignalIndex counter = m-\u003eindex(m, \"data\", \"counter\"); if (counter.scalar == NULL) return -EINVAL; *(counter.scalar) += 1; *model_time = stop_time; return 0; } void model_destroy(ModelDesc* m) { UNUSED(m); } Example (Signal Vector Interface) #include \u003cstring.h\u003e #include \u003cdse/modelc/model.h\u003e #include \u003cdse/logger.h\u003e #define UNUSED(x) ((void)x) int model_step(ModelDesc* m, double* model_time, double stop_time) { SignalVector* sv = m-\u003esv; while (sv \u0026\u0026 sv-\u003ename) { log_debug(\"Signal Vector : %s\", sv-\u003ename); for (uint32_t i = 0; i \u003c sv-\u003ecount; i++) { log_debug(\" signal : %s\", sv-\u003esignal[i]); if (sv-\u003eis_binary) { log_debug(\" length : %s\", sv-\u003elength[i]); log_debug(\" buffer_size : %s\", sv-\u003ebuffer_size[i]); log_debug(\" mime_type : %s\", sv-\u003emime_type[i]); // Example use of object functions. void* data = strdup(\"foo\"); signal_reset(sv, i); signal_append(sv, i, data, strlen(\"foo\")); free(data); signal_release(sv, i); const char* mime_type = signal_annotation(sv, i, \"mime_type\", NULL); if (mime_type) log_debug(\" annotation : %s\", mime_type); } else { log_debug(\" scalar : %s\", sv-\u003escalar[i]); } } // Next signal vector. sv++; } *model_time = stop_time; return 0; } Typedefs ModelDesc typedef struct ModelDesc { ModelIndex index; SimulationSpec* sim; ModelInstanceSpec* mi; SignalVector* sv; ModelVTable vtable; uint64_t [4] __reserved__; } ModelSignalIndex typedef struct ModelSignalIndex { SignalVector* sv; double* scalar; void** binary; uint32_t vector; uint32_t signal; } ModelVTable typedef struct ModelVTable { ModelCreate create; ModelStep step; ModelDestroy destroy; ModelIndex index; void *[2] __reserved__; } SignalVector typedef struct SignalVector { const char* name; const char* alias; const char* function_name; ModelInstanceSpec* mi; void* index; void* index_uid; uint32_t count; const char** signal; _Bool is_binary; struct { double* scalar; }; struct { void** binary; uint32_t* length; uint32_t* buffer_size; const char** mime_type; void** ncodec; _Bool* reset_called; } vtable; void** annotation; uint64_t [7] __reserved__; } SignalVectorVTable typedef struct SignalVectorVTable { BinarySignalAppendFunc append; BinarySignalResetFunc reset; BinarySignalReleaseFunc release; SignalAnnotationGetFunc annotation; BinarySignalCodecFunc codec; SignalGroupAnnotationGetFunc group_annotation; void *[2] __reserved__; } Functions model_annotation Retrieve the specified annotation from the Model specification.\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. name (const char*) The name of the annotation. Returns const char* The value of the specified annotation. NULL The specified annotation was not found. model_create Optional method of ModelVTable interface.\nCalled by the Model Runtime to create a new instance of this model.\nThe model_create() method may extend or mutilate the provided Model Descriptor. When extending the Model Descriptor and allocating additional resources then the model_destroy() method should also be implemented.\nFault conditions can be communicated to the caller by setting variable errno to a non-zero value. Additionally, log_fatal() can be used to immediately halt execution of a model.\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. Returns NULL The Channel was configured. (ModelDesc*) Pointer to a new, or mutilated, version of the Model Descriptor object. The original Model Descriptor object will be released by the Model Runtime (i.e. don’t call free()). errno \u003c\u003e 0 (indirect) Indicates an error condition. Example #include \u003cstddef.h\u003e #include \u003cstring.h\u003e #include \u003cdse/modelc/model.h\u003e #include \u003cdse/logger.h\u003e typedef struct { ModelDesc model; /* Signal Pointers. */ struct { double* counter; } signals; } ExtendedModelDesc; static inline double* _index(ExtendedModelDesc* m, const char* v, const char* s) { ModelSignalIndex idx = signal_index((ModelDesc*)m, v, s); if (idx.scalar == NULL) log_fatal(\"Signal not found (%s:%s)\", v, s); return idx.scalar; } ModelDesc* model_create(ModelDesc* model) { /* Extend the ModelDesc object (using a shallow copy). */ ExtendedModelDesc* m = calloc(1, sizeof(ExtendedModelDesc)); memcpy(m, model, sizeof(ModelDesc)); /* Index the signals that are used by this model. */ m-\u003esignals.counter = _index(m, \"data\", \"counter\"); /* Set initial values. */ *(m-\u003esignals.counter) = 42; /* Return the extended object. */ return (ModelDesc*)m; } int model_step(ModelDesc* model, double* model_time, double stop_time) { ExtendedModelDesc* m = (ExtendedModelDesc*)model; *(m-\u003esignals.counter) += 1; *model_time = stop_time; return 0; } model_destroy Optional method of ModelVTable interface.\nCalled by the Model Runtime at the end of a simulation, the model_destroy() function may be implemented by a Model Integrator to perform any custom cleanup operations (e.g. releasing instance related resources, such as open files or allocated memory).\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. model_expand_vars Expand environment variables in a string according to typical shell variable expansion (i.e ${FOO} or ${BAR:-default}). Environment variables are searched first with the Model Instance Name prefixed to the variable name with a “__” delimiter (i.e. “INSTANCE_NAME__ENVAR”), and then if no match is found, the search is repated with only the provied variable name.\nNote: Variables are converted to upper case before searching the environment.\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. source (const char*) The string containing environment variables to expand. Returns char* String with environment variables expanded. Caller to free. model_index_ Provided method (by the Runtime). Model implementers may specify a different index method by mutilating the Model Descriptor in the model_create() method, or even at runtime.\nA model may use this method to index a signal that is contained within the Signal Vectors of the Model Descriptor.\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. vname (const char*) The name (alias) of the Signal Vector. sname (const char*) The name of the signal within the Signal Vector. When set to NULL the index will match on Signal Vector (vanme) only. Returns ModelSignalIndex An index. When valid, either the scalar or binary fields will be set to a valid pointer (i.e. not NULL). When sname is not specified the index will contain a valid pointer to a Signal Vector object only (i.e. both scalar and binary will be set to NULL). model_instance_annotation Retrieve the specified annotation from the Model instance (Stack specification).\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. name (const char*) The name of the annotation. Returns const char* The value of the specified annotation. NULL The specified annotation was not found. model_step Mandatory method of ModelVTable interface. Alternatively, Model implementers may specify the ModelVTable.step method dynamically by mutilating the Model Descriptor in the model_create() method, or even at runtime.\nCalled by the Model Runtime to step the model for a time interval.\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. model_time (double*) (in/out) Specifies the model time for this step of the model. stop_time (double) Specifies the stop time for this step of the model. The model step should not exceed this time. Returns 0 The step completed without error. \u003c\u003e0 An error occurred at some point during the step execution. model_time (via parameter) The final model time reached for this step. This value may be less than stop_time if a step decides to return early. signal_annotation Get an annotation from a signal definition.\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. name (const char*) The name of the annotation. Returns const char* The annotation value. NULL The requested annotation was not found, inspect errno for additional information.. Example (Annotation Specification) kind: SignalGroup metadata: name: data spec: signals: - signal: counter annotations: initial_value: 10 Example (Code Usage) #include \u003cstdlib.h\u003e #include \u003cdse/modelc/model.h\u003e ModelDesc* model_create(ModelDesc* m) { ModelSignalIndex idx = m-\u003eindex(m, \"data\", \"counter\"); if (idx.scalar) { /* Set initial value. */ const char* v = signal_annotation(idx.sv, idx.signal, \"initial_value\", NULL); if (v) *(idx.scalar) = atoi(v); } return m; } signal_append Append data to the end of the specified binary signal. The append method will resize the buffers of the binary signal as required.\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. data (uint8_t*) Address/pointer to the data which should be appended to the binary signal. len (size_t) Length of the provided data buffer being appended. Returns 0 The operation completed without error. -EINVAL (-22) Bad arguments. -ENOSYS (-88) The called function is not available. \u003c\u003e0 Indicates an error condition. Inspect errno for additional information. signal_codec Return a pointer to the Codec object associated with a binary signal.\nCodec objects are created when a binary signal is specified with a mime_type annotation.\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. Returns void* The Codec object associated with the binary signal. NULL The binary signal does not have an associated Codec object, inspect errno for additional information.. Example (Codec Specification) kind: SignalGroup metadata: name: network labels: channel: network_vector annotations: vector_type: binary spec: signals: - signal: can_bus annotations: mime_type: application/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=2; interface_id=3 Reference Network Codec API\nsignal_group_annotation Get an annotation from a signal group.\nParameters sv (SignalVector*) The Signal Vector object representing the signal group. name (const char*) The name of the annotation. Returns const char* The annotation value. NULL The requested annotation was not found, inspect errno for additional information.. signal_index A model may use this method to index a signal that is contained within the Signal Vectors of the Model Descriptor.\nParameters model (ModelDesc*) The Model Descriptor object representing an instance of this model. vname (const char*) The name (alias) of the Signal Vector. name (const char*) The name of the signal within the Signal Vector. When set to NULL the index will match on Signal Vector (vanme) only. Returns ModelSignalIndex An index. When valid, either the scalar or binary fields will be set to a valid pointer (i.e. not NULL). When sname is not specified the index will contain a valid pointer to a Signal Vector object only (i.e. both scalar and binary will be set to NULL). signal_read Read data from the specified binary signal. Returns pointer to the internal binary signal buffers.\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. data (uint8_t*) Address/pointer to the data of the binary signal. len (size_t) Length of the data. Returns 0 The operation completed without error. -EINVAL (-22) Bad arguments. \u003c\u003e0 Indicates an error condition. Inspect errno for additional information. signal_release Release the resources allocated to a binary signal (e.g. free the buffer).\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. Returns 0 The operation completed without error. -EINVAL (-22) Bad arguments. -ENOSYS (-88) The called function is not available. \u003c\u003e0 Indicates an error condition. Inspect errno for additional information. signal_reset Reset a binary signal (e.g. sets its buffer length to 0). The buffers of the binary signal are not released (see signal_release()).\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. Returns 0 The operation completed without error. -EINVAL (-22) Bad arguments. -ENOSYS (-88) The called function is not available. \u003c\u003e0 Indicates an error condition. Inspect errno for additional information. signal_reset_called Indicate if reset has been called, and thusly its contained data consumed (by the caller).\nParameters sv (SignalVector*) The Signal Vector object containing the signal. index (uint32_t) Index of the signal in the Signal Vector object. reset_called (bool*) (out) The reset_called value of the specified binary signal. Returns 0 The operation completed without error. -EINVAL (-22) Bad arguments. \u003c\u003e0 Indicates an error condition. Inspect errno for additional information. ","categories":"","description":"","excerpt":"Model API The Model API allows model developers and integrators to …","ref":"/dse.doc/apis/modelc/model/","tags":"","title":"Model API Reference"},{"body":"(v0.0.1)\nModel kind: Model metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: runtime: dynlib: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 executable: - os: string arch: string libs: - string annotations: ? property1 ? property2 gateway: annotations: ? property1 ? property2 mcl: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 This schema object defines a Model kind. A Model kind is used to define a model which participates within a DSE based simulation.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec ModelSpec true none Enumerated Values Property Value kind Model ModelSpec runtime: dynlib: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 executable: - os: string arch: string libs: - string annotations: ? property1 ? property2 gateway: annotations: ? property1 ? property2 mcl: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 Properties Name Type Required Description runtime object false Selects (or defines) the kind of runtime that a particular model implements. In some cases several runtimes of a particular type may be defined according to operating system architecture. » dynlib [LibrarySpec] false Dynamic Library runtime specifications. » executable [ExecutableSpec] false Executable runtime specifications. » gateway GatewaySpec false Defines a Gateway Model which represents a connection from a remote simulation system. The remote system loads a model which includes the ModelC Gateway functionality, that model is then able to connect to a DSE based simulation using the ModelC Gateway functionality.\nThe remote system may be a different type of simulation environment. » mcl [LibrarySpec] false Model Compatibility Library runtime specifications. channels [object] false A list of channels belonging to this model. » name string false The name of the channel, used when connecting this channel to the SimBus. » alias string false The alias of the channel, used when the channel name will be determined elsewhere. » expectedModelCount integer false Indicates how many models are expected to connect to this channel (used by SimBus only). » selectors object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none LibrarySpec path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 Defines a Model which is implemented as a dynamic library. The model defined here will be loaded by an appropriate runtime executable, that executable provides all necessary library functions related to the DSE simulation environment. Addition libraries may be specified via the libs property.\nProperties Name Type Required Description path string true The relative (to the model package) path to the runtime artifact. os string false Indicate the operating system of the runtime (e.g. linux, windows). arch string false Indicate the architecture of the runtime (e.g. amd64, w32) variant string false Indicate the architecture sub variant of the runtime (e.g. v7) libs [string] false A list of libraries on which the runtime is dependant. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties any false none GatewaySpec annotations: ? property1 ? property2 Defines a Gateway Model which represents a connection from a remote simulation system. The remote system loads a model which includes the ModelC Gateway functionality, that model is then able to connect to a DSE based simulation using the ModelC Gateway functionality. The remote system may be a different type of simulation environment.\nProperties Name Type Required Description annotations LibrarySpec/properties/annotations false Non identifying information (i.e. information specific to the object itself). ExecutableSpec os: string arch: string libs: - string annotations: ? property1 ? property2 Defines a model implemented in an executable. The functions representing the model functionality will be taken directly from linked symbols in the executable file.\nProperties Name Type Required Description os string false Indicate the operating system of the executable (e.g. linux, windows). arch string false Indicate the architecture of the executable (e.g. amd64, w32) libs [string] false A list of libraries on which the executable is dependant. The executable would load each of the listed libraries. annotations LibrarySpec/properties/annotations false Non identifying information (i.e. information specific to the object itself). undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nModel kind: Model metadata: name: string labels: property1: …","ref":"/dse.doc/schemas/yaml/model/","tags":["Schema"],"title":"Schema: Model"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/modelc/","tags":"","title":"ModelC"},{"body":"GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB debugging with the following technique:\nIn the main Makefile, add the GDB_CMD environment variable (i.e. --env GDB_CMD=\"$(GDB_CMD)\") to every DOCKER_CMD that requires interactive GDB debugging support.\nFor each Makefile run target where interactive GDB debugging is required, prefix the run command with the GDB_CMD variable, for example: cd build/_out; $(GDB_CMD) bin/test_tdd.\nSet the GDB_CMD environment variable with your GDB command (e.g. export GDB_CMD=\"gdb -ex run\").\nExecute your Makefile run target, which will start in GDB according to the configuration in GDB_CMD.\nA few simple GDB commands:\nbt - backtrace. frame x - move to stack frame x (where x is from output of bt command). print x - print the value of variable x. list - list the code around the current stopped point. quit - exit GDB. Hint: this technique is particularly helpful when working with CMocka based Test Cases.\nExample GDB_CMD settings:\n# Run GDB. $ export GDB_CMD=\"gdb -q -ex run\" # Run GDB and exit if the program finished without error. $ export GDB_CMD=\"gdb -q -ex='set confirm on' -ex=run -ex=quit\" Example Makefile:\n# Docker CMDS (shortened example). ifneq ($(CI), true) DOCKER_BUILDER_CMD := docker run -it --rm \\ --volume $$(pwd):/tmp/repo \\ ... --env GDB_CMD=\"$(GDB_CMD)\" \\ --workdir /tmp/repo \\ $(GCC_BUILDER_IMAGE) endif # Run target. run: cd build/_out; $(GDB_CMD) bin/test_tdd ModelC Integration with GDB in Docker Environment When developing parts of the Model C Library it is occasionally necessary to run the various elements under GDB. The Docker based build environment can be configured to do this, and there are several Makefile targets which help in establishing that environment.\nExact commands to run SimBus and ModelC can be taken from the output of unit/integration tests.\nStart Docker Environment (Terminal 1) This command creates a Docker Network, starts a Redis Container, and then starts a Docker Build Container ready for use. The current directory of the repo is also mapped into the container at /tmp/repo.\n:~/git/dse/dse.modelc$ make test-env 433d62be46ba4a2af17a03754e240e4e2774a093bceb86bed875dc0c4c9e7ec0 dse 658d227bbdf354525c31d930b9b045c867898498cd37fd3fbbae12e0aec626ca a035f2d928d18d4df4cfb2215d65e0f75abfb8a9fcdb5f52904d8fff115c4286 :/tmp/repo# ls dse/modelc/build/_out/ bin data examples include lib licenses root@c5e03415542a:/tmp/repo# Connect to Docker Environment and start SimBus (Terminal 2) :~/git/dse/dse.modelc$ make test-env-it docker exec -it --workdir /tmp/repo modelc_testenv /bin/bash :/tmp/repo# cd /tmp/repo/dse/modelc/build/_out/examples/binary :/tmp/repo/dse/modelc/build/_out/examples/binary# gdb --args /tmp/repo/dse/modelc/build/_out/bin/simbus --logger 2 --timeout 1 stack.yaml (gdb) run Starting program: /tmp/repo/dse/modelc/build/_out/bin/simbus --logger 2 --timeout 1 stack.yaml Version: 0.0.2 ... Start the Bus ... Connect to Docker Environment and start ModelC (Terminal 3) :~/git/dse/dse.modelc$ make test-env-it docker exec -it --workdir /tmp/repo modelc_testenv /bin/bash :/tmp/repo# cd /tmp/repo/dse/modelc/build/_out/examples/binary :/tmp/repo/dse/modelc/build/_out/examples/binary# gdb --args /tmp/repo/dse/modelc/build/_out/bin/modelc --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml (gdb) run Starting program: /tmp/repo/dse/modelc/build/_out/bin/modelc --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml Version: 0.0.2 Platform: linux-amd64 ... Model function model_setup called Configure Channel: binary_channel Channel Name: Network Channel Alias: binary_channel [INFO] signal[0] : RAW (_load_signals:259) Unique signals identified: 1 Init Controller channel: Network Pub Key: bus.ch.Network.tx Sub Key: bus.ch.Network.rx [INFO] Allocate signal vector type 1 for 1 signals. (model_configure_channel:405) [FATAL] Binary vector not allocated! (model_setup:94) [Inferior 1 (process 37) exited with code 0175] (gdb) General GDB commands bt frame up down info locals info args GDB Server ModelC can be debugged using GDB Server which enables remote debugging - where the program being debugged runs on a remote system while debugger (and debugging symbols) are running on the local system.\nRun ModelC with GDB Server GDB Server can be started on a target system a number of ways. For the debugger to connect to the running GDB Server instance requires connectivity via port 2159.\nNote: In each of the following examples it is assumed that the container images have been built locally and include the same executable files in both local and remote (in container) systems.\n# GDB Server via 'simer'. $ simer dse/modelc/build/_out/examples/minimal -endtime 0.04 -gdb minimal_inst # GDB Server with standalone command. $ gdbserver localhost:2159 dse/modelc/build/_out/bin/modelc --name instance model.yaml simulation.yaml # GDB Server with docker compose. $ cat docker-compose.yaml --- version: \"1.0\" services: ... modelc: image: dse-modelc:test volumes: - ./:/tmp/repo - /usr/bin/gdbserver:/tmp/repo/gdbserver container_name: \"modelc\" working_dir: /tmp/repo command: gdbserver localhost:2159 dse/modelc/build/_out/bin/modelc --name instance model.yaml simulation.yaml ports: - 2159:2159 ... $ docker-compose up Connect to remote ModelC Note: solib-search-path should be set to the local path (relative to the running remote executable).\n$ gdb dse/modelc/build/_out/bin/modelc (gdb) set solib-search-path ./ (gdb) target remote localhost:2159 (gdb) continue (gdb) bt Dynamic Linking Linux Dynamic linking on Linux can be debugged with the following commands:\n# Use the runtime example. $ cd dse/modelc/build/_out/examples/runtime # Read the Dynamic Linking data fields. $ readelf -d lib/libruntime.so Dynamic section at offset 0x2df0 contains 27 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libmodel_runtime.so] 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000e (SONAME) Library soname: [libruntime.so] 0x000000000000001d (RUNPATH) Library runpath: [lib] **** set via CMake **** ... # Monitor the loading process: $ LD_DEBUG=libs bin/importer lib/libruntime.so sim data/simulation.yaml target_inst ... # Monitor and inject a search path: $ LD_DEBUG=libs LD_LIBRARY_PATH=./lib bin/importer lib/libruntime.so sim data/simulation.yaml target_inst ... Adjust ‘runpath’ with CMake Use the INSTALL_RPATH target property to set the runpath. This value can be a list of paths: lib:resources/lib. Those paths would be relative to the working directory of the executable needing to load dynamic libraries.\nset_target_properties(runtime PROPERTIES INSTALL_RPATH \"lib\" ) Windows Windows will load dynamic linked libraries which have been placed in the folder as other libraries.\nGLib C Docker A common problem is that a binary build on your laptop/WSL is then installed inside a container where the GLib version is different (usually because a different OS revision/version). This can happen indirectly.\n/usr/local/bin/gateway: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.34' not found (required by /usr/local/bin/gateway) /usr/local/bin/gateway: /lib/x86_64-linux-gnu/libc.so.6: version `GLIBC_2.32' not found (required by /usr/local/bin/gateway) This can be further detected/understood with this command:\nobjdump -T /usr/local/bin/gateway | grep GLIBC_ If using builder images, and mapping source trees into a container, then check to be sure that an executable built by the host system is not installed. The following example uses a clean make target to ensure a container local build.\nFROM golang:bookworm AS gateway ADD . /src RUN cd /src \u0026\u0026 make clean build ","categories":"","description":"","excerpt":"GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB …","ref":"/dse.doc/docs/devel/debug/modelc/","tags":["Developer","ModelC","GDB"],"title":"Model C Debug Techniques"},{"body":"FMI ModelC FMU The FMI ModelC FMU is and FMU which is capable of loading and running a DSE Simulation (e.g. a ModelC Simulation Stack). All capabilites of the ModelC Runtime are supported, including the exchange of binary signals (e.g. CAN) and realisation of bus topologies (e.g. multi-node CAN Networks).\nComponent Diagram @startuml fmimodelc-component title FMI ModelC FMU center footer Dynamic Simulation Environment @enduml default_log Default logging function in case the FMU caller does not provide any logger.\nfmi2ExitInitializationMode Initialise the Model Runtime (of the ModelC library) and in the process establish the simulation that this ModelC FMU is wrapping/operating.\nThis function will generate indexes to map between FMI Variables and ModelC Signals; both scaler signals (double) and binary signals (string/binary).\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. Returns fmi2OK (fmi2Status) The simulation that this FMU represents is ready to be operated. fmi2GetReal Get values for the provided list of value references.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to retrieve. nvr (int) The number of value references to retrieve. value (fmi2Real[]) Storage for the retrieved values. Returns fmi2OK (fmi2Status) The requested variables are retrieved (where available). fmi2GetString Get values for the provided list of value references.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to retrieve. nvr (int) The number of value references to retrieve. value (fmi2String[]) Storage for the retrieved values. Returns fmi2OK (fmi2Status) The requested variables are retrieved (where available). fmi2SetReal Set values for the provided list of value references and values.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to set. nvr (int) The number of value references to set. value (fmi2Real[]) Storage for the values to be set. Returns fmi2OK (fmi2Status) The requested variables have been set (where available). fmi2SetString Set values for the provided list of value references and values. String/Binary variables are always appended to the ModelC Binary Signal.\nNote: If several variables are indexed against the same ModelC Binary Signal, for instance in a Bus Topology, then each variable will be appended to that ModelC Binary Signal.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to set. nvr (int) The number of value references to set. value (fmi2String[]) Storage for the values to be set. Returns fmi2OK (fmi2Status) The requested variables have been set (where available). fmu_signals_reset Required by FMU.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmi2Instantiate Create an instance of this FMU, allocate/initialise a FmuInstanceData object which should be used for subsequent calls to FMI methods (as parameter fmi2Component c).\nNote: This implementation does not use memory related callbacks provided by the Importer (e.g. malloc() or free()).\nReturns fmi2Component (pointer) An FmuInstanceData object which represents this FMU instance. fmi2DoStep Set values for the provided list of value references and values. String/Binary variables are always appended to the ModelC Binary Signal.\nNote: If several variables are indexed against the same ModelC Binary Signal, for instance in a Bus Topology, then each variable will be appended to that ModelC Binary Signal.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. currentCommunicationPoint (fmi2Real) The model time (for the start of this step). communicationStepSize (fmi2Real) The model step size. noSetFMUStatePriorToCurrentPoint (fmi2Boolean) Not used. Returns fmi2OK (fmi2Status) The step completed. fmi2Error (fmi2Status) An error occurred when stepping the ModelC Simulation. fmi2FreeInstance Free memory and resources related to the provided FMU instance.\nParameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. fmu_signals_setup Placeholder to signal the FMU to not use the default signal allocation.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_signals_remove This method frees the allocated binary signal indexes.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_load_signal_handlers This method assigns the signal handler function to a vtable.\nParameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Typedefs Functions ","categories":"","description":"","excerpt":"FMI ModelC FMU The FMI ModelC FMU is and FMU which is capable of …","ref":"/dse.doc/apis/fmi/fmimodelc/","tags":"","title":"FMI ModelC FMU API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/ncodec/","tags":"","title":"NCodec"},{"body":"Network Codec A Network Codec has two interfaces: a Codec Interface which is used to encode/decode message from a Model/Device (connected to a Network), and a Stream Interface which is used to exchange the encoded messages with other Model/Devices connected to the same Network.\nThe Network Codec API (codec.h \u0026 codec.c) provides the framework for implementing both the Codec Interface and the Stream Interface. A typical realisation of this scheme would be:\nStream Implementation - provided by the Model Environment. Network Codec Implementation - provided by a Codec vendor. Model - using the Network Codec API to configure and use a Network, with the assistance of both the Network Codec and Stream implementations. Component Diagram @startuml ncodec-component title Network Codec package \"Model Environment\" { interface \"Signal Interface\" as Sif component \"Model\" as foo { component \"Model\" as Model interface \"CodecVTable\" as Cvt component \"Codec\" as Codec interface \"StreamVTable\" as Svt } component \"Stream\" as Stream interface \"Binary Interface\" as Bif component \"Codec Lib\" as lib } Sif )-down- Model Model -right-( Cvt Cvt -right- Codec Codec -right-( Svt Svt -right- Stream Stream -down-( Bif lib .up.\u003e Codec Model --\u003e lib :ncodec_open() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.0 #include \u003cstddef.h\u003e #include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cerrno.h\u003e #include \u003cdse/ncodec/codec.h\u003e #define MIMETYPE \"application/x-codec-example\" #define UNUSED(x) ((void)x) extern NCodecStreamVTable example_stream; static void trace_read(NCODEC* nc, NCodecMessage* m) { UNUSED(nc); NCodecCanMessage* msg = m; printf(\"TRACE RX: %02d (length=%lu)\\n\", msg-\u003eframe_id, msg-\u003elen); } static void trace_write(NCODEC* nc, NCodecMessage* m) { UNUSED(nc); NCodecCanMessage* msg = m; printf(\"TRACE TX: %02d (length=%lu)\\n\", msg-\u003eframe_id, msg-\u003elen); } int main(int argc, char* argv[]) { int rc; static const char* greeting = \"Hello World\"; if (argc \u003e 1) { rc = ncodec_load(argv[1], NULL); if (rc) { printf(\"Load failed (rc %d)\\n\", rc); return rc; } } NCODEC* nc = ncodec_open(MIMETYPE, (void*)\u0026example_stream); if (nc == NULL) { printf(\"Open failed (errno %d)\\n\", errno); return errno; } ncodec_config(nc, (struct NCodecConfigItem){ .name = \"name\", .value = \"simple network codec\" }); /* Install trace functions. */ NCodecInstance* _nc = (NCodecInstance*)nc; _nc-\u003etrace.read = trace_read; _nc-\u003etrace.write = trace_write; /* Write a message to the Network Codec. */ ncodec_write(nc, \u0026(struct NCodecCanMessage){ .frame_id = 42, .frame_type = CAN_EXTENDED_FRAME, .buffer = (uint8_t*)greeting, .len = strlen(greeting) }); ncodec_flush(nc); /* Reposition to start of stream. */ ncodec_seek(nc, 0, NCODEC_SEEK_SET); /* Read the response from the Network Codec. */ NCodecCanMessage msg = {}; rc = ncodec_read(nc, \u0026msg); if (rc \u003e 0) { printf(\"Message is: %s\\n\", (char*)msg.buffer); } else { printf(\"There was no message! (reason %d)\\n\", rc); } /* Close the Network Codec. */ ncodec_close(nc); return 0; } Typedefs NCodecCanMessage typedef struct NCodecCanMessage { uint32_t frame_id; uint8_t* buffer; size_t len; NCodecCanFrameType frame_type; uint64_t [2] __reserved__; struct { uint8_t bus_id; uint8_t node_id; uint8_t interface_id; } sender; struct { uint64_t send; uint64_t arb; uint64_t recv; } timing; } NCodecConfigItem typedef struct NCodecConfigItem { const char* name; const char* value; } NCodecInstance typedef struct NCodecInstance { const char* mime_type; NCodecVTable codec; NCodecStreamVTable* stream; NCodecTraceVTable trace; void* private; } NCodecPdu typedef struct NCodecPdu { uint32_t id; const uint8_t* payload; size_t payload_len; uint32_t swc_id; uint32_t ecu_id; NCodecPduTransportType transport_type; struct { struct ; struct (anonymous struct at dse/ncodec/codec.h:369:9) none; NCodecPduCanMessageMetadata can_message; NCodecPduIpMessageMetadata ip_message; NCodecPduStructMetadata struct_object; } transport; } NCodecPduCanMessageMetadata typedef struct NCodecPduCanMessageMetadata { NCodecPduCanFrameFormat frame_format; NCodecPduCanFrameType frame_type; uint32_t interface_id; uint32_t network_id; } NCodecPduDoIpAdapter typedef struct NCodecPduDoIpAdapter { uint8_t protocol_version; uint16_t payload_type; } NCodecPduIpAddrV4 typedef struct NCodecPduIpAddrV4 { uint32_t src_addr; uint32_t dst_addr; } NCodecPduIpAddrV6 typedef struct NCodecPduIpAddrV6 { uint16_t [8] src_addr; uint16_t [8] dst_addr; } NCodecPduIpMessageMetadata typedef struct NCodecPduIpMessageMetadata { uint64_t eth_dst_mac; uint64_t eth_src_mac; uint16_t eth_ethertype; uint8_t eth_tci_pcp; uint8_t eth_tci_dei; uint16_t eth_tci_vid; NCodecPduIpProtocol ip_protocol; NCodecPduIpAddr ip_addr_type; struct { struct ; struct (anonymous struct at dse/ncodec/codec.h:319:9) none; NCodecPduIpAddrV4 ip_v4; NCodecPduIpAddrV6 ip_v6; } ip_addr; uint16_t ip_src_port; uint16_t ip_dst_port; NCodecPduSoAd so_ad_type; struct { struct ; struct (anonymous struct at dse/ncodec/codec.h:329:9) none; NCodecPduDoIpAdapter do_ip; NCodecPduSomeIpAdapter some_ip; } so_ad; } NCodecPduSomeIpAdapter typedef struct NCodecPduSomeIpAdapter { uint32_t message_id; uint32_t length; uint32_t request_id; uint8_t protocol_version; uint8_t interface_version; uint8_t message_type; uint8_t return_code; } NCodecPduStructMetadata typedef struct NCodecPduStructMetadata { const char* type_name; const char* var_name; const char* encoding; uint16_t attribute_aligned; bool attribute_packed; const char* platform_arch; const char* platform_os; const char* platform_abi; } NCodecStreamVTable typedef struct NCodecStreamVTable { NCodecStreamRead read; NCodecStreamWrite write; NCodecStreamSeek seek; NCodecStreamTell tell; NCodecStreamEof eof; NCodecStreamClose close; } NCodecTraceVTable typedef struct NCodecTraceVTable { NCodecTraceWrite write; NCodecTraceRead read; } NCodecVTable typedef struct NCodecVTable { NCodecConfig config; NCodecStat stat; NCodecWrite write; NCodecRead read; NCodecFlush flush; NCodecTruncate truncate; NCodecClose close; } Functions ncodec_close Parameters nc (NCODEC*) Network Codec object. ncodec_config Set an additional parameter on a Network Codec. If the parameter is already specified in the MIMEtype of the codex, the value being set will take priority over the value originally specified in the MIMEtype.\nParameters nc (NCODEC*) Network Codec object. item (NetworkConfigItem) The config item being set. ncodec_create Implemented in Codec library.\nParameters mime_type (const char*) The MIMEtype specifier. Returns NCodecOpen (pointer) Returns a pointer to a codec function which can open the specified MIMEtype. NULL This codec library does not support the specified MIMEtype. ncodec_flush Parameters nc (NCODEC*) Network Codec object. Returns 0 The Network Codec internal buffers were flushed to the connected stream. -ENOSTR The object represented by nc does not represent a valid stream. -ENOSR No stream resource has been configured. ncodec_load Implemented by integrator.\nParameters filename (const char*) Name of the Network Codec library to load. hint (const char*) Optional path from where to load the Network Codec. Returns 0 The Network Codec library way successfully loaded. -1 The Network Codec library could not be loaded. Inspect errno for more details. ncodec_open Implemented by integrator.\nParameters name (const char*) A name associated with the codec instance being opened. mime_type (const char*) The MIMEtype specifier. Returns NCODEC (pointer) Object representing the Network Codec. NULL The Network Codec could not be created. Inspect errno for more details. Error Conditions Available by inspection of errno.\nELIBACC Static library(ies) not loaded. EINVAL Stream parameter not valid. ENODATA A Network Codec matching the MIMEtype could not be found. ENOENT The ncodec_create was not found in any loaded static library. ncodec_read Read messages from a Network Codex until the stream represented by the codec is fully consumed (i.e. no more messages).\nThe codec owns the message buffer/memory returned by this function. Messages should be consumed immediately within a sequence of calls to ncodec_read (e.g. until ENOMSG), or duplicate the messages for later processing.\nParameters nc (NCODEC*) Network Codec object. msg (NCodecMessage*) (out) The message representation to write to the Network Codec. Caller owns the message buffer/memory. Message type is defined by the codec implementation. Returns \u003cint32_t\u003e The number of bytes read from the Network Codec. Will be identical to the value returned in msg.len. Additional messages may remain on the Network Codec, after processing this message, repeat calls to ncodec_read until -ENOMSG is returned. -ENOMSG (-42) No message is available from the Network Codec. -ENOSTR (-60) The object represented by nc does not represent a valid stream. -ENOSR (-63) No stream resource has been configured. -EINVAL (-22) Bad msg argument. ncodec_seek Parameters nc (NCODEC*) Network Codec object. pos (size_t) Seek position relative to the seek operation. op (int32_t) Seek operation (NCodecStreamSeekOperation). Returns +ve The position in the underlying stream object after the seek operation. -ENOSTR (-60) The object represented by nc does not represent a valid stream. -EINVAL (-22) Bad msg argument. ncodec_stat Parameters nc (NCODEC*) Network Codec object. index (int32_t*) (out) Index of the config item returned by this call. When there are no more config items to be returned, this value is set to -1 and an empty NetworkConfigItem object is returned. Returns NetworkConfigItem A config item. ncodec_tell Parameters nc (NCODEC*) Network Codec object. Returns +ve The current position in the underlying stream object. -ENOSTR (-60) The object represented by nc does not represent a valid stream. -ENOSR (-63) No stream resource has been configured. ncodec_truncate Parameters nc (NCODEC*) Network Codec object. Returns 0 The Network Codec internal buffers were truncated. -ENOSTR The object represented by nc does not represent a valid stream. -ENOSR No stream resource has been configured. ncodec_write Write the provided message to the Network Codec object.\nThe caller owns the message buffer/memory and the codec implementation will encode (i.e. duplicate) the content of that message buffer/memory during this call.\nParameters nc (NCODEC*) Network Codec object. msg (NCodecMessage*) The message representation to write to the Network Codec. Caller owns the message buffer/memory. Message type is defined by the codec implementation. Returns +VE (int32_t) The number of bytes written to the Network Codec. Will be identical to the value provided in msg.len. -ENOSTR (-60) The object represented by nc does not represent a valid stream. -EINVAL (-22) Bad msg argument. ","categories":"","description":"","excerpt":"Network Codec A Network Codec has two interfaces: a Codec Interface …","ref":"/dse.doc/apis/ncodec/","tags":"","title":"Network Codec API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/network/","tags":"","title":"Network"},{"body":"Network Model The Network Model runs a Communication Stack which represents the connection between Physical Signals and Network Messages.\nTypedefs MarshalItem typedef struct MarshalItem { NetworkSignal* signal; NetworkMessage* message; size_t signal_vector_index; } Network typedef struct Network { const char* name; int* doc; NetworkMessage* messages; const char* message_lib_path; const char* function_lib_path; void* message_lib_handle; void* function_lib_handle; MarshalItem* marshal_list; size_t signal_count; const char** signal_name; double* signal_vector; NetworkScheduleItem* schedule_list; uint32_t tick; uint32_t bus_id; uint32_t node_id; uint32_t interface_id; } NetworkFunction typedef struct NetworkFunction { char* name; int* annotations; void* data; NetworkFunctionFunc function; } NetworkMessage typedef struct NetworkMessage { const char* name; uint32_t frame_id; uint8_t frame_type; NetworkSignal* signals; const char* container; uint32_t mux_id; NetworkSignal* mux_signal; void* buffer; size_t buffer_len; uint8_t cycle_time_ms; void* payload; uint8_t payload_len; uint32_t buffer_checksum; bool needs_tx; PackFunc pack_func; UnpackFunc unpack_func; bool update_signals; NetworkFunction* encode_functions; NetworkFunction* decode_functions; } NetworkScheduleItem typedef struct NetworkScheduleItem { NetworkMessage* message; uint32_t alarm; } NetworkSignal typedef struct NetworkSignal { const char* name; char* signal_name; const char* member_type; unsigned int buffer_offset; double init_value; bool internal; double value; bool mux_signal; MarshalItem* mux_mi; EncodeFuncInt8 encode_func_int8; EncodeFuncInt16 encode_func_int16; EncodeFuncInt32 encode_func_int32; EncodeFuncInt64 encode_func_int64; EncodeFuncFloat encode_func_float; EncodeFuncDouble encode_func_double; DecodeFuncInt8 decode_func_int8; DecodeFuncInt16 decode_func_int16; DecodeFuncInt32 decode_func_int32; DecodeFuncInt64 decode_func_int64; DecodeFuncFloat decode_func_float; DecodeFuncDouble decode_func_double; RangeFuncInt8 range_func_int8; RangeFuncInt16 range_func_int16; RangeFuncInt32 range_func_int32; RangeFuncInt64 range_func_int64; RangeFuncFloat range_func_float; RangeFuncDouble range_func_double; } Functions ","categories":"","description":"","excerpt":"Network Model The Network Model runs a Communication Stack which …","ref":"/dse.doc/apis/network/network/","tags":"","title":"Network API Reference"},{"body":"(v1.0.0)\nNetwork kind: Network metadata: name: CAN1 annotations: message_lib: examples/stub/data/message.so function_lib: examples/stub/data/function.so spec: messages: - message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t - signal: Alive annotations: struct_member_name: alive struct_member_offset: 1 struct_member_primitive_type: uint8 - signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t functions: encode: - function: counter_inc_uint8 annotations: position: 1 - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network definition.\nSupported annotations: Annotation Description message_lib Relative path of the shared library containing the Network Message symbols. function_lib Relative path of the shared library containing Network Function symbols. node_id The identifier of the Node used to indicate the sender of a network message. Typically specified in a mimeTYPE for the Network Signal, however a value may also be specified here. interface_id The identifier of the Interface of the Node used to send a network message. Typically specified in a mimeTYPE for the Network Signal, however a value may also be specified here. bus_id The identifier of the Bus connected to the Interface of the Node. Typically specified in a mimeTYPE for the Network Signal, however a value may also be specified here. Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec NetworkSpec true none Enumerated Values Property Value kind Network NetworkSpec messages: - message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t functions: encode: - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 Properties Name Type Required Description messages [NetworkMessage] true A list of messages belonging to this Network. NetworkMessage message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t functions: encode: - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network message definition.\nSupported annotations: Annotation Description struct_name Name of the typedef/struct representing the message. struct_size Size of the message struct (in bytes). frame_id The frame id of the message when encoded to a bus transport (e.g. CAN Frame ID). frame_length The length of the message when encoded (in bytes). cycle_time_ms Message will be sent according to the specified schedule (milliseconds). Properties Name Type Required Description message string true The name of the message. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties any false none signals [NetworkSignal] false A list of signals represented in this message. functions NetworkFunctions false Message functions to be applied to this message. NetworkSignal signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t A Network signal definition.\nSupported annotations: Annotation Description init_value The signal is initialised to this value. The value will be interpreted according to the struct_member_primitive_type annotation. struct_member_name Name of the struct member which represents this signal. struct_member_offset Offset of the member in the struct (in bytes). struct_member_primitive_type The primitive type of the member (select from int8_t, int16_t, int32_t, int64_t, uint8_t, uint16_t, uint32_t, uint64_t, float or double). Properties Name Type Required Description signal string true The name of the signal. annotations NetworkMessage/properties/annotations false Non identifying information (i.e. information specific to the object itself). NetworkFunctions encode: - \u0026a1 function: crc_generate annotations: position: 0 decode: - *a1 Message functions to be applied to this message.\nProperties Name Type Required Description encode [NetworkFunction] false Message functions applied to the encode processing path (i.e. from Signal to Network interface). Functions are implicitly applied in the order of definition. decode [NetworkFunction] false Message functions applied to the decode processing path (i.e. from Network to Signal interface). Functions are implicitly applied in the order of definition. NetworkFunction function: crc_generate annotations: position: 0 A Network Function definition.\nProperties Name Type Required Description function string true The name of the function (i.e. the name of the symbol in the Network Function shared library). annotations NetworkMessage/properties/annotations false Non identifying information (i.e. information specific to the object itself). undefined\n","categories":"","description":"","excerpt":"(v1.0.0)\nNetwork kind: Network metadata: name: CAN1 annotations: …","ref":"/dse.doc/schemas/yaml/network/","tags":["Schema"],"title":"Schema: Network"},{"body":"(v0.0.1)\nParameterSet kind: ParameterSet metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: parameters: - parameter: string value: string annotations: ? property1 ? property2 A parameter_set definition.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec ParameterSetSpec true none Enumerated Values Property Value kind ParameterSet ParameterSetSpec parameters: - parameter: string value: string annotations: ? property1 ? property2 Properties Name Type Required Description parameters [Parameter] true A list of parameters belonging to this parameter set. Parameter parameter: string value: string annotations: ? property1 ? property2 A signal parameter definition.\nProperties Name Type Required Description parameter string true The name of the parameter. value string false The value of the parameter. annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties any false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nParameterSet kind: ParameterSet metadata: name: string …","ref":"/dse.doc/schemas/yaml/parameterset/","tags":["Schema"],"title":"Schema: ParameterSet"},{"body":"(v0.0.1)\nPropagator kind: Propagator metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: options: direction: both signals: - signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A propagator definition.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec PropagatorSpec true none Enumerated Values Property Value kind Propagator PropagatorSpec options: direction: both signals: - signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 Properties Name Type Required Description options object false none » direction string false none signals [SignalEncoding] false A list of signals belonging to this propagator. Enumerated Values Property Value direction both direction forward direction reverse SignalEncoding signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A signal encoding definition.\nProperties Name Type Required Description signal string true The name of the signal. target string false none encoding object false none » linear object false none »» min number false none »» max number false none »» factor number false none »» offset number false none » mapping [object] false none »» name string false none »» source number false none »» target number false none »» range object false none »»» min number false none »»» max number false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nPropagator kind: Propagator metadata: name: string labels: …","ref":"/dse.doc/schemas/yaml/propagator/","tags":["Schema"],"title":"Schema: Propagator"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/report/","tags":"","title":"Report"},{"body":"(v1.0.0)\nRunnable kind: Runnable metadata: name: target annotations: target_lib: examples/stub/lib/target.so spec: tasks: - function: task_init schedule: 0 - function: task_5ms schedule: 5 - function: task_10ms schedule: 10 - function: task_20ms schedule: 20 - function: task_40ms schedule: 40 A Runnable definition.\nSupported annotations: Annotation Description target_lib Relative path of the shared library containing the Runnable library. Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec RunnableSpec true none Enumerated Values Property Value kind Runnable RunnableSpec tasks: - function: task_init schedule: 20 Properties Name Type Required Description tasks [Task] true A list of tasks belonging to this Runnable. Task function: task_init schedule: 20 A Runnable task definition.\nProperties Name Type Required Description function string true The name of the function representing the task. This function\nwill be loaded from the library referenced by the Runnable\nannotation target_lib. schedule integer true The task schedule interval (in milliseconds). undefined\n","categories":"","description":"","excerpt":"(v1.0.0)\nRunnable kind: Runnable metadata: name: target annotations: …","ref":"/dse.doc/schemas/yaml/runnable/","tags":["Schema"],"title":"Schema: Runnable"},{"body":"Runtime API The Runtime API provides methods for implementing a model Runtime/Importer which can be used to load, configure and execute a model.\nTypedefs ChannelSpec typedef struct ChannelSpec { const char* name; const char* alias; void* private; } ModelCArguments typedef struct ModelCArguments { const char* transport; char* uri; const char* host; int port; double timeout; int log_level; double step_size; double end_time; int uid; const char* name; const char* file; const char* path; void* yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; int steps; const char* sim_path; int [4] __reserved__; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char* name; const char* path; const char* file; char* full_path; void* doc; void* channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { int uid; char* name; int* model_desc; ModelDefinitionSpec model_definition; void* spec; void* yaml_doc_list; void* private; int [8] __reserved__; } RuntimeModelDesc typedef struct RuntimeModelDesc { int model; struct { const char* runtime_model; char* sim_path; const char* model_name; const char* simulation_yaml; int argc; char** argv; void* doc_list; int log_level; double step_size; double end_time; double step_time_correction; int binary_signals_reset; } runtime; int [8] __reserved__; } SimulationSpec typedef struct SimulationSpec { const char* transport; char* uri; int uid; double timeout; double step_size; double end_time; ModelInstanceSpec* instance_list; const char* sim_path; int mode_loopback; int sequential_cosim; int [4] __reserved__; } Functions modelc_destroy Bypass the controller and call model_destroy() directly.\nParameters model_instance : ModelInstanceSpec (pointer to) The model instance, which holds references to the registered channels and model functions. step_size : double The duration simulation step to be performed (in seconds).\nmodelc_step Execute a simulation step with the provided step size for all model functions of the given model instance.\nThe AdapterModel properties are normally set from a Start Message, however when the SimBus is mocked (or not present) then the stop_time needs to be set. model_time is set in the call to step_model().\nParameters model_instance : ModelInstanceSpec (pointer to) The model instance, which holds references to the registered channels and model functions. step_size : double The duration simulation step to be performed (in seconds).\nReturns 0 : Success. +ve/-ve : Failure, inspect `errno` for the failing condition. ","categories":"","description":"","excerpt":"Runtime API The Runtime API provides methods for implementing a model …","ref":"/dse.doc/apis/modelc/runtime/","tags":"","title":"Runtime API Reference"},{"body":"Schedule API The Schedule API proves a task schedule with configurable beat and an optional delay. Interfaces of the Schedule object allow for customization of the schedule behaviour, these include:\nScheduleVTable - tick and marshalling call interfaces. ScheduleTaskVTable - Support custom task call interfaces, the default is a simple void (*)(void) function call. Component Diagram @startuml schedule-api skinparam nodesep 55 skinparam ranksep 40 title Schedule API component \"Schedule\" as s component \"ScheduleItem\" as sI component \"ScheduleTask\" as sT interface \"ScheduleVTable\" as sVT interface \"ScheduleTaskVTable\" as sTVT component \"Integration\" as vT component \"Target\" as task s --( sVT s --( sTVT sVT -- vT sTVT -- vT s ---\u003e sI : [0..m] sI --\u003e sT vT --\u003e sT : \"exec()\" sT ..\u003e task : \"task()\" center footer Dynamic Simulation Environment @enduml Example // Copyright 2025 Robert Bosch GmbH #include \u003cstddef.h\u003e #include \u003cstdio.h\u003e #include \u003cdse/clib/schedule/schedule.h\u003e void task_init(void) { printf(\"task_init\\n\"); } void task_1ms(void) { printf(\"task_1ms\\n\"); } void task_5ms(void) { printf(\"task_1ms\\n\"); } void schedule_api_example(void) { // Configure the schedule. Schedule s = { 0 }; schedule_configure( \u0026s, (ScheduleVTable){ 0 }, (ScheduleTaskVTable){ 0 }, 0.001, NULL); schedule_add(\u0026s, task_init, 0); schedule_add(\u0026s, task_1ms, 1); schedule_add(\u0026s, task_5ms, 5); // Progress simulation for 10 ms. for (double sim_time = 0; sim_time \u003c= 0.01001; sim_time += 0.0005) { schedule_tick(\u0026s, sim_time); } // Destroy the schedule. schedule_destroy(\u0026s); } Typedefs Schedule typedef struct Schedule { ScheduleVTable vtable; ScheduleItem* list; int count; double schedule_time; double* delay; double beat; uint32_t tick; bool init_tick_done; ScheduleTaskVTable task_vtable; } ScheduleItem typedef struct ScheduleItem { ScheduleTask task; uint32_t schedule_beats; uint32_t alarm; } ScheduleTaskVTable typedef struct ScheduleTaskVTable { ScheduleTaskExec exec; ScheduleTaskInfo info; ScheduleTaskFree free; } ScheduleVTable typedef struct ScheduleVTable { void* data; ScheduleTick tick; ScheduleMarshal marshal_in; ScheduleMarshal marshal_out; ScheduleMarshal marshal_noop; } Functions schedule_add Add a task to the schedule.\nParameters s (Schedule*) A schedule descriptor object. task (ScheduleTask) A task object (void*). This may represent any type or object that is supported by the configured ScheduleTaskVTable. schedule_beats (uint32_t) Indicates the schedule of the task in beats. Set to 0 for initialisation tasks. schedule_configure Configure a schedule object.\nParameters s (Schedule*) A schedule descriptor object to be configured. vtable (ScheduleVTable) Reference to a ScheduleVTable object. Can be provided as a null object (e.g. (ScheduleVTable){ 0 }) in which case the default tick function is configured (schedule_default_tick). task_vtable (ScheduleTaskVTable) Reference to a ScheduleTaskVTable object. Can be provided as a null object (e.g. (ScheduleTaskVTable){ 0 }) in which case the default exec function is configured (schedule_default_exec). beat (double) The schedule beat. If 0 then the default DEFAULT_BEAT is used (1 mSec). delay (double*) Pointer to a delay value which will be applied to the schedule. Set to NULL if no delay should be configured. schedule_destroy Releases any resourced allocated to the schedule. If ScheduleTaskVTable.free is configured then that function is called, the implementation of that function should release resources allocated to each ScheduleItem object as required.\nParameters s (Schedule*) A schedule descriptor object. schedule_tick Tick the schedule items, and execute tasks as required.\nParameters s (Schedule*) A schedule descriptor object. simulation_time (double) The current simulation time. ","categories":"","description":"","excerpt":"Schedule API The Schedule API proves a task schedule with configurable …","ref":"/dse.doc/apis/clib/schedule/","tags":"","title":"Schedule API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/schema/","tags":"","title":"Schema"},{"body":"Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.\nTypedefs SchemaLabel typedef struct SchemaLabel { const char* name; const char* value; } SchemaObject typedef struct SchemaObject { const char* kind; const char* name; void* doc; void* data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char* kind; const char* name; SchemaLabel* labels; int labels_len; void* data; } SchemaSignalObject typedef struct SchemaSignalObject { const char* signal; void* data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec. The caller should free the object by calling schema_release_channel_selector().\nThe returned SchemaObjectSelector can be used when calling schema_object_search() to search for schema objects.\nNote: A channel selector will not match on metadata/name.\nParameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects that will searched by the generated selector. channel (ChannelSpec*) A channel spec object. kind (const char*) The kind of schema object to select. Returns SchemaObjectSelector (pointer) The complete selector object. NULL A selector object could not be created. This return value does not represent an error condition. The caller will determine if this condition represents and error (typically a configuration error). schema_object_enumerator Enumerate over all child objects of a schema list object. Each child object is marshalled via the generator function and returned to the caller.\nWhen index exceeds the length of the schema list object the function returns NULL and the enumeration is complete.\nParameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects which will be enumerated over.. object (SchemaObject*) The schema list object to enumerate over. path (const char*) Enumerate objects located at this path, relative from the object. index (uint32_t*) Maintains the enumerator postion between calls. Set to 0 to begin a new schema object enumeration (i.e. from the first object in the list). generator (SchemaObjectGenerator) A generator function which creates the required schema object. Returns void* Pointer to the generated object created by the generator function. The caller must free this object. NULL The enumeration is complete. schema_object_search Search the collection of schema objects according to the selector, and call the handler function for each matching object. Schema objects are searched in the order they were parsed (i.e. listed order at the CLI).\nExample #include \u003cdse/modelc/model.h\u003e #include \u003cdse/modelc/schema.h\u003e #include \u003cdse/logger.h\u003e int match_handler(ModelInstanceSpec* mi, SchemaObject* object) { uint32_t index = 0; SchemaSignalObject* so; do { so = schema_object_enumerator( mi, object, \"spec/signals\", \u0026index, schema_signal_object_generator); if (so == NULL) break; if (so-\u003esignal) { log_debug(\" signal identified: %s\", so-\u003esignal); } free(so); } while (1); return 0; } void object_search(ModelInstanceSpec* mi, const char* channel_name) { ChannelSpec channel_spec = { .name = channel_name }; SchemaObjectSelector* selector = schema_build_channel_selector(mi, \u0026channel_spec, \"SignalGroup\"); if (selector) { schema_object_search(mi, selector, match_handler); } schema_release_selector(selector); } Parameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects which will be searched. selector (SchemaObjectSelector*) A selector object, schema objects are matched as follows: kind - matches the object kind (if NULL matches all object kinds). name - matches the object name (if NULL matches all object names). labels[] - matches all labels of the object (i.e. AND). handler (SchemaMatchHandler) A handler function which is called for each matching schema object. The handler can control the search continuation by returning as follows: 0 - the search should continue until no more matches are found. +ve - the search should stop and return 0 (indicating success). -ve - the search should abort, set errno with a value to indicate the failing condition, and return +ve (indicating failure). Returns 0 The schema search successfully completed. +ve Failure, inspect errno for an indicator of the failing condition. schema_release_selector Release any allocated memory in a SchemaObjectSelector object.\nParameters selector (SchemaObjectSelector*) A selector object, created by calling schema_build_channel_selector(). schema_signal_object_generator Generate a schema signal object.\nParameters model_instance (ModelInstanceSpec*) The Model Instance, which holds references to the various schema objects which will be searched. data (void*) The YAML node to generate from. Returns void* Pointer to the generated schema signal object. The caller must free this object. NULL The object cannot be generated. ","categories":"","description":"","excerpt":"Schema API The Schema API provides a number of functions for parsing …","ref":"/dse.doc/apis/modelc/schema/","tags":"","title":"Schema API Reference"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/sdp/","tags":"","title":"SDP"},{"body":"(v0.0.1)\nSignalData Data = [[0..N],[0..N]] MsgPack encoded Signal Data. Number of elements in each nested array should be identical.\nProperties oneOf\nName Type Required Description anonymous SignalUid false Signal UID. xor\nName Type Required Description anonymous SignalValueNumeric false Numeric signal value. The value may be encoded as any integer or float type. xor\nName Type Required Description anonymous SignalValueBinary false Binary signal value. SignalUid 0 Signal UID.\nProperties Name Type Required Description anonymous integer(int32) false Signal UID. SignalValueNumeric 0 Numeric signal value. The value may be encoded as any integer or float type.\nProperties Name Type Required Description anonymous number(double) false Numeric signal value. The value may be encoded as any integer or float type. SignalValueBinary string Binary signal value.\nProperties Name Type Required Description anonymous string(binary) false Binary signal value. undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nSignalData Data = [[0..N],[0..N]] MsgPack encoded Signal …","ref":"/dse.doc/schemas/yaml/signaldata/","tags":["Schema"],"title":"Schema: SignalData"},{"body":"(v0.0.1)\nSignalGroup kind: SignalGroup metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: signals: - signal: string transform: linear: factor: 0 offset: 0 annotations: ? property1 ? property2 A signal group definition.\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec SignalGroupSpec true none Enumerated Values Property Value kind SignalGroup SignalGroupSpec signals: - signal: string transform: linear: factor: 0 offset: 0 annotations: ? property1 ? property2 Properties Name Type Required Description signals [Signal] true A list of signals belonging to this signal group. Signal signal: string transform: linear: factor: 0 offset: 0 annotations: ? property1 ? property2 A signal definition.\nProperties Name Type Required Description signal string true The name of the signal. transform object false A transformation definition. » linear object false Represents a linear transformation in the form:\nf(X) = X * factor + offset. »» factor number(double) true none »» offset number(double) true none annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties any false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nSignalGroup kind: SignalGroup metadata: name: string labels: …","ref":"/dse.doc/schemas/yaml/signalgroup/","tags":["Schema"],"title":"Schema: SignalGroup"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/simbus/","tags":"","title":"SimBus"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/simer/","tags":"","title":"Simer"},{"body":"SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC \u003c-\u003e SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.\nComponent Diagram @startuml simmock-objects title SimMock Objects package \"SimBus Mock\" { class Signal \u003c\u003cSignalVector\u003e\u003e { +uint32_t count +double scalar[] +annotation() } class Network \u003c\u003cSignalVector\u003e\u003e { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.yaml .... kind: \u003cb\u003eSignalGroup metadata: name: \u003cb\u003esignal labels: channel: \u003cb\u003esignal_vector ] file svNet [ signalgroup.yaml .... kind: \u003cb\u003eSignalGroup metadata: name: \u003cb\u003enetwork labels: channel: \u003cb\u003enetwork_vector annotations: vector_type: \u003cb\u003ebinary ] Signal -\u003e svSig Network -\u003e svNet } map ModelMock { sv_signal *--\u003e Signal sv_network *--\u003e Network } map SimMock { model *--\u003e ModelMock sv_signal *--\u003e Signal sv_network_rx *-\u003e Network sv_network_tx *-\u003e Network } center footer Dynamic Simulation Environment @enduml Typedefs BinaryCheck typedef struct BinaryCheck { int index; int* buffer; int len; } FrameCheck typedef struct FrameCheck { int frame_id; int offset; int value; bool not_present; } ModelMock typedef struct ModelMock { const char* name; int* mi; int* sv_signal; int* sv_network; int* sv_save; int vtable; int* sm_signal; int* mfc_signal; } SignalCheck typedef struct SignalCheck { int index; double value; } SimMock typedef struct SimMock { int sim; double step_size; ModelMock* model; void* doc_list; double model_time; int* sv_signal; int* sv_network_rx; int* sv_network_tx; } Functions simmock_alloc Create a SimMock object.\nParameters inst_names[] (const char*) Array of model instance names which should be allocated in the SimMock object. count (size_t) The number of elements in the inst_names array. Returns SimMock* The allocated SimMock object. Caller should free by calling simmock_free(). simmock_binary_check Check the content of a binary signal.\nParameters mock (SimMock*) A SimMock object. model_name (const char*) The name of the model to check. checks (BinaryCheck*) Array of BinaryCheck objects. count (size_t) The number elements in the checks array. func (BinaryCheckFunc) Optional function pointer for performing the binary check. simmock_configure Configure a SimMock object with a list of command line arguments (as would be used by the ModelC.exe).\nExample #include \u003cdse/testing.h\u003e #include \u003cdse/mocks/simmock.h\u003e int test_setup(void** state) { const char* inst_names[] = { \"target_inst\", \"network_inst\", }; char* argv[] = { (char*)\"test_runnable\", (char*)\"--name=target_inst;network_inst\", (char*)\"--logger=5\", // 1=debug, 5=QUIET (commit with 5!) (char*)\"../../../../tests/cmocka/network/stack.yaml\", (char*)\"../../../../tests/cmocka/network/signalgroup.yaml\", (char*)\"../../../../tests/cmocka/network/network.yaml\", (char*)\"../../../../tests/cmocka/network/model.yaml\", (char*)\"../../../../tests/cmocka/network/runnable.yaml\", }; SimMock* mock = simmock_alloc(inst_names, ARRAY_SIZE(inst_names)); simmock_configure(mock, argv, ARRAY_SIZE(argv), ARRAY_SIZE(inst_names)); simmock_load(mock); simmock_setup(mock, \"signal\", \"network\"); /* Return the mock. */ *state = mock; return 0; } Parameters mock (SimMock*) A SimMock object. argv (char*) Array of arguments. argc (size_t) Number of elements in the argv array. expect_model_count (size_t) The expected number of models to be configured (based on the parsed list of arguments). simmock_exit Call model_destroy() for each model.\nParameters mock (SimMock*) A SimMock object. call_destroy (bool) Indicate that model_destroy() should be explicitly called. Set to true when using the SimMock library outside of the ModelC repo (which has its own mock object representing the controller). simmock_find_model Find a MockModel object contained within a SimMock object.\nParameters mock (SimMock*) A SimMock object. name (const char*) The name of the model to find. Returns MockModel* The identified MockModel object. NULL No MockModel was found. simmock_frame_check Check the content of a binary signal for various frames. The binary signal should be represented by a Network Codec (NCodec) object.\nExample #include \u003cdse/testing.h\u003e #include \u003cdse/mocks/simmock.h\u003e void test_network__frame_check(void** state) { SimMock* mock = *state; /* 0ms - initial tick, Rx consumed, Tx of initial content. */ { for (uint32_t i = 0; i \u003c 1; i++) { assert_int_equal(simmock_step(mock, true), 0); } FrameCheck f_checks[] = { { .frame_id = 0x1f3u, .offset = 0, .value = 0x01 }, { .frame_id = 0x1f4u, .offset = 1, .value = 0x02 }, { .frame_id = 0x1f5u, .offset = 4, .value = 0x02 }, }; simmock_print_network_frames(mock, LOG_DEBUG); simmock_frame_check( mock, \"network_inst\", \"can_bus\", f_checks, ARRAY_SIZE(f_checks)); } } Parameters mock (SimMock*) A SimMock object. model_name (const char*) The name of the model to check. sig_name (const char*) The name of the binary signal where frames should be located. checks (FrameCheck*) Array of FrameCheck objects. count (size_t) The number elements in the checks array. simmock_free Destroy and free resources allocated to a SimMock object.\nParameters mock (SimMock*) The SimMock object to be released. simmock_load Load all of the models referenced by a SimMock object.\nParameters mock (SimMock*) A SimMock object. simmock_load_model_check Check the condition/state of a loaded model.\nParameters mock (SimMock*) A SimMock object. expect_create_func (bool) Indicate that model libraries should contain a model_create function. expect_step_func (bool) Indicate that model libraries should contain a model_step function. expect_destroy_func (bool) Indicate that model libraries should contain a model_destroy function. simmock_print_binary_signals Print the binary signals contained in each network vector of each model.\nParameters mock (SimMock*) A SimMock object. level (int) The log level to print at. simmock_print_network_frames Print the frames contained in each network vector of each model.\nParameters mock (SimMock*) A SimMock object. level (int) The log level to print at. simmock_print_scalar_signals Print the scalar signal values of each signal vector of each model.\nParameters mock (SimMock*) A SimMock object. level (int) The log level to print at. simmock_read_frame Read a frame, using the associated NCodec object, from the specified binary signal.\nParameters sv (SignalVector*) A Signal Vector object. sig_name (const char*) The name of the binary signal where frames should be written. data (uint8_t*) Array for the read data. The data is preallocated by the caller. len (size_t) Length of the data array. Returns uint32_t The Frame ID associated with the read data. 0 No frame was found in the specified binary signal. simmock_read_pdu Read a PDU, using the associated NCodec object, from the specified binary signal.\nParameters sv (SignalVector*) A Signal Vector object. sig_name (const char*) The name of the binary signal where PDUs should be written. data (uint8_t*) Array for the read data. The data is preallocated by the caller. len (size_t) Length of the data array. Returns uint32_t The PDU ID associated with the read data. 0 No PDU was found in the specified binary signal. simmock_setup Calls the model_setup() function on each model and then creates Signal Vectors for each model. Additional Signal Vectors are created to facilitate the mocked behaviour of a simulation (via the SimMock object).\nParameters mock (SimMock*) A SimMock object. sig_name (const char*) The name of the scalar channel. sig_name (const char*) The name of the binary channel. simmock_signal_check Check the values of various signals on the Signal Vector (scalar).\nExample #include \u003cdse/testing.h\u003e #include \u003cdse/mocks/simmock.h\u003e #define SIG_task_init_done 1 #define SIG_task_5_active 2 #define SIG_task_5_counter 6 void test_network__signal_check(void** state) { SimMock* mock = *state; /* 0ms - initial tick, Rx consumed, Tx of initial content. */ { for (uint32_t i = 0; i \u003c 1; i++) { assert_int_equal(simmock_step(mock, true), 0); } SignalCheck s_checks[] = { { .index = SIG_task_init_done, .value = 1.0 }, { .index = SIG_task_5_active, .value = 0.0 }, { .index = SIG_task_5_counter, .value = 0.0 }, }; simmock_print_scalar_signals(mock, LOG_DEBUG); simmock_signal_check( mock, \"network_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); } } Parameters mock (SimMock*) A SimMock object. model_name (const char*) The name of the model to check. checks (SignalCheck*) Array of SignalCheck objects. count (size_t) The number elements in the checks array. func (SignalCheckFunc) Optional function pointer for performing the signal check. simmock_step Calls model_step() on each model and manages the mocked exchange of both scalar and binary Signal Vectors.\nParameters mock (SimMock*) A SimMock object. assert_rc (bool) Indicate that an assert check (value 0) should be made for each return from a call to model_step(). Returns int The combined (or’ed) return code of each call to model_step(). simmock_write_frame Write a frame, using the associated NCodec object, to the specified binary signal.\nParameters sv (SignalVector*) A Signal Vector object. sig_name (const char*) The name of the binary signal where frames should be written. data (uint8_t*) Array of data to write (in the frame). len (size_t) Length of the data array. frame_id (uint32_t) The Frame ID associated with the data. frame_type (uint8_t) The Frame Type associated with the frame. simmock_write_pdu Write a PDU, using the associated NCodec object, to the specified binary signal.\nParameters sv (SignalVector*) A Signal Vector object. sig_name (const char*) The name of the binary signal where PDUs should be written. data (uint8_t*) Array of data to write (in the PDU). len (size_t) Length of the data array. id (uint32_t) The PDU ID associated with the data. ","categories":"","description":"","excerpt":"SimMock API The SimMock API provides interfaces for the development of …","ref":"/dse.doc/apis/modelc/simmock/","tags":"","title":"SimMock API Reference"},{"body":"SimMock and CMocka Testing for Model Developers The DSE ModelC Library includes a SimMock source code library which may be used to develop integration tests for Models. With the SimMock library, a Model Developer is able to easily develop CMocka Testcases which:\nValidate a model configuration and confirm the Models operation. Develop scenarios where expected signal exchange is verified. Inject network messages into the simulation or model (e.g. CAN frames) and read network messages. Check expected values for both scalars (Signals) and messages (Network). Stack several Model Instances within one SimMock and confirm their interoperation. ModelC Shared Library Stub When testing models directly with the SimMock it may be necessary to use a stub of the modelc.so library. The following integrations are required:\ntests/cmocka/Makefile export LD_LIBRARY_PATH=$(shell pwd)/build/_out/lib tests/cmocka/CMakeLists.txt # Target - ModelC Stub # -------------------- add_library(modelc_stub SHARED ${DSE_MOCKS_SOURCE_DIR}/modelc_stub.c ) set_target_properties(modelc_stub PROPERTIES OUTPUT_NAME modelc ) install(TARGETS modelc_stub) Example Test Files network/test_network.c #include \u003cdse/testing.h\u003e #include \u003cdse/logger.h\u003e #include \u003cdse/mocks/simmock.h\u003e static int test_setup(void** state) { const char* inst_names[] = { \"target_inst\", \"network_inst\", }; char* argv[] = { (char*)\"test_runnable\", (char*)\"--name=target_inst;network_inst\", (char*)\"--logger=5\", // 1=debug, 5=QUIET (commit with 5!) (char*)\"../../../../tests/cmocka/network/stack.yaml\", (char*)\"../../../../tests/cmocka/network/signalgroup.yaml\", (char*)\"../../../../tests/cmocka/network/network.yaml\", (char*)\"../../../../tests/cmocka/network/model.yaml\", (char*)\"../../../../tests/cmocka/network/runnable.yaml\", }; SimMock* mock = simmock_alloc(inst_names, ARRAY_SIZE(inst_names)); simmock_configure(mock, argv, ARRAY_SIZE(argv), ARRAY_SIZE(inst_names)); simmock_load(mock); simmock_setup(mock, \"signal\", \"network\"); /* Return the mock. */ *state = mock; return 0; } static int test_teardown(void** state) { SimMock* mock = *state; simmock_exit(mock, false); simmock_free(mock); return 0; } #define SIG_reset_counters 0 #define SIG_task_init_done 1 #define SIG_task_5_active 2 #define SIG_task_10_active 3 #define SIG_task_20_active 4 #define SIG_task_40_active 5 #define SIG_task_5_counter 6 #define SIG_task_10_counter 7 #define SIG_task_20_counter 8 #define SIG_task_40_counter 9 void test_network__network2target2network(void** state) { SimMock* mock = *state; ModelMock* network_model = \u0026mock-\u003emodel[1]; assert_non_null(network_model); /* 0-19.5ms */ { for (uint32_t i = 0; i \u003c 39; i++) { assert_int_equal(simmock_step(mock, true), 0); } SignalCheck s_checks[] = { { .index = SIG_task_init_done, .value = 1.0 }, { .index = SIG_task_5_active, .value = 1.0 }, { .index = SIG_task_5_counter, .value = 3.0 }, { .index = SIG_task_10_active, .value = 1.0 }, { .index = SIG_task_10_counter, .value = 1.0 }, { .index = SIG_task_20_active, .value = 0.0 }, { .index = SIG_task_20_counter, .value = 0.0 }, }; simmock_signal_check( mock, \"target_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); simmock_signal_check( mock, \"network_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); } /* Inject a message carrying the reset_counters signal. */ uint8_t buffer[8] = { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 }; simmock_write_frame(mock-\u003esv_network_tx, \"can_bus\", buffer, 8, 0x1f0u, 0); assert_int_equal(simmock_step(mock, true), 0); /* 20ms */ { for (uint32_t i = 0; i \u003c 1; i++) { assert_int_equal(simmock_step(mock, true), 0); } SignalCheck s_checks[] = { { .index = SIG_task_init_done, .value = 1.0 }, { .index = SIG_task_5_active, .value = 1.0 }, { .index = SIG_task_5_counter, .value = 1.0 }, { .index = SIG_task_10_active, .value = 1.0 }, { .index = SIG_task_10_counter, .value = 1.0 }, { .index = SIG_task_20_active, .value = 1.0 }, { .index = SIG_task_20_counter, .value = 1.0 }, }; FrameCheck f_checks[] = { { .frame_id = 0x1f4u, .offset = 1, .value = 0x02 }, { .frame_id = 0x1f4u, .offset = 2, .value = 0x02 }, { .frame_id = 0x1f4u, .offset = 3, .value = 0x02 }, { .frame_id = 0x1f5u, .offset = 4, .value = 0x02 }, { .frame_id = 0x1f7u, .offset = 4, .value = 0x02 }, }; simmock_print_scalar_signals(mock, LOG_DEBUG); simmock_print_network_frames(mock, LOG_DEBUG); assert_int_equal(network_model-\u003esv_network-\u003elength[0] \u003e 0, true); simmock_signal_check( mock, \"network_inst\", s_checks, ARRAY_SIZE(s_checks), NULL); simmock_frame_check( mock, \"network_inst\", \"can_bus\", f_checks, ARRAY_SIZE(f_checks)); } } int run_network_tests(void) { void* s = test_setup; void* t = test_teardown; const struct CMUnitTest tests[] = { cmocka_unit_test_setup_teardown( test_network__network2target2network, s, t), }; return cmocka_run_group_tests_name(\"NETWORK\", tests, NULL, NULL); } References and Further Reading Testing with CMocka ","categories":"","description":"","excerpt":"SimMock and CMocka Testing for Model Developers The DSE ModelC Library …","ref":"/dse.doc/docs/devel/testing/simmock/","tags":["Developer","Testing","CMocka"],"title":"Testing Models with SimMock"},{"body":"(v0.0.1)\nSimulation kind: Simulation metadata: name: project annotations: input: somefile.json generator: parse2ast spec: simulation: arch: linux-amd64 stepsize: 0.0005 endtime: 0.2 channels: - name: physical - name: network networks: - name: CAN mime_type: application/x uses: - name: model.linear url: https://github.com/boschglobal/dse.fmi version: 1.1.15 path: model/linear/path vars: - name: enable value: true stacks: - name: stack_name stacked: true arch: linux-amd64 models: - name: linear model: model.linear channels: - name: physical alias: scalar env: - name: SIMBUS_LOGLEVEL value: 4 workflows: - name: generate-fmimcl vars: - name: FMU_DIR value: \"{{.PATH}}/fmu\" Simulation Abstract Syntax Tree (AST).\nProperties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec SimulationSpec true none Enumerated Values Property Value kind Simulation SimulationSpec arch: linux-amd64 stepsize: 0.0005 endtime: 0.005 channels: - name: string networks: - name: string mime_type: string uses: - name: string url: string version: string path: string user: string token: string metadata: ? property1 ? property2 vars: - name: string value: string reference: uses stacks: - name: string arch: linux-amd64 stacked: true sequential: true env: - name: string value: string reference: uses models: - name: string model: string uid: 0 uses: string metadata: ? property1 ? property2 arch: linux-amd64 external: true channels: - name: string alias: string files: - name: string value: string reference: uses env: - name: string value: string reference: uses workflows: - name: string uses: string vars: - name: string value: string reference: uses Properties Name Type Required Description arch string true The default system architecture for the simulation. stepsize number(double) false The configured simulation step-size. endtime number(double) false The configured simulation end-time. channels [SimulationChannel] true The list of channels available in this simulation. uses [Uses] false The list of uses references to external artifacts or repos. vars [Var] false The list of variables available to models in this simulation. stacks [Stack] true The list of stacks contained within this simulation. SimulationChannel name: string networks: - name: string mime_type: string Properties Name Type Required Description name string true The name of this channel. networks [SimulationNetwork] false A list of networks associated with a channel. SimulationNetwork name: string mime_type: string A network definition.\nProperties Name Type Required Description name string true The name of the network signal (on the associated channel). mime_type string true MIME type defining the network. ModelChannel name: string alias: string A model \u003c-\u003e simulation channel mapping.\nProperties Name Type Required Description name string true The name of the channel in the simulation. alias string true The name (alias) of the channel in the model. Uses name: string url: string version: string path: string user: string token: string metadata: ? property1 ? property2 Defines an external resource used by the simulation.\nProperties Name Type Required Description name string true The name of uses item (to be used for references). url string true The URL of the uses item (repository or artefact). version string false The tag/version of the uses item. path string false A sub-path relative to the uses artefact (URL or ZIP file) where the item is located. user string false Username for resources which require authentication (typically an environment variable: $SOME_USER). token string false Token for resources which require authentication (typically an environment variable: $SOME_TOKEN). metadata object false Additional data relating to the uses item (e.g. container details). » additionalProperties any false none Var name: string value: string reference: uses A variable definition.\nProperties Name Type Required Description name string true A variable name. value string true A corresponding variable value. reference string false This value is derived from the specified reference (e.g. a downloaded file) The resource name is specified in the value. Enumerated Values Property Value reference uses File name: string value: string reference: uses A file definition.\nProperties Name Type Required Description name string true Name of the file (to be placed in the data folder of a model) or a relative path of the file (i.e. relative to the Model defining the file). value string true A corresponding file value, interpret as a ‘uses’ reference or a local file path. reference string false This value is derived from the specified reference (e.g. a downloaded file) The resource name is specified in the value. Enumerated Values Property Value reference uses Stack name: string arch: linux-amd64 stacked: true sequential: true env: - name: string value: string reference: uses models: - name: string model: string uid: 0 uses: string metadata: ? property1 ? property2 arch: linux-amd64 external: true channels: - name: string alias: string files: - name: string value: string reference: uses env: - name: string value: string reference: uses workflows: - name: string uses: string vars: - name: string value: string reference: uses A stack definition which composes one or more models as a logical unit of the simulation.\nProperties Name Type Required Description name string true The name of the stack. arch string false The architecture of the stack, if different from the simulation default architecture. stacked boolean false Indicate that models in this stack should be run in a ‘stacked’ configuration (i.e. as a single process). sequential boolean false Indicate that models in this stack should be run as a Sequential Co-Simulation. env [Var] false Sets environment variables in the runtime of this simulation stack. models [Model] true The list of models belonging to this simulation stack. Model name: string model: string uid: 0 uses: string metadata: ? property1 ? property2 arch: linux-amd64 external: true channels: - name: string alias: string files: - name: string value: string reference: uses env: - name: string value: string reference: uses workflows: - name: string uses: string vars: - name: string value: string reference: uses Properties Name Type Required Description name string true The name of the model in the simulation (i.e. the model instance name). model string true The name of the model this instance represents (as named in the associated repository metadata). uid integer false UID assigned to this model instance. Should be unique to the simulation. uses string true Name of the uses item that represents the implementation of the model. metadata object false Additional data relating to the model implementation (e.g. package layout details). » additionalProperties any false none arch string false The architecture of the model, if different from the stack or simulation default architecture. external boolean false This model is external to the operated simulation (e.g. a Gateway\nmodel). External models may optionally reference a ‘uses’ item and\nits associated workflows. channels [ModelChannel] true An array of model \u003c-\u003e simulation channel mappings. files [File] false An array of files to be combined with the model deployment. Files specified without a path are placed\nin the model data folder (i.e. ‘sim//data’), otherwise the file is placed relative to the\nmodel folder. env [Var] false Sets environment variables in the runtime of this model.\nValues defined here supersede those set in the simulation stack (of the model). workflows [Workflow] false An array of workflows used to construct/process artifacts used by this model instance. Workflow name: string uses: string vars: - name: string value: string reference: uses Properties Name Type Required Description name string true The name of the workflow. uses string false If a workflow is located in a different repository than the model, indicate that here. vars [Var] false Set variable values to be used by the workflow. undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nSimulation kind: Simulation metadata: name: project …","ref":"/dse.doc/schemas/yaml/simulation/","tags":["Schema"],"title":"Schema: Simulation"},{"body":"(v0.0.1)\nStack kind: Stack metadata: name: default annotations: simulation: stepsize: 0.0005 endtime: 0.2 spec: connection: transport: redis: timeout: 60 uri: redis://localhost:6379 models: - name: simbus uid: 0 model: name: simbus channels: - expectedModelCount: 1 name: physical - name: input uid: 1 model: name: dse.modelc.csv runtime: env: CSV_FILE: model/input/data/input.csv paths: - model/input/data channels: - alias: signal_channel name: physical selectors: channel: signal_vector model: input A stack definition.\nProperties Name Type Required Description kind string true Indicate the type of object. metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none spec StackSpec true none Enumerated Values Property Value kind Stack StackSpec connection: timeout: string transport: redis: uri: string timeout: 0 runtime: env: property1: string property2: string stacked: true sequential: true models: - name: string uid: 0 annotations: ? property1 ? property2 model: name: string mcl: strategy: string models: - name: string runtime: env: property1: string property2: string files: - string paths: - string x32: true i386: true external: true channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 Properties Name Type Required Description connection object false none » timeout string false Model timeout for messages from the transport. » transport object false none oneOf\nName Type Required Description »» anonymous object false none »»» redis RedisConnection true Redis connection. xor\nName Type Required Description »» anonymous object false none »»» redispubsub RedisConnection true Redis connection. xor\nName Type Required Description »» anonymous object false none »»» mq MessageQueue true Message Queue based connection. continued\nName Type Required Description runtime StackRuntime false Runtime properties of a Stack. models [ModelInstance] false [A model instance object.] ModelInstance name: string uid: 0 annotations: ? property1 ? property2 model: name: string mcl: strategy: string models: - name: string runtime: env: property1: string property2: string files: - string paths: - string x32: true i386: true external: true channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ? property1 ? property2 A model instance object.\nProperties Name Type Required Description name string true none uid integer true none annotations object false Non identifying information (i.e. information specific to the object itself). » additionalProperties any false none model object true none » name string true none » mcl object false none »» strategy string true none »» models [object] true A list of models belonging to this MCL. »»» name string true The name of the MCL model. runtime ModelInstanceRuntime false Runtime properties of a Model Instance. channels [object] false none » name string false The name of the channel, used when connecting this channel to the SimBus. » alias string false The alias of the channel, used when the channel name will be determined elsewhere. » expectedModelCount integer false Indicates how many models are expected to connect to this channel (used by SimBus only). » selectors object false Identifying information used to identify objects within the system (e.g. giving a specific ’label’ to an object). »» additionalProperties string false none » annotations object false Non identifying information (i.e. information specific to the object itself). »» additionalProperties any false none StackRuntime env: property1: string property2: string stacked: true sequential: true Runtime properties of a Stack.\nProperties Name Type Required Description env object false Environment variables. » additionalProperties string false none stacked boolean false Run all Models (of this stack) in a single instance of ModelC. sequential boolean false Run the Models in this Stack as a Sequential Co-Simulation. All Models run in a single instance of ModelC (i.e. setting stacked is implicitly selected). ModelInstanceRuntime env: property1: string property2: string files: - string paths: - string x32: true i386: true external: true Runtime properties of a Model Instance.\nProperties Name Type Required Description env object false Environment variables. » additionalProperties string false none files [string] false Additional file arguments passed to ModelC. paths [string] false Paths to scan for additional (YAML) files, subsequently passed as arguments ModelC. x32 boolean false Run Model with 32bit ModelC executable (x32 abi). i386 boolean false Run Model with 32bit ModelC executable (i386 abi). external boolean false This model is external to the operated simulation (e.g. a Gateway). RedisConnection uri: string timeout: 0 Redis connection.\nProperties Name Type Required Description uri string false none timeout integer false none MessageQueue uri: string Message Queue based connection.\nProperties Name Type Required Description uri string false none undefined\n","categories":"","description":"","excerpt":"(v0.0.1)\nStack kind: Stack metadata: name: default annotations: …","ref":"/dse.doc/schemas/yaml/stack/","tags":["Schema"],"title":"Schema: Stack"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/","tags":"","title":"Tags"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/testing/","tags":"","title":"Testing"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/testscript/","tags":"","title":"Testscript"},{"body":"Testscript for E2E Testing DSE Projects can use Testscript to run End-to-end tests (E2E) which are written in the (simple) txtar format. The containerised runtime supports both the Simer simulation runner as well as Taskfile based workflows.\nCode Layout and Test Organisation L- tests/testscript Directory containing Testscript tests. L- e2e Collection of E2E tests. L- testcase.txtar Individual testcase (in txtar format). L- Makefile High-level build automation. Example Test Files tests/exec.txtar env NAME=minimal_inst env SIM=dse/modelc/build/_out/examples/minimal env SANDBOX=dse/modelc/build/_out # TEST: MStep executable exec sh -e $WORK/test.sh stdout 'Model Function: model_step' stdout 'Starting Simulation \\(for 10 steps\\) ...' stdout 'step 9 \\(model_time=0.004500\\)' stdout 'Simulation complete.' stdout 'value: 10' -- test.sh -- cd /repo/$SIM /repo/$SANDBOX/bin/mstep \\ --logger 2 \\ --name $NAME \\ data/model.yaml \\ data/simulation.yaml tests/simer.txtar env NAME=minimal_inst env SIM=dse/modelc/build/_out/examples/minimal # TEST: minimal example model exec sh -e $WORK/test.sh stdout 'Load YAML File: data/simulation.yaml' stdout 'Loading symbol: model_create ... not found' stdout 'Loading symbol: model_step ... ok' stdout 'Loading symbol: model_destroy ... not found' stdout 'Run the Simulation ...' stdout 'Controller exit ...' stdout 'SignalValue: 2628574755 = 4.000000 \\[name=counter\\]' -- test.sh -- SIMER=\"${SIMER:-ghcr.io/boschglobal/dse-simer:latest}\" docker run --name simer -i --rm -v $ENTRYDIR/$SIM:/sim \\ $SIMER -valgrind $NAME -env $NAME:SIMBUS_LOGLEVEL=2 Makefile ############### ## Docker Images. TESTSCRIPT_IMAGE ?= ghcr.io/boschglobal/dse-testscript:main SIMER_IMAGE ?= ghcr.io/boschglobal/dse-simer:main ############### ## Test Parameters. export TESTSCRIPT_E2E_DIR ?= tests/testscript/e2e TESTSCRIPT_E2E_FILES = \\ $(TESTSCRIPT_E2E_DIR)/exec.txtar \\ $(TESTSCRIPT_E2E_DIR)/simer.txtar \\ .PHONY: test test: test_e2e .PHONY: test_e2e test_e2e: do-test_testscript-e2e do-test_testscript-e2e: # Test debug; add '-v' to Testscript command (e.g. $(TESTSCRIPT_IMAGE) -v \\). ifeq ($(PACKAGE_ARCH), linux-amd64) @set -eu; for t in $(TESTSCRIPT_E2E_FILES) ;\\ do \\ echo \"Running E2E Test: $$t\" ;\\ docker run -it --rm \\ -e ENTRYDIR=$$(pwd) \\ -v /var/run/docker.sock:/var/run/docker.sock \\ -v $$(pwd):/repo \\ $(TESTSCRIPT_IMAGE) \\ -e ENTRYDIR=$$(pwd) \\ -e SIMER=$(SIMER_IMAGE) \\ $$t ;\\ done; endif Testing Features and Integrations Testscript is provided as a containerised runtime with a minimal set of features and integrations. Use this runtime to run other containerised tools and advanced processing workflows.\nVolumes and Paths BUILDDIR - (go tests only) mapped to /builddir and contains the path of the related Makefile (which started Testscript). ENTRYHOSTDIR - mapped to /repo, host relative path of the repository root. ENTRYWORKDIR - (container runtime only) mapped to /workdir, will be a path generated by mktemp. REPODIR - mapped to /repo within the Testscript environment. WORKDIR - (container runtime only) mapped to /workdir within the Testscript environment. Docker Docker is included in the runtime and setup to access the host docker system.\nHint: When mapping a volume into a container use the ENTRYDIR full host path rather than /repo as the docker system will consider mount paths from the host perspective (rather than the perspective of the running container).\nTaskfile Task is included in the runtime, along with a set of CLI tools (i.e. curl) that a task might use. Typically a task would run a containerised workflow where additional tools are installed.\nTestscript Testscript is included in the runtime and is also set as the container ENTRYPOINT.\nTesting Techniques E2E / Smoke Tests Testscript can be used to write a simple E2E / Smoke test using the Simer simulation runner. The following minimal example shows how easily a test can be written:\nenv NAME=minimal_inst env SIM=dse/modelc/build/_out/examples/minimal exec sh -e $WORK/test.sh stdout 'SignalValue: 2628574755 = 4.000000 \\[name=counter\\]' -- test.sh -- SIMER=\"${SIMER:-ghcr.io/boschglobal/dse-simer:latest}\" docker run --name simer -i --rm -v $ENTRYDIR/$SIM:/sim \\ $SIMER -valgrind $NAME -env $NAME:SIMBUS_LOGLEVEL=2 References / Links Simer Testscript txtar Taskfile ","categories":"","description":"","excerpt":"Testscript for E2E Testing DSE Projects can use Testscript to run …","ref":"/dse.doc/docs/devel/testing/testscript/","tags":["Developer","Simer","Testing","Testscript"],"title":"Testing with Testscript"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/tags/trace/","tags":"","title":"trace"},{"body":"","categories":"","description":"","excerpt":"","ref":"/dse.doc/schemas/yaml/","tags":["Schema"],"title":"YAML Schemas"}]