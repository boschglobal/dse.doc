<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dynamic Simulation Environment</title><link>https://boschglobal.github.io/dse.doc/</link><description>Recent content on Dynamic Simulation Environment</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://boschglobal.github.io/dse.doc/index.xml" rel="self" type="application/rss+xml"/><item><title>Contributions Guide</title><link>https://boschglobal.github.io/dse.doc/docs/devel/contribution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/contribution/</guid><description>Synopsis Developers wishing to contribute, as well as those having no choice in the matter, will find this documentation page full of useful information to guide you towards finalising your contribution.
Git Commands Setup and Configure Git # Set user name and email (for signoff). git config --global --add user.name &amp;#34;User Name (dept)&amp;#34; git config --global --add user.email &amp;#34;user.name@de.bosch.com&amp;#34; Working with Commits Sign Off # Add a signoff to a commit.</description></item><item><title>Documentation Systems</title><link>https://boschglobal.github.io/dse.doc/docs/devel/documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/documentation/</guid><description>The documentation system is built by pulling content from individual Git Repos into a Hugo/Docsy project. The Hugo build system then consolidates that content into a single documentation system which is then published.
Hint: Documentation in each Git Repo needs to follow the same layout and structure as the Documentation Repo for the content to be merged correctly.
Layout Repo Documentation When writing documentation construct a layout as described in the following section.</description></item><item><title>Signal Vectors</title><link>https://boschglobal.github.io/dse.doc/docs/arch/signalvector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/signalvector/</guid><description>Synopsis The Dynamic Simulation Environment (DSE) presents models with a simple vector interface for the exchange of signals. Those signals can be either:
scalar : Internally represented as a 64bit storage container (double). These values are transparently exchanged between models. Models may cast/convert these scalar values to other types as required. binary : Binary strings, which may container embedded NULL values, can be exchanged between models. Additionally a binary signal may be annotated with a MIME type which describes the content of a binary signal.</description></item><item><title>Gateway Models</title><link>https://boschglobal.github.io/dse.doc/docs/arch/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/gateway/</guid><description>Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway API which can be used to connect remote simulations, via a gateway model, to a running DSE simulation. A gateway model takes care of signal exchange and time synchronisation between the remote simulation and the DSE simulation. Signals can be either scalar values or binary strings, the latter enabling virtual bus connections between simulation environments.
The gateway model runs in the remote simulation, and is written in that systems native language (or modelling construct).</description></item><item><title>FMI API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/fmi/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/fmi/</guid><description>storage_get_bucket Returns a reference/pointer to the requested storage bucket.
Parameters model_desc (FmuModelDesc*) Model Descriptor. type (storage_type) Indicate the storage type bucket which should be retrieved. Returns storage_bucket* Reference to the requested storage bucket. NULL The specified storage bucket is not provisioned. FMU Model API The FMU Model API (a part of the DSE C Lib) provides a simplified interface for developing Models which adhere to the Modelica Association FMI Standard. It has the following notable capabilities:</description></item><item><title>Gateway API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</guid><description>Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.
Component Diagram @startuml gateway-model title Gateway Model node &amp;#34;Dynamic Simulation Environment&amp;#34; { component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif } package &amp;#34;Gateway Model&amp;#34; { component &amp;#34;ModelC Lib&amp;#34; as ModelC component &amp;#34;Model&amp;#34; } SBif &amp;lt;-down- ModelC Model -up-&amp;gt; ModelC :model_gw_setup() Model -up-&amp;gt; ModelC :model_gw_sync() Model -up-&amp;gt; ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.</description></item><item><title>Schema: Manifest</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/manifest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/manifest/</guid><description>(v0.0.1)
Manifest kind: Manifest metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: repos: - name: string repo: string path: string registry: string user: string token: string tools: - name: string version: string repo: string arch: - string schema: string models: - name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ?</description></item><item><title>Marshal API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</guid><description>Marshal API The Marshal API supports two modes of operation:
Marshalling of intrinsic data types between source and target where the target represents externally defined data structures. Marshalling of signal maps between a signal interface and the source data objects (of the marshalling sub-system). When these operations are combined it becomes possible to map signals to externally defined data structures (i.e. C style structs).
Component Diagram @startuml data-marshal-interface skinparam nodesep 55 skinparam ranksep 40 title Marshal Interface interface &amp;#34;Signals&amp;#34; as sig package &amp;#34;Controller&amp;#34; { component &amp;#34;Source&amp;#34; as sou component &amp;#34;Target&amp;#34; as tar } sig -right-&amp;gt; sou : out sig &amp;lt;-right- sou : in sou -right-&amp;gt; tar : out sou &amp;lt;-right- tar : in center footer Dynamic Simulation Environment @enduml Typedefs MarshalGroup typedef struct MarshalGroup { char* name; int count; MarshalKind kind; MarshalDir dir; MarshalType type; struct (anonymous struct at dse/clib/data/marshal.</description></item><item><title>MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</guid><description>Model Compatibility Layer The Model Compatibility Layer (MCL) can be used to implement support for models which were written according to different a modeling interface. This is done by combining a Strategy and Adapter pattern to build an MCL which can load, execute and exchange data with a the foreign model.
Component Diagram @startuml mcl-component title Compatibility Layer component &amp;#34;ModelC&amp;#34; { component &amp;#34;MCL Model&amp;#34; as MCLmodel } component &amp;#34;MCL Lib&amp;#34; { interface &amp;#34;Strategy&amp;#34; as Sif interface &amp;#34;Adapter&amp;#34; as Aif component &amp;#34;MCL&amp;#34; as MCL } interface &amp;#34;Model Interface&amp;#34; as Mif component &amp;#34;Model&amp;#34; as Model MCLmodel --( Sif MCLmodel --( Aif Sif -- MCL Aif -- MCL MCL -( Mif Mif - Model center footer Dynamic Simulation Environment @enduml Typedefs MclAdapterDesc typedef struct MclAdapterDesc { const char* name; MclLoadHandler load_func; MclInitHandler init_func; MclStepHandler step_func; MclUnloadHandler unload_func; } MclInstanceDesc typedef struct MclInstanceDesc { int* model_instance; int* mcl_channel_sv; MclStrategyDesc* strategy; int models; } MclModelDesc typedef struct MclModelDesc { const char* name; int* model_doc; char* path; void* handle; double* vector_double; void** vector_binary; double model_time; double model_time_correction; double step_size; MclAdapterDesc* adapter; void* private; } MclStrategyDesc typedef struct MclStrategyDesc { const char* name; double model_time; double stop_time; MclExecuteMethod execute; MclExecuteHandler execute_func; MclMarshallOutHandler marshall_out_func; MclMarshallInHandler marshall_in_func; MclInstanceDesc* mcl_instance; } Functions mcl_create Creates an instance of an MCL Model.</description></item><item><title>Model API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/model/</guid><description>Model API The Model API allows model developers and integrators to implement models which can be connected to a Simulation Bus. Models are able to exchange signals with other models via this connection to a Simulation Bus. A runtime environment, such as the ModelC Runtime/Importer, will load the model and also manages the connection with the Simulation Bus.
The Model API provides two simple interfaces which facilitate the development of models; the Model Interface which is concerned with the model lifecycle; and the Signal Interface which facilitates signal exchange.</description></item><item><title>Schema: Model</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/model/</guid><description>(v0.0.1)
Model kind: Model metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: runtime: dynlib: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 executable: - os: string arch: string libs: - string annotations: ? property1 ? property2 gateway: annotations: ? property1 ? property2 mcl: - path: string os: string arch: string variant: string libs: - string annotations: ?</description></item><item><title>modelc</title><link>https://boschglobal.github.io/dse.doc/docs/user/tools/modelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/tools/modelc/</guid><description>modelc Run the model loader and executer.
Synopsis # Load and run a Model, specifying the Model, Stack and SignalGroup YAML files. $ dse.modelc --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml Options $ dse.modelc ModelC - model runner usage: [--transport &amp;lt;transport&amp;gt;] [--uri &amp;lt;endpoint&amp;gt;] (i.e. redis://localhost:6379) [--host &amp;lt;host url&amp;gt;] *** depreciated, use --uri *** [--port &amp;lt;port number&amp;gt;] *** depreciated, use --uri *** [--stepsize &amp;lt;double&amp;gt;] [--endtime &amp;lt;double&amp;gt;] [--uid &amp;lt;model uid&amp;gt;] [--name &amp;lt;model name&amp;gt;] *** normally required *** [--timeout &amp;lt;double&amp;gt;] [--logger &amp;lt;number&amp;gt;] 0.</description></item><item><title>Model C Debug Techniques</title><link>https://boschglobal.github.io/dse.doc/docs/devel/modelc_debug/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/modelc_debug/</guid><description>GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB debugging with the following technique:
In the main Makefile, add the GDB_CMD environment variable (i.e. --env GDB_CMD=&amp;quot;$(GDB_CMD)&amp;quot;) to every DOCKER_CMD that requires interactive GDB debugging support.
For each Makefile run target where interactive GDB debugging is required, prefix the run command with the GDB_CMD variable, for example: cd build/_out; $(GDB_CMD) bin/test_tdd.
Set the GDB_CMD environment variable with your GDB command (e.</description></item><item><title>Model C with Network Codec</title><link>https://boschglobal.github.io/dse.doc/docs/devel/modelc_ncodec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/modelc_ncodec/</guid><description>Network Codec The Model C Library integrates the DSE Network Codec implementation of the Automotive Bus schemas.
Configuration of Binary Signals IMPORTANT: It is recommended to specify a SignalGroup for each individual Model Instance in a Simulation. This is so that the MIMEtype of each Binary Signal can be completely configured (especially bus_id,node_id and interface_id). Models may implement supplemental configuration options (such as annotations on the Model Instance definition) which can further adjust or augment the MIMEtype parameters.</description></item><item><title>mstep</title><link>https://boschglobal.github.io/dse.doc/docs/user/tools/mstep/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/tools/mstep/</guid><description>mstep Debug tool to load and step a model through a simulation.
Synopsis # Load and step a Model, specifying the Model, Stack and SignalGroup YAML files. $ dse.mstep --logger 2 --name binary_model_instance model.yaml stack.yaml signal_group.yaml Options $ mstep --help Model Loader and Stepper usage: [--transport &amp;lt;transport&amp;gt;] [--uri &amp;lt;endpoint&amp;gt;] (i.e. redis://localhost:6379) [--host &amp;lt;host url&amp;gt;] *** depreciated, use --uri *** [--port &amp;lt;port number&amp;gt;] *** depreciated, use --uri *** [--stepsize &amp;lt;double&amp;gt;] [--endtime &amp;lt;double&amp;gt;] [--uid &amp;lt;model uid&amp;gt;] [--name &amp;lt;model name&amp;gt;] *** normally required *** [--timeout &amp;lt;double&amp;gt;] [--logger &amp;lt;number&amp;gt;] 0.</description></item><item><title>Network Codec API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/ncodec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/ncodec/</guid><description>Network Codec A Network Codec has two interfaces: a Codec Interface which is used to encode/decode message from a Model/Device (connected to a Network), and a Stream Interface which is used to exchange the encoded messages with other Model/Devices connected to the same Network.
The Network Codec API (codec.h &amp;amp; codec.c) provides the framework for implementing both the Codec Interface and the Stream Interface. A typical realisation of this scheme would be:</description></item><item><title>Schema: Network</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/network/</guid><description>(v1.0.0)
Network kind: Network metadata: name: CAN1 annotations: message_lib: examples/stub/data/message.so function_lib: examples/stub/data/function.so spec: messages: - message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t - signal: Alive annotations: struct_member_name: alive struct_member_offset: 1 struct_member_primitive_type: uint8 - signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t functions: encode: - function: counter_inc_uint8 annotations: position: 1 - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network definition.</description></item><item><title>Schema: ParameterSet</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/parameterset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/parameterset/</guid><description>(v0.0.1)
ParameterSet kind: ParameterSet metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: parameters: - parameter: string value: string annotations: ? property1 ? property2 A parameter_set definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.</description></item><item><title>Schema: Propagator</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/propagator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/propagator/</guid><description>(v0.0.1)
Propagator kind: Propagator metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: options: direction: both signals: - signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A propagator definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object.</description></item><item><title>Schema: Runnable</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/runnable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/runnable/</guid><description>(v1.0.0)
Runnable kind: Runnable metadata: name: target annotations: target_lib: examples/stub/lib/target.so spec: tasks: - function: task_init schedule: 0 - function: task_5ms schedule: 5 - function: task_10ms schedule: 10 - function: task_20ms schedule: 20 - function: task_40ms schedule: 40 A Runnable definition.
Supported annotations: Annotation Description target_lib Relative path of the shared library containing the Runnable library. Properties Name Type Required Description kind string true none metadata object false Information relating to an object.</description></item><item><title>Runtime API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</guid><description>Runtime API The Runtime API provides methods for implementing a model Runtime/Importer which can be used to load, configure and execute a model.
Typedefs ChannelSpec typedef struct ChannelSpec { const char* name; const char* alias; void* private; } ModelCArguments typedef struct ModelCArguments { const char* transport; char* uri; const char* host; int port; double timeout; int log_level; double step_size; double end_time; int uid; const char* name; const char* file; const char* path; void* yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; int steps; } ModelChannelDesc typedef struct ModelChannelDesc { const char* name; const char* function_name; const char** signal_names; int signal_count; int propagator_source_channel; int propagator_target_channel; double* vector_double; void** vector_binary; int* vector_binary_size; int* vector_binary_buffer_size; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char* name; const char* path; const char* file; char* full_path; void* doc; void* channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { int uid; char* name; int* model_desc; ModelDefinitionSpec model_definition; void* spec; void* yaml_doc_list; void* private; } SimulationSpec typedef struct SimulationSpec { const char* transport; char* uri; int uid; double timeout; double step_size; double end_time; ModelInstanceSpec* instance_list; } Functions modelc_destroy Bypass the controller and call model_destroy() directly.</description></item><item><title>Schema API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</guid><description>Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.
Typedefs SchemaLabel typedef struct SchemaLabel { const char* name; const char* value; } SchemaObject typedef struct SchemaObject { const char* kind; const char* name; void* doc; void* data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char* kind; const char* name; SchemaLabel* labels; int labels_len; void* data; } SchemaSignalObject typedef struct SchemaSignalObject { const char* signal; void* data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec.</description></item><item><title>Schema: SignalData</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/signaldata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/signaldata/</guid><description>(v0.0.1)
SignalData Data = [[0..N],[0..N]] MsgPack encoded Signal Data. Number of elements in each nested array should be identical.
Properties oneOf
Name Type Required Description anonymous SignalUid false Signal UID. xor
Name Type Required Description anonymous SignalValueNumeric false Numeric signal value. The value may be encoded as any integer or float type. xor
Name Type Required Description anonymous SignalValueBinary false Binary signal value. SignalUid 0 Signal UID.
Properties Name Type Required Description anonymous integer(int32) false Signal UID.</description></item><item><title>Schema: SignalGroup</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/signalgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/signalgroup/</guid><description>(v0.0.1)
SignalGroup kind: SignalGroup metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: signals: - signal: string transform: linear: factor: 0 offset: 0 annotations: ? property1 ? property2 A signal group definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.</description></item><item><title>simbus</title><link>https://boschglobal.github.io/dse.doc/docs/user/tools/simbus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/tools/simbus/</guid><description>simbus Run the SimBus.
Synopsis # Run the SimBus, specifying the Stack YAML file. $ dse.simbus --logger 2 --timeout 1 stack.yaml Options $ simbus --help Standalone SimBus usage: [--transport &amp;lt;transport&amp;gt;] [--uri &amp;lt;endpoint&amp;gt;] (i.e. redis://localhost:6379) [--host &amp;lt;host url&amp;gt;] *** depreciated, use --uri *** [--port &amp;lt;port number&amp;gt;] *** depreciated, use --uri *** [--stepsize &amp;lt;double&amp;gt;] [--endtime &amp;lt;double&amp;gt;] [--uid &amp;lt;model uid&amp;gt;] [--name &amp;lt;model name&amp;gt;] *** normally required *** [--timeout &amp;lt;double&amp;gt;] [--logger &amp;lt;number&amp;gt;] 0..6 *** 0=more, 6=less, 3=INFO *** [--file &amp;lt;model file&amp;gt;] [--path &amp;lt;path to model&amp;gt;] *** relative path to Model Package *** [YAML FILE [,YAML FILE] .</description></item><item><title>SimMock API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</guid><description>SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC &amp;lt;-&amp;gt; SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.
Component Diagram @startuml simmock-objects title SimMock Objects package &amp;#34;SimBus Mock&amp;#34; { class Signal &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +double scalar[] +annotation() } class Network &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.</description></item><item><title>Schema: Stack</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/stack/</guid><description>(v0.0.1)
Stack kind: Stack metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: connection: timeout: string transport: redis: uri: string timeout: 0 runtime: env: property1: string property2: string stacked: true models: - name: string uid: 0 annotations: ? property1 ? property2 model: name: string mcl: strategy: string models: - name: string runtime: env: property1: string property2: string files: - string x32: true channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ?</description></item><item><title>Testing with CMocka</title><link>https://boschglobal.github.io/dse.doc/docs/devel/modelc_cmocka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/modelc_cmocka/</guid><description>CMocka Testing for C Code The DSE Projects use CMocka for both Unit and Integration testing. This document introduces the typical CMocka Test Project and explains the testing features which are most often used when developing.
Code Layout and Test Organisation L- tests/cmocka Directory containing CMocka tests. L- target An individual test target (single test executable). L- __tests__.c Entry point for the test target (runs test groups). L- test_foo.c Contains a test group (e.</description></item><item><title>Testing Models with SimMock</title><link>https://boschglobal.github.io/dse.doc/docs/devel/modelc_simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/modelc_simmock/</guid><description>SimMock and CMocka Testing for Model Developers The DSE ModelC Library includes a SimMock source code library which may be used to develop integration tests for Models. With the SimMock library, a Model Developer is able to easily develop CMocka Testcases which:
Validate a model configuration and confirm the Models operation. Develop scenarios where expected signal exchange is verified. Inject network messages into the simulation or model (e.g. CAN frames) and read network messages.</description></item><item><title>Testing with Testscript</title><link>https://boschglobal.github.io/dse.doc/docs/devel/modelc_testscript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/modelc_testscript/</guid><description>Testscript for E2E Testing DSE Projects can use Testscript to run End-to-end tests (E2E) which are written in the (simple) txtar format. The containerised runtime supports both the Simer simulation runner as well as Taskfile based workflows.
Code Layout and Test Organisation L- tests/testscript Directory containing Testscript tests. L- e2e Collection of E2E tests. L- testcase.txtar Individual testcase (in txtar format). L- Makefile High-level build automation. Example Test Files tests/exec.txtar env NAME=minimal_inst env SIM=dse/modelc/build/_out/examples/minimal env SANDBOX=dse/modelc/build/_out # TEST: MStep executable exec sh -e $WORK/test.</description></item></channel></rss>