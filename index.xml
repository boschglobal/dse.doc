<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dynamic Simulation Environment</title><link>https://boschglobal.github.io/dse.doc/</link><description>Recent content on Dynamic Simulation Environment</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://boschglobal.github.io/dse.doc/index.xml" rel="self" type="application/rss+xml"/><item><title>C4 Architecture Diagrams</title><link>https://boschglobal.github.io/dse.doc/docs/arch/c4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/c4/</guid><description>C1 System System Context C2 Container Interop Native Virtual ECU C3 Component Bootloader Runnable Model Composite Model Gateway FMI MCL C4</description></item><item><title>Builder - Simulation Development Platform</title><link>https://boschglobal.github.io/dse.doc/docs/user/builder/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/builder/</guid><description>Synopsis Containerised simulation builder with DSL (DSE Script).
Describe a Simulation simulation arch=linux-amd64 channel network uses dse.fmi https://github.com/boschglobal/dse.fmi v1.1.32 model fmu_CAN dse.fmi.network_model channel network network_channel workflow generate-model var NETWORK_SIGNAL can_bus var MIME_TYPE &amp;#34;application/x-automotive-bus;interface=stream;type=frame;bus=can;schema=fbs;bus_id=1;node_id=2;interface_id=3&amp;#34; var MEASUREMENT measurement.txt var OUT_DIR {{.PATH}}/data workflow generate-fmimodelc var FMU_NAME example var SIGNAL_GROUPS network Use the Builder Tool # Build a simulation. $ cd examples/runnable $ builder runnable.dse $ task -y Run the Simulation # Run a simulation.</description></item><item><title>Contributions Guide</title><link>https://boschglobal.github.io/dse.doc/docs/devel/contribution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/contribution/</guid><description>Synopsis Developers wishing to contribute, as well as those having no choice in the matter, will find this documentation page full of useful information to guide you towards finalising your contribution.
Git Commands Setup and Configure Git # Set user name and email (for signoff). git config --global --add user.name &amp;#34;User Name (dept)&amp;#34; git config --global --add user.email &amp;#34;user.name@de.bosch.com&amp;#34; Working with Commits Sign Off # Add a signoff to a commit.</description></item><item><title>Documentation Systems</title><link>https://boschglobal.github.io/dse.doc/docs/devel/documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/documentation/</guid><description>The documentation system is built by pulling content from individual Git Repos into a Hugo/Docsy project. The Hugo build system then consolidates that content into a single documentation system which is then published.
Hint: Documentation in each Git Repo needs to follow the same layout and structure as the Documentation Repo for the content to be merged correctly.
Layout Repo Documentation When writing documentation construct a layout as described in the following section.</description></item><item><title>Simer - Simulation Runner</title><link>https://boschglobal.github.io/dse.doc/docs/user/simer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/simer/</guid><description>Synopsis Containerised simulation run-time.
# Run a simulation. $ simer path/to/simulation -stepsize 0.0005 -endtime 0.04 Simulation Setup Structure The structure of a simulation is flexible and can be arranged based on individual project needs. All paths used within a simulation configuration should be relative to the root of the simulation folder (i.e. the simulation path). The simer tool will search for YAML files contained within the simulation path and automatically configure, and then run, the contained simulation.</description></item><item><title>SDP Workflows</title><link>https://boschglobal.github.io/dse.doc/docs/devel/sdp/workflows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/sdp/workflows/</guid><description>The SDP builds simulations using Git repositories which contain both models and their associated workflows. The workflows are defined using Task, and implemented with containerized tool-chains. Additional metadata, embedded in the Taskfile, makes is possible for the SDP to automate the task of configuring and operating the workflows.
Layout Go based Tools Models are typically written in the C Language using an established repository layout. Within that layout, workflow tools can be written in any programming language.</description></item><item><title>Report - Simulation Validation</title><link>https://boschglobal.github.io/dse.doc/docs/user/report/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/report/</guid><description>Synopsis Containerized simulation validation tool for Simer based simulations.
# Run the reports. $ dse-report path/to/simulation Report Tool Codespace The Codespace (aka Devcontainer) of the DSE Simulation Development Platform is pre-configured with a command for running the Report tool.
# Run the reports. $ dse-report path/to/simulation Setup Report is a containerized tool which validates a simulation using a collection of report templates included in the Report container.
# Latest Report Container: $ docker pull ghcr.</description></item><item><title>Guide : Simulation Development Platform (SDP)</title><link>https://boschglobal.github.io/dse.doc/docs/user/guides/sdp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/guides/sdp/</guid><description>Synopsis Simulation Development Platform (SDP) using Codespaces or DevContainers to code, build, and run DSE Simulations.
Setup GitHub Codespaces GitHub Codespaces provides a cloud-hosted development environment which is pre-configured for the SDP. This environment includes SDP Extensions and can be immediately used to build and run simulations.
Steps to use Codespaces: Go to the repository on GitHub. Click the Code button and choose Open with Codespaces. If you don’t have an existing codespace, click New codespace to create one.</description></item><item><title>AST - AST Tools</title><link>https://boschglobal.github.io/dse.doc/docs/tools/ast/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/tools/ast/</guid><description>Synopsis AST Tools.
$ dse-ast &amp;lt;command&amp;gt; [flags] The dse-ast toolchain provides commands for processing and transforming Abstract Syntax Trees (ASTs) in YAML format, based on input JSON.
Commands convert Transform the JSON into a YAML-based Abstract Syntax Tree (AST).
$ dse-ast convert -input &amp;lt;json_file_path&amp;gt; -output &amp;lt;yaml_ast_output_path&amp;gt; resolve Resolve internal references within the AST to produce a fully linked version.
$ dse-ast resolve -input &amp;lt;yaml_ast_path&amp;gt; -output &amp;lt;yaml_ast_output_path&amp;gt; generate Generate the final output simulation files based on the resolved AST.</description></item><item><title>Model - CSV</title><link>https://boschglobal.github.io/dse.doc/docs/user/models/csv/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/models/csv/</guid><description>Synposis A model for setting simulation signals with values read from a CSV file.
Model Structure examples/csv └── sim ├── data │ └── simulation.yml └── model └── input └── lib/libcsv.so └── data └── model.yml └── valueset.csv &amp;lt;-- CSV File. CSV File Timestamp;A;B;C 0.0000;1.0;2.0;3.0 0.0005;-1.1;2.1;3.1 0.0010;1.2;-2.2;3.2 0.0015;1.3;2.3;-3.3 Examples Simulation / DSE Script simulation channel physical uses dse.modelc https://github.com/boschglobal/dse.modelc v2.1.32 model input dse.modelc.csv channel physical signal_channel envar CSV_FILE model/input/data/valueset.csv file valueset.csv input.csv Simulation / Stack --- kind: Stack metadata: name: csv_stack spec: connection: transport: redispubsub: uri: redis://localhost:6379 timeout: 60 models: - name: simbus model: name: simbus channels: - name: physical expectedModelCount: 1 - name: input uid: 42 model: name: dse.</description></item><item><title>DSL - DSL Tools</title><link>https://boschglobal.github.io/dse.doc/docs/tools/dsl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/tools/dsl/</guid><description>Synopsis DSL Tools.
$ dse-parse2ast [args] Commands dse-parse2ast Convert a DSE file into an intermediate JSON representation.
$ dse-parse2ast &amp;lt;dse_file_path&amp;gt; &amp;lt;json_output_file_path&amp;gt; Keywords simulation Defines the simulation setup including architecture, stepsize, and endtime.
simulation arch=linux-amd64 stepsize=0.0005 endtime=0.005
arch Specifies the architecture in simulation or stack or model level (default : linux-amd64 ).
simulation arch=linux-amd64
stepsize Time increment for each simulation step (default : 0.0005).
simulation stepsize=0.0005
endtime Total simulation duration step (default : 0.</description></item><item><title>Graph - Graph Tools</title><link>https://boschglobal.github.io/dse.doc/docs/tools/graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/tools/graph/</guid><description>Synopsis Graph Tools for static and dynamic analysis of Simulations.
$ dse-graph report examples/graph/&amp;lt;sim-name&amp;gt;/&amp;lt;sim-status&amp;gt; Commands The Graph tool includes the following commands and options:
Drop $ dse-graph drop &amp;lt;sim|ast|-all&amp;gt; Import dse-graph import examples/graph/&amp;lt;sim-name&amp;gt;/&amp;lt;sim-status&amp;gt; Export $ dse-graph export export.cyp Report dse-graph report examples/graph/&amp;lt;sim-name&amp;gt;/&amp;lt;sim-status&amp;gt; Option Tag (-tag) dse-graph report -tag=tag_name examples/graph/&amp;lt;sim-name&amp;gt;/&amp;lt;sim-status&amp;gt; Option List (-list) dse-graph report &amp;lt;-list|-list-all|-list-tags&amp;gt; Option Name (-name) dse-graph report -name=&amp;#34;Report1;Report2&amp;#34; examples/graph/&amp;lt;sim-name&amp;gt;/&amp;lt;sim-status&amp;gt; Option Reports (-reports) dse-graph report -reports=path/to/reports examples/graph/&amp;lt;sim-name&amp;gt;/&amp;lt;sim-status&amp;gt; Report Appliance Usage # Start the memgraph container (using a make target).</description></item><item><title>LSP - LSP Tools</title><link>https://boschglobal.github.io/dse.doc/docs/tools/lsp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/tools/lsp/</guid><description>Synopsis LSP Tools.
Live AST View The extension supports live viewing of the models and channels derived from .dse files
To view the AST preview Open a supported .dse file in the VS Code editor. Click the Open Preview button in the upper-right corner of the editor window. Alternatively, you can use keyboard shortcuts Press Ctrl + K V to open preview in a side panel. Press Ctrl + Shift + V to open preview in the main panel.</description></item><item><title>Trace - Simulation Trace Tool</title><link>https://boschglobal.github.io/dse.doc/docs/tools/trace/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/tools/trace/</guid><description>Synopsis Simulation trace tool.
# Create the trace folder. $ mkdir examples/binary/data/trace # Collect a SimBus trace from a simulation run. $ docker run --name simer -i --rm \ --volume ./examples/binary:/sim \ --env SIMBUS_TRACEFILE=data/trace/simbus.bin \ ghcr.io/boschglobal/dse-simer:latest # Print a long-form summary of the trace file. $ docker run --name simer -i --rm \ --volume ./examples/binary:/sim \ --entrypoint /usr/local/bin/trace \ ghcr.io/boschglobal/dse-simer:latest summary -long data/trace/simbus.bin Commands The Trace tool includes the following commands and options:</description></item><item><title>FMI Gateway FMU</title><link>https://boschglobal.github.io/dse.doc/docs/user/models/fmi/fmigateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/models/fmi/fmigateway/</guid><description>Synposis FMI Gateway FMU
Simulation Setup Structure Example Simulation Setup DOC: Provide description of Gateway Taskfile workflows.
Operation The configuration and operation of the gateway is done in the stack.yaml that is to be loaded by the gateway. The stack follows the following schema with some additional, gateway specific annotations/ additions.
Stack Metadata Name Type Required Description metadata object true none » name string true This field is required to be named &amp;ldquo;gateway&amp;rdquo; » annotation object false none »» start_redis boolean true Set to false with no redis instance should be started on windows, can be controlled via environment variable »» create_logfiles boolean false Set to true to create Logfiles of the started models, can be controlled via environment variable »» show_redis boolean false Set to true if the redis process should be shown as terminal window, can be controlled via environment variable »» show_simbus boolean false Set to true if the simbus process should be shown as terminal window, can be controlled via environment variable »» show_models boolean false Set to true if the model processes should be shown as terminal windows, can be controlled via environment variable »» model_stack string false Name of the Stack.</description></item><item><title>FMI Model Compatibility Library</title><link>https://boschglobal.github.io/dse.doc/docs/user/models/fmi/fmimcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/models/fmi/fmimcl/</guid><description>Synposis FMI Model Compatibility Library
Simulation Setup Structure Example Simulation Setup DOC: Provide description of FMI MCL Taskfile workflows.
Operation Measurement The FMI MCL can be configured to produce an MDF measurement file for scalar signals of the FMUs interface, including FMI Variables with &amp;rsquo;local&amp;rsquo; causality.
Note: the path of the measurement file is relative to the simulation path (i.e. /sim/&amp;hellip;).
# Using Simer; enable measurement on the FMU represented by &amp;#39;fmu_inst&amp;#39;.</description></item><item><title>FMI ModelC FMU</title><link>https://boschglobal.github.io/dse.doc/docs/user/models/fmi/fmimodelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/models/fmi/fmimodelc/</guid><description>Synposis FMI ModelC FMU
Simulation Setup Structure Example Simulation FMU Setup DOC: Provide description of FMI ModelC FMU Taskfile workflows.
FMU Operation DOC: Operation.</description></item><item><title>ModelC Environment Variables</title><link>https://boschglobal.github.io/dse.doc/docs/user/envars/modelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/envars/modelc/</guid><description>Tool Specific Environment Variables ModelC Variable CLI Option Default NCODEC_TRACE_LOG N/A None NCODEC_TRACE_{bus}_{bus_id} N/A None NCODEC_TRACE_PDU_{swc_id} N/A None SIMBUS_LOGLEVEL --logger 4 (LOG_NOTICE) SIMBUS_TRANSPORT --transport redispubsub SIMBUS_URI --uri redis://localhost:6379 SIMBUS_TIMEOUT --timeout 60 (seconds) SimBus Variable CLI Option Default SIMBUS_LOGLEVEL --logger 4 (LOG_NOTICE) SIMBUS_TRACEFILE N/A None (trace disabled, path to trace file) SIMBUS_TRANSPORT --transport redispubsub SIMBUS_URI --uri redis://localhost:6379 SIMBUS_TIMEOUT --timeout 60 (seconds) Examples Benchmark Variable CLI Option Default MODEL_ID N/A 1 SIGNAL_CHANGE N/A 5 STARTUP_ANNO N/A 1 STARTUP_IDX N/A 1 TAG N/A None (a log prefix, configure as a string) Block Variable CLI Option Default MODEL_COUNT N/A 1 MODEL_ID N/A 1 CSV Variable CLI Option Default CSV_FILE N/A None (path to CSV file) CSV_LINE_MAXLEN N/A 1ß24</description></item><item><title>Model C with Network Codec</title><link>https://boschglobal.github.io/dse.doc/docs/devel/ncodec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/ncodec/</guid><description>Network Codec The Model C Library integrates the DSE Network Codec implementation of the Automotive Bus schemas.
Configuration of Binary Signals IMPORTANT: It is recommended to specify a SignalGroup for each individual Model Instance in a Simulation. This is so that the MIMEtype of each Binary Signal can be completely configured (especially bus_id,node_id and interface_id). Models may implement supplemental configuration options (such as annotations on the Model Instance definition) which can further adjust or augment the MIMEtype parameters.</description></item><item><title>Workflow - Network Model</title><link>https://boschglobal.github.io/dse.doc/docs/user/workflows/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/workflows/network/</guid><description>Synposis Workflow Structure Transformations Simulation (DSE) {{readFile &amp;ldquo;example.md&amp;rdquo;}}
Workflow Example task generate-network {{readFile &amp;ldquo;task.md&amp;rdquo;}}</description></item><item><title>SDP Environment Variables</title><link>https://boschglobal.github.io/dse.doc/docs/user/envars/sdp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/envars/sdp/</guid><description>Container Specific Environment Variables Tool Specific Variable Default SIMER_IMAGE ghcr.io/boschglobal/dse-simer:latest BUILDER_IMAGE ghcr.io/boschglobal/dse-builder:latest REPORT_IMAGE ghcr.io/boschglobal/dse-report:latest Workflow Specific Variable Default FMI_IMAGE ghcr.io/boschglobal/dse-fmi FMI_TAG latest Note: this pattern of IMAGE and TAG is repeated for all repos which contain workflows.</description></item><item><title>Simulation Framework Benchmark</title><link>https://boschglobal.github.io/dse.doc/docs/arch/benchmark/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/benchmark/</guid><description>Overview The following Simulation Framework Benchmarks give an understanding of how the Dynamic Simulation Environment performs for a variety of simulation topologies. This information can be used to decide on a deployment strategy for a simulation that takes into account:
The total number of signals in a simulation. How many models are configured in a simulation. The expected amount of signal exchange per simulation step (throughput). Each of these benchmarks are evaluated across a subset of recommended simulation topologies.</description></item><item><title>Simulation Topology</title><link>https://boschglobal.github.io/dse.doc/docs/arch/topology/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/topology/</guid><description>Overview The Dynamic Simulation Environment provides several simulation topologies, all of which support distributed simulations, that may incorporate models running on multiple OS/Arch combinations or running in multiple simulation environments.
These topologies include:
Standalone - Stacked model instances running in a single process. Uses a Loopback SimBus. Distributed - Distributed model instances, multi process, multi OS, optionally stacked. Uses a Redis SimBus. Gateway - Remote simulation systems are connected with a gateway model.</description></item><item><title>Simulation Transports</title><link>https://boschglobal.github.io/dse.doc/docs/arch/transport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/transport/</guid><description>Overview A Simulation Transport specifies how data-exchange between Models is facilitated by a simulation environment. Each transport has its own specific properties and the selection of a transport will be determined by the planned operational deployment of a simulation.
Transport Latency Status Loopback Fastest Available, stacked simulations (single process). TCP Fastest Planned. Redis Faster Recommended. Redis PubSub Fast Available, stable. RESP Fast Under consideration, for cloud connectivity (tunnelling). gPPC Fast Under consideration, for cloud connectivity (HTTP).</description></item><item><title>Model Compatibility Library</title><link>https://boschglobal.github.io/dse.doc/docs/arch/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/mcl/</guid><description>Synopsis The Model Compatibility Library (MCL) of the Dynamic Simulation Environment (DSE) is a representation of an Architectural Pattern for supporting 3rd-party model interfaces in a DSE Simulation. To support a model interface an implementation will need to implement the MCL API (i.e. MclVTable) and may also optionally use the Marshal API to manage signal/variable exchange with the model being interfaced.
Design Deployment Configuration References MCL API Marshal API FMI MCL - An MCL implementation for the Modelica FMI Standard.</description></item><item><title>Signal Vectors</title><link>https://boschglobal.github.io/dse.doc/docs/arch/signalvector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/signalvector/</guid><description>Synopsis The Dynamic Simulation Environment (DSE) presents models with a simple vector interface for the exchange of signals. Those signals can be either:
scalar : Internally represented as a 64bit storage container (double). These values are transparently exchanged between models. Models may cast/convert these scalar values to other types as required. binary : Binary strings, which may container embedded NULL values, can be exchanged between models. Additionally a binary signal may be annotated with a MIME type which describes the content of a binary signal.</description></item><item><title>Gateway Models</title><link>https://boschglobal.github.io/dse.doc/docs/arch/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/gateway/</guid><description>Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway API which can be used to connect remote simulations, via a gateway model, to a running DSE simulation. A gateway model takes care of signal exchange and time synchronisation between the remote simulation and the DSE simulation. Signals can be either scalar values or binary strings, the latter enabling virtual bus connections between simulation environments.
The gateway model runs in the remote simulation, and is written in that systems native language (or modelling construct).</description></item><item><title>Testing with CMocka</title><link>https://boschglobal.github.io/dse.doc/docs/devel/testing/cmocka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/testing/cmocka/</guid><description>CMocka Testing for C Code The DSE Projects use CMocka for both Unit and Integration testing. This document introduces the typical CMocka Test Project and explains the testing features which are most often used when developing.
Code Layout and Test Organisation L- tests/cmocka Directory containing CMocka tests. L- target An individual test target (single test executable). L- __tests__.c Entry point for the test target (runs test groups). L- test_foo.c Contains a test group (e.</description></item><item><title>FMU API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmu/</guid><description>fmi2GetString Get values for the provided list of value references.
Parameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU. vr (fmi2ValueReference[]) List of value references to retrieve. nvr (int) The number of value references to retrieve. value (fmi2String[]) Storage for the retrieved values. Returns fmi2OK (fmi2Status) The requested variables are retrieved (where available). fmi2SetReal Set values for the provided list of value references and values.
Parameters c (fmi2Component*) An FmuInstanceData object representing an instance of this FMU.</description></item><item><title>Example Network Function API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/network/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/network/functions/</guid><description>Example Network Functions Example implementation of Network Functions.
Typedefs InstanceData typedef struct InstanceData { int position; } Functions counter_inc_uint8 Increment an 8-bit counter in the message packet.
Note: in the encode path, changes to the counter are not reflected in the corresponding signal. Subsequent calls to network_message_recalculate may overwrite the modified counter.
Parameters data (void**) Pointer reference for instance data. payload (uint8_t*) The payload that this function will modify. payload_len (size_t) The length of the payload.</description></item><item><title>Gateway API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</guid><description>Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.
Component Diagram @startuml gateway-model title Gateway Model node &amp;#34;Dynamic Simulation Environment&amp;#34; { component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif } package &amp;#34;Gateway Model&amp;#34; { component &amp;#34;ModelC Lib&amp;#34; as ModelC component &amp;#34;Model&amp;#34; } SBif &amp;lt;-down- ModelC Model -up-&amp;gt; ModelC :model_gw_setup() Model -up-&amp;gt; ModelC :model_gw_sync() Model -up-&amp;gt; ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.</description></item><item><title>FMI Gateway FMU API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmigateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmigateway/</guid><description>fmu_init In this method the required yaml files are parsed and the session is configured, if required. The gateway is set up and connected to the simbus. After a sucessfull connection has been established, the fmu variables are indexed to their corresponding simbus signals.
Required by FMU.
Parameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. Returns 0 (int32_t) The FMU was created correctly. fmu_step This method executes one step of the gateway model and signals are exchanged with the other simulation participants.</description></item><item><title>INI FIle API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/ini/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/ini/</guid><description>INI File API Simple INI File API for reading and modifying INI files.
Example The following example demonstrates how to use the INI File API.
// Copyright 2025 Robert Bosch GmbH #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;dse/clib/ini/ini.h&amp;gt; #define INI_FILE &amp;#34;dse_clib.ini&amp;#34; int main(void) { // Open and read an INI file (if it exists). IniDesc ini = ini_open(INI_FILE); // Get an INI value. printf(&amp;#34;foo (initial value) = %s\n&amp;#34;, ini_get_val(&amp;amp;ini, &amp;#34;foo&amp;#34;)); // Set an INI value.</description></item><item><title>Schema: Manifest</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/manifest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/manifest/</guid><description>(v0.0.1)
Manifest kind: Manifest metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: repos: - name: string repo: string path: string registry: string user: string token: string tools: - name: string version: string repo: string arch: - string schema: string models: - name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ?</description></item><item><title>Marshal API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</guid><description>Marshal API The Marshal API supports two modes of operation:
Marshalling of intrinsic data types between source and target where the target represents externally defined data structures. Marshalling of signal maps between a signal interface and the source data objects (of the marshalling sub-system). When these operations are combined it becomes possible to map signals to externally defined data structures (i.e. C style structs).
Component Diagram @startuml data-marshal-interface skinparam nodesep 55 skinparam ranksep 40 title Marshal Interface interface &amp;#34;Signals&amp;#34; as sig package &amp;#34;Controller&amp;#34; { component &amp;#34;Source&amp;#34; as sou component &amp;#34;Target&amp;#34; as tar } sig -right-&amp;gt; sou : out sig &amp;lt;-right- sou : in sou -right-&amp;gt; tar : out sou &amp;lt;-right- tar : in center footer Dynamic Simulation Environment @enduml Typedefs MarshalGroup typedef struct MarshalGroup { char* name; int count; MarshalKind kind; MarshalDir dir; MarshalType type; struct { uint32_t* ref; struct { int32_t* _int32; uint64_t* _uint64; double* _double; char** _string; void** _binary; void* ptr; } _binary_len; } target; struct { int offset; struct { double* scalar; void** binary; } binary_len; } source; struct { MarshalStringEncode* string_encode; MarshalStringDecode* string_decode; } functions; uint64_t [4] __reserved__; } MarshalMapSpec typedef struct MarshalMapSpec { const char* name; int count; bool is_binary; const char** signal; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; uint64_t [4] __reserved__; } MarshalSignalMap typedef struct MarshalSignalMap { char* name; int count; bool is_binary; struct { int* index; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; } signal; struct { int* index; struct { double* scalar; void** binary; } binary_len; } source; uint64_t [4] __reserved__; } MarshalStruct typedef struct MarshalStruct { char* name; int count; void* handle; MarshalKind kind; MarshalDir dir; struct { MarshalType* type; int* offset; int* length; } target; struct { int* index; void** pdata; struct { double* scalar; void** binary; } binary_len; uint32_t* binary_buffer_size; } source; uint64_t [4] __reserved__; } Functions marshal_generate_signalmap Creates a signal map between signals (i.</description></item><item><title>FMI MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmimcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmimcl/</guid><description>FMI Model Compatibility Library The FMI Model Compatibility Library provides an interfaces for loading and operating FMUs.
Sequence Diagram @startuml fmimcl-sequence title FMI MCL - Sequence actor User participant ModelC participant MCL participant MARSHAL participant FMIMCL participant ENGINE participant ADAPTER participant COMPONENT User -&amp;gt; ModelC : model_create() activate ModelC ModelC -&amp;gt; MCL : MCL_create() activate MCL MCL -&amp;gt; FMIMCL : fmimcl_parse() activate FMIMCL FMIMCL -&amp;gt; FMIMCL : parse yaml FMIMCL -&amp;gt; MCL deactivate FMIMCL MCL -&amp;gt; FMIMCL : fmimcl_adapter_create() activate FMIMCL FMIMCL -&amp;gt; ADAPTER : adapter_create() activate ADAPTER ADAPTER -&amp;gt; ADAPTER : set adapter functions ADAPTER -&amp;gt; FMIMCL deactivate ADAPTER FMIMCL -&amp;gt; MCL deactivate FMIMCL MCL-&amp;gt; ENGINE: fmimcl_allocate_scalar_source() activate ENGINE ENGINE-&amp;gt; MCL deactivate ENGINE MCL-&amp;gt; ENGINE: fmimcl_generate_marshal_table() activate ENGINE ENGINE-&amp;gt; MCL deactivate ENGINE MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : MCL_load() activate MCL group Generate MarshalSignalMap list ||| MCL -&amp;gt; MCL++ loop for each SignalVector MCL -&amp;gt; MARSHAL : marshal_generate_signalmap() activate MARSHAL MARSHAL -&amp;gt; MCL deactivate MARSHAL end return NTL ||| end MCL -&amp;gt; ADAPTER : adapter_load() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : load_functions() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : mcl_init() activate MCL MCL -&amp;gt; ADAPTER : adapter_init() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : do_init() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; User deactivate ModelC User -&amp;gt; ModelC : model_step() activate ModelC ModelC -&amp;gt; MCL : mcl_marshal_out() activate MCL MCL -&amp;gt; MARSHAL : marshal_signalmap_out() activate MARSHAL MARSHAL -&amp;gt; MCL deactivate MARSHAL MCL -&amp;gt; ADAPTER : adapter_marshal_out() activate ADAPTER ADAPTER -&amp;gt; MARSHAL : marshal_group_out() activate MARSHAL MARSHAL -&amp;gt; ADAPTER deactivate MARSHAL ADAPTER -&amp;gt; COMPONENT : set_variables() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : mcl_step() activate MCL MCL -&amp;gt; ADAPTER : adapter_step() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : do_step() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : mcl_marshal_in() activate MCL MCL -&amp;gt; ADAPTER : adapter_marshal_in() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : get_variables() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MARSHAL : marshal_group_in() activate MARSHAL MARSHAL -&amp;gt; ADAPTER deactivate MARSHAL ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; MARSHAL : marshal_signalmap_in() activate MARSHAL MARSHAL -&amp;gt; MCL deactivate MARSHAL MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; User deactivate ModelC User -&amp;gt; ModelC : model_destroy() activate ModelC ModelC -&amp;gt; MCL : mcl_unload() activate MCL MCL -&amp;gt; ADAPTER : adapter_unload() activate ADAPTER ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : MCL_destroy() activate MCL MCL -&amp;gt; FMIMCL: fmimcl_destroy() activate FMIMCL FMIMCL-&amp;gt; MCL deactivate FMIMCL MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; User deactivate ModelC center footer Dynamic Simulation Environment @enduml mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.</description></item><item><title>MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</guid><description>Model Compatibility Library API A Model Compatibility Library provides an interface for supporting 3rd-party model interfaces in a DSE Simulation.
Component Diagram @startuml mcl-interface skinparam nodesep 55 skinparam ranksep 40 title MCL Interface component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif package &amp;#34;MCL&amp;#34; { component &amp;#34;Runtime&amp;#34; as ModelC component &amp;#34;MCL&amp;#34; as Mcl interface &amp;#34;ModelVTable&amp;#34; as MVt interface &amp;#34;MclVTable&amp;#34; as MclVt component &amp;#34;MCL Lib&amp;#34; as MclLib } MclLib -up- MclVt MclLib -up- MVt SBif &amp;lt;-down- ModelC MVt )-up- ModelC MclVt )-up- Mcl component &amp;#34;Model&amp;#34; as MclModel interface &amp;#34;Model I/F&amp;#34; as ModelIf MclModel -up- ModelIf ModelIf )-up- MclLib center footer Dynamic Simulation Environment @enduml Typedefs MclDesc typedef struct MclDesc { int model; const char* adapter; const char* version; MclVTable vtable; double step_size; double model_time; double model_time_correction; struct { int count; const char** signal; struct { double* scalar; void** binary; } binary_len; int* kind; } source; int* msm; uint64_t [4] __reserved__; } MclVTable typedef struct MclVTable { MclLoad load; MclInit init; MclStep step; MclMarshalOut marshal_out; MclMarshalIn marshal_in; MclUnload unload; void *[2] __reserved__; } Functions mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.</description></item><item><title>MDF API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/mdf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/mdf/</guid><description>MDF API The MDF API (a part of the DSE C Lib) provides methods for creating an MDF4 data stream. Data is saved according to the ASAM Standards.
Because of the streaming design the exact number of samples written to an MDF file is not known when the MDF file is initially created. Accordingly, to indicate this condition, the follwing flags are set in the MDF file:
Update of cycle counters for CG-/CABLOCK required.</description></item><item><title>Model API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/model/</guid><description>Model API The Model API allows model developers and integrators to implement models which can be connected to a Simulation Bus. Models are able to exchange signals with other models via this connection to a Simulation Bus. A runtime environment, such as the ModelC Runtime/Importer, will load the model and also manages the connection with the Simulation Bus.
The Model API provides two simple interfaces which facilitate the development of models; the Model Interface which is concerned with the model lifecycle; and the Signal Interface which facilitates signal exchange.</description></item><item><title>Schema: Model</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/model/</guid><description>(v0.0.1)
Model kind: Model metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: runtime: dynlib: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 executable: - os: string arch: string libs: - string annotations: ? property1 ? property2 gateway: annotations: ? property1 ? property2 mcl: - path: string os: string arch: string variant: string libs: - string annotations: ?</description></item><item><title>Model C Debug Techniques</title><link>https://boschglobal.github.io/dse.doc/docs/devel/debug/modelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/debug/modelc/</guid><description>GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB debugging with the following technique:
In the main Makefile, add the GDB_CMD environment variable (i.e. --env GDB_CMD=&amp;quot;$(GDB_CMD)&amp;quot;) to every DOCKER_CMD that requires interactive GDB debugging support.
For each Makefile run target where interactive GDB debugging is required, prefix the run command with the GDB_CMD variable, for example: cd build/_out; $(GDB_CMD) bin/test_tdd.
Set the GDB_CMD environment variable with your GDB command (e.</description></item><item><title>FMI ModelC FMU API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmimodelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmimodelc/</guid><description>FMI ModelC FMU The FMI ModelC FMU is and FMU which is capable of loading and running a DSE Simulation (e.g. a ModelC Simulation Stack). All capabilites of the ModelC Runtime are supported, including the exchange of binary signals (e.g. CAN) and realisation of bus topologies (e.g. multi-node CAN Networks).
Component Diagram @startuml fmimodelc-component title FMI ModelC FMU center footer Dynamic Simulation Environment @enduml default_log Default logging function in case the FMU caller does not provide any logger.</description></item><item><title>Network Codec API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/ncodec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/ncodec/</guid><description>Network Codec A Network Codec has two interfaces: a Codec Interface which is used to encode/decode message from a Model/Device (connected to a Network), and a Stream Interface which is used to exchange the encoded messages with other Model/Devices connected to the same Network.
The Network Codec API (codec.h &amp;amp; codec.c) provides the framework for implementing both the Codec Interface and the Stream Interface. A typical realisation of this scheme would be:</description></item><item><title>Network API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/network/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/network/network/</guid><description>Network Model The Network Model runs a Communication Stack which represents the connection between Physical Signals and Network Messages.
Typedefs MarshalItem typedef struct MarshalItem { NetworkSignal* signal; NetworkMessage* message; size_t signal_vector_index; } Network typedef struct Network { const char* name; int* doc; NetworkMessage* messages; const char* message_lib_path; const char* function_lib_path; void* message_lib_handle; void* function_lib_handle; MarshalItem* marshal_list; size_t signal_count; const char** signal_name; double* signal_vector; NetworkScheduleItem* schedule_list; uint32_t tick; uint32_t bus_id; uint32_t node_id; uint32_t interface_id; } NetworkFunction typedef struct NetworkFunction { char* name; int* annotations; void* data; NetworkFunctionFunc function; } NetworkMessage typedef struct NetworkMessage { const char* name; uint32_t frame_id; uint8_t frame_type; NetworkSignal* signals; const char* container; uint32_t mux_id; NetworkSignal* mux_signal; void* buffer; size_t buffer_len; uint8_t cycle_time_ms; void* payload; uint8_t payload_len; uint32_t buffer_checksum; bool needs_tx; PackFunc pack_func; UnpackFunc unpack_func; bool update_signals; NetworkFunction* encode_functions; NetworkFunction* decode_functions; } NetworkScheduleItem typedef struct NetworkScheduleItem { NetworkMessage* message; uint32_t alarm; } NetworkSignal typedef struct NetworkSignal { const char* name; char* signal_name; const char* member_type; unsigned int buffer_offset; double init_value; bool internal; double value; bool mux_signal; MarshalItem* mux_mi; EncodeFuncInt8 encode_func_int8; EncodeFuncInt16 encode_func_int16; EncodeFuncInt32 encode_func_int32; EncodeFuncInt64 encode_func_int64; EncodeFuncFloat encode_func_float; EncodeFuncDouble encode_func_double; DecodeFuncInt8 decode_func_int8; DecodeFuncInt16 decode_func_int16; DecodeFuncInt32 decode_func_int32; DecodeFuncInt64 decode_func_int64; DecodeFuncFloat decode_func_float; DecodeFuncDouble decode_func_double; RangeFuncInt8 range_func_int8; RangeFuncInt16 range_func_int16; RangeFuncInt32 range_func_int32; RangeFuncInt64 range_func_int64; RangeFuncFloat range_func_float; RangeFuncDouble range_func_double; } Functions</description></item><item><title>Schema: Network</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/network/</guid><description>(v1.0.0)
Network kind: Network metadata: name: CAN1 annotations: message_lib: examples/stub/data/message.so function_lib: examples/stub/data/function.so spec: messages: - message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t - signal: Alive annotations: struct_member_name: alive struct_member_offset: 1 struct_member_primitive_type: uint8 - signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t functions: encode: - function: counter_inc_uint8 annotations: position: 1 - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network definition.</description></item><item><title>Schema: ParameterSet</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/parameterset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/parameterset/</guid><description>(v0.0.1)
ParameterSet kind: ParameterSet metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: parameters: - parameter: string value: string annotations: ? property1 ? property2 A parameter_set definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.</description></item><item><title>Schema: Propagator</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/propagator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/propagator/</guid><description>(v0.0.1)
Propagator kind: Propagator metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: options: direction: both signals: - signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A propagator definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object.</description></item><item><title>Schema: Runnable</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/runnable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/runnable/</guid><description>(v1.0.0)
Runnable kind: Runnable metadata: name: target annotations: target_lib: examples/stub/lib/target.so spec: tasks: - function: task_init schedule: 0 - function: task_5ms schedule: 5 - function: task_10ms schedule: 10 - function: task_20ms schedule: 20 - function: task_40ms schedule: 40 A Runnable definition.
Supported annotations: Annotation Description target_lib Relative path of the shared library containing the Runnable library. Properties Name Type Required Description kind string true none metadata object false Information relating to an object.</description></item><item><title>Runtime API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</guid><description>Runtime API The Runtime API provides methods for implementing a model Runtime/Importer which can be used to load, configure and execute a model.
Typedefs ChannelSpec typedef struct ChannelSpec { const char* name; const char* alias; void* private; } ModelCArguments typedef struct ModelCArguments { const char* transport; char* uri; const char* host; int port; double timeout; int log_level; double step_size; double end_time; int uid; const char* name; const char* file; const char* path; void* yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; int steps; const char* sim_path; int [4] __reserved__; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char* name; const char* path; const char* file; char* full_path; void* doc; void* channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { int uid; char* name; int* model_desc; ModelDefinitionSpec model_definition; void* spec; void* yaml_doc_list; void* private; int [8] __reserved__; } RuntimeModelDesc typedef struct RuntimeModelDesc { int model; struct { const char* runtime_model; char* sim_path; const char* model_name; const char* simulation_yaml; int argc; char** argv; void* doc_list; int log_level; double step_size; double end_time; double step_time_correction; int binary_signals_reset; RuntimeModelVTable vtable; } runtime; int [5] __reserved__; } RuntimeModelVTable typedef struct RuntimeModelVTable { RuntimeModelSetEnv set_env; void *[2] __reserved__; } SimulationSpec typedef struct SimulationSpec { const char* transport; char* uri; int uid; double timeout; double step_size; double end_time; ModelInstanceSpec* instance_list; const char* sim_path; int mode_loopback; int sequential_cosim; void* spec; int [3] __reserved__; } Functions modelc_destroy Bypass the controller and call model_destroy() directly.</description></item><item><title>Schedule API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/schedule/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/schedule/</guid><description>Schedule API The Schedule API proves a task schedule with configurable beat and an optional delay. Interfaces of the Schedule object allow for customization of the schedule behaviour, these include:
ScheduleVTable - tick and marshalling call interfaces. ScheduleTaskVTable - Support custom task call interfaces, the default is a simple void (*)(void) function call. Component Diagram @startuml schedule-api skinparam nodesep 55 skinparam ranksep 40 title Schedule API component &amp;#34;Schedule&amp;#34; as s component &amp;#34;ScheduleItem&amp;#34; as sI component &amp;#34;ScheduleTask&amp;#34; as sT interface &amp;#34;ScheduleVTable&amp;#34; as sVT interface &amp;#34;ScheduleTaskVTable&amp;#34; as sTVT component &amp;#34;Integration&amp;#34; as vT component &amp;#34;Target&amp;#34; as task s --( sVT s --( sTVT sVT -- vT sTVT -- vT s ---&amp;gt; sI : [0.</description></item><item><title>Schema API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</guid><description>Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.
Typedefs SchemaLabel typedef struct SchemaLabel { const char* name; const char* value; } SchemaObject typedef struct SchemaObject { const char* kind; const char* name; void* doc; void* data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char* kind; const char* name; SchemaLabel* labels; int labels_len; void* data; } SchemaSignalObject typedef struct SchemaSignalObject { const char* signal; void* data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec.</description></item><item><title>Schema: SignalData</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/signaldata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/signaldata/</guid><description>(v0.0.1)
SignalData Data = [[0..N],[0..N]] MsgPack encoded Signal Data. Number of elements in each nested array should be identical.
Properties oneOf
Name Type Required Description anonymous SignalUid false Signal UID. xor
Name Type Required Description anonymous SignalValueNumeric false Numeric signal value. The value may be encoded as any integer or float type. xor
Name Type Required Description anonymous SignalValueBinary false Binary signal value. SignalUid 0 Signal UID.
Properties Name Type Required Description anonymous integer(int32) false Signal UID.</description></item><item><title>Schema: SignalGroup</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/signalgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/signalgroup/</guid><description>(v0.0.1)
SignalGroup kind: SignalGroup metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: signals: - signal: string transform: linear: factor: 0 offset: 0 annotations: ? property1 ? property2 A signal group definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.</description></item><item><title>SimMock API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</guid><description>SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC &amp;lt;-&amp;gt; SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.
Component Diagram @startuml simmock-objects title SimMock Objects package &amp;#34;SimBus Mock&amp;#34; { class Signal &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +double scalar[] +annotation() } class Network &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.</description></item><item><title>Testing Models with SimMock</title><link>https://boschglobal.github.io/dse.doc/docs/devel/testing/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/testing/simmock/</guid><description>SimMock and CMocka Testing for Model Developers The DSE ModelC Library includes a SimMock source code library which may be used to develop integration tests for Models. With the SimMock library, a Model Developer is able to easily develop CMocka Testcases which:
Validate a model configuration and confirm the Models operation. Develop scenarios where expected signal exchange is verified. Inject network messages into the simulation or model (e.g. CAN frames) and read network messages.</description></item><item><title>Schema: Simulation</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/simulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/simulation/</guid><description>(v0.0.1)
Simulation kind: Simulation metadata: name: project annotations: input: somefile.json generator: parse2ast spec: simulation: arch: linux-amd64 stepsize: 0.0005 endtime: 0.2 channels: - name: physical - name: network networks: - name: CAN mime_type: application/x uses: - name: model.linear url: https://github.com/boschglobal/dse.fmi version: 1.1.15 path: model/linear/path vars: - name: enable value: true stacks: - name: stack_name stacked: true arch: linux-amd64 models: - name: linear model: model.linear channels: - name: physical alias: scalar env: - name: SIMBUS_LOGLEVEL value: 4 workflows: - name: generate-fmimcl vars: - name: FMU_DIR value: &amp;#34;{{.</description></item><item><title>Schema: Stack</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/stack/</guid><description>(v0.0.1)
Stack kind: Stack metadata: name: default annotations: simulation: stepsize: 0.0005 endtime: 0.2 spec: connection: transport: redis: timeout: 60 uri: redis://localhost:6379 models: - name: simbus uid: 0 model: name: simbus channels: - expectedModelCount: 1 name: physical - name: input uid: 1 model: name: dse.modelc.csv runtime: env: CSV_FILE: model/input/data/input.csv paths: - model/input/data channels: - alias: signal_channel name: physical selectors: channel: signal_vector model: input A stack definition.
Properties Name Type Required Description kind string true Indicate the type of object.</description></item><item><title>Testing with Testscript</title><link>https://boschglobal.github.io/dse.doc/docs/devel/testing/testscript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/testing/testscript/</guid><description>Testscript for E2E Testing DSE Projects can use Testscript to run End-to-end tests (E2E) which are written in the (simple) txtar format. The containerised runtime supports both the Simer simulation runner as well as Taskfile based workflows.
Code Layout and Test Organisation L- tests/testscript Directory containing Testscript tests. L- e2e Collection of E2E tests. L- testcase.txtar Individual testcase (in txtar format). L- Makefile High-level build automation. Example Test Files tests/exec.txtar env NAME=minimal_inst env SIM=dse/modelc/build/_out/examples/minimal env SANDBOX=dse/modelc/build/_out # TEST: MStep executable exec sh -e $WORK/test.</description></item></channel></rss>