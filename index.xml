<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dynamic Simulation Environment</title><link>https://boschglobal.github.io/dse.doc/</link><description>Recent content on Dynamic Simulation Environment</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://boschglobal.github.io/dse.doc/index.xml" rel="self" type="application/rss+xml"/><item><title>C4 Architecture Diagrams</title><link>https://boschglobal.github.io/dse.doc/docs/arch/c4/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/c4/</guid><description>C1 System System Context C2 Container Interop Native Virtual ECU C3 Component Bootloader Runnable Model Composite Model Gateway FMI MCL C4</description></item><item><title>Contributions Guide</title><link>https://boschglobal.github.io/dse.doc/docs/devel/contribution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/contribution/</guid><description>Synopsis Developers wishing to contribute, as well as those having no choice in the matter, will find this documentation page full of useful information to guide you towards finalising your contribution.
Git Commands Setup and Configure Git # Set user name and email (for signoff). git config --global --add user.name &amp;#34;User Name (dept)&amp;#34; git config --global --add user.email &amp;#34;user.name@de.bosch.com&amp;#34; Working with Commits Sign Off # Add a signoff to a commit.</description></item><item><title>Documentation Systems</title><link>https://boschglobal.github.io/dse.doc/docs/devel/documentation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/documentation/</guid><description>The documentation system is built by pulling content from individual Git Repos into a Hugo/Docsy project. The Hugo build system then consolidates that content into a single documentation system which is then published.
Hint: Documentation in each Git Repo needs to follow the same layout and structure as the Documentation Repo for the content to be merged correctly.
Layout Repo Documentation When writing documentation construct a layout as described in the following section.</description></item><item><title>Simer - Simulation Runner</title><link>https://boschglobal.github.io/dse.doc/docs/user/simer/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/simer/</guid><description>Synopsis Containerised simulation run-time.
# Run a simulation. $ simer path/to/simulation -stepsize 0.0005 -endtime 0.04 Simulation Setup Structure The structure of a simulation is flexible and can be arranged based on individual project needs. All paths used within a simulation configuration should be relative to the root of the simulation folder (i.e. the simulation path). The simer tool will search for YAML files contained within the simulation path and automatically configure, and then run, the contained simulation.</description></item><item><title>FMI Gateway FMU</title><link>https://boschglobal.github.io/dse.doc/docs/user/fmi/fmigateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/fmi/fmigateway/</guid><description>Synposis FMI Gateway FMU
Simulation Setup Structure Example Simulation Setup DOC: Provide description of Gateway Taskfile workflows.
Operation The configuration and operation of the gateway is done in the stack.yaml that is to be loaded by the gateway. The stack follows the following schema with some additional, gateway specific annotations/ additions.
Stack Metadata Name Type Required Description metadata object true none » name string true This field is required to be named &amp;ldquo;gateway&amp;rdquo; » annotation object false none »» redis_show boolean false Set to true if the redis process should be shown as terminal window »» simbus_show boolean false Set to true if the simbus process should be shown as terminal window »» models_show boolean false Set to true if the model processes should be shown as terminal windows »» model_stack string false Name of the Stack.</description></item><item><title>FMI Model Compatibility Library</title><link>https://boschglobal.github.io/dse.doc/docs/user/fmi/fmimcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/fmi/fmimcl/</guid><description>Synposis FMI Model Compatibility Library
Simulation Setup Structure Example Simulation Setup DOC: Provide description of FMI MCL Taskfile workflows.
Operation Measurement The FMI MCL can be configured to produce an MDF measurement file for scalar signals of the FMUs interface, including FMI Variables with &amp;rsquo;local&amp;rsquo; causality.
Note: the path of the measurement file is relative to the simulation path (i.e. /sim/&amp;hellip;).
# Using Simer; enable measurement on the FMU represented by &amp;#39;fmu_inst&amp;#39;.</description></item><item><title>FMI ModelC FMU</title><link>https://boschglobal.github.io/dse.doc/docs/user/fmi/fmimodelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/fmi/fmimodelc/</guid><description>Synposis FMI ModelC FMU
Simulation Setup Structure Example Simulation FMU Setup DOC: Provide description of FMI ModelC FMU Taskfile workflows.
FMU Operation DOC: Operation.</description></item><item><title>Model C with Network Codec</title><link>https://boschglobal.github.io/dse.doc/docs/devel/ncodec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/ncodec/</guid><description>Network Codec The Model C Library integrates the DSE Network Codec implementation of the Automotive Bus schemas.
Configuration of Binary Signals IMPORTANT: It is recommended to specify a SignalGroup for each individual Model Instance in a Simulation. This is so that the MIMEtype of each Binary Signal can be completely configured (especially bus_id,node_id and interface_id). Models may implement supplemental configuration options (such as annotations on the Model Instance definition) which can further adjust or augment the MIMEtype parameters.</description></item><item><title>Network - Network Model</title><link>https://boschglobal.github.io/dse.doc/docs/user/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/user/network/</guid><description>Synposis Network Model of a Communication Stack representing the connection between Physical Signals and Network Messages.
# Build a network model. $ cd path/to/simulation; $ task generate \ DBCFILE=networks/can_1/can_1.dbc \ SIGNAL=can_1 \ MIMETYPE=&amp;#34;application/x-automotive-bus; interface=stream; type=frame; bus=can; schema=fbs; bus_id=1; node_id=1; interface_id=0&amp;#34; $ cd - # Run the simulation. $ simer path/to/simulation -stepsize 0.0005 -endtime 0.04 Simulation Setup Structure Network Example Simulation # Example Source Code: L- dse/network/examples/brake-by-wire L- simulation.yaml Stack definitions. L- model.</description></item><item><title>Transports</title><link>https://boschglobal.github.io/dse.doc/docs/arch/transport/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/transport/</guid><description>Overview Transport Latency Status Loopback Fastest Available, stacked simulations (single process). TCP Fastest Planned. Redis Faster Recommended. Redis PubSub Fast Available, stable. RESP Fast Under consideration, for cloud connectivity (tunnelling). gPPC Fast Under consideration, for cloud connectivity (HTTP). Redis Async Slower Available, experimental. MsgQueue Slowest Discontinued, poor performance at scale. Usage A transport can be specified in a number of ways, however typically a transport will be configured in a Stack Configuration (YAML) or via an Environment Variable.</description></item><item><title>Model Compatibility Library</title><link>https://boschglobal.github.io/dse.doc/docs/arch/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/mcl/</guid><description>Synopsis The Model Compatibility Library (MCL) of the Dynamic Simulation Environment (DSE) is a representation of an Architectural Pattern for supporting 3rd-party model interfaces in a DSE Simulation. To support a model interface an implementation will need to implement the MCL API (i.e. MclVTable) and may also optionally use the Marshal API to manage signal/variable exchange with the model being interfaced.
Design Deployment Configuration References MCL API Marshal API FMI MCL - An MCL implementation for the Modelica FMI Standard.</description></item><item><title>Signal Vectors</title><link>https://boschglobal.github.io/dse.doc/docs/arch/signalvector/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/signalvector/</guid><description>Synopsis The Dynamic Simulation Environment (DSE) presents models with a simple vector interface for the exchange of signals. Those signals can be either:
scalar : Internally represented as a 64bit storage container (double). These values are transparently exchanged between models. Models may cast/convert these scalar values to other types as required. binary : Binary strings, which may container embedded NULL values, can be exchanged between models. Additionally a binary signal may be annotated with a MIME type which describes the content of a binary signal.</description></item><item><title>Gateway Models</title><link>https://boschglobal.github.io/dse.doc/docs/arch/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/arch/gateway/</guid><description>Synopsis The Dynamic Simulation Environment (DSE) provides a Gateway API which can be used to connect remote simulations, via a gateway model, to a running DSE simulation. A gateway model takes care of signal exchange and time synchronisation between the remote simulation and the DSE simulation. Signals can be either scalar values or binary strings, the latter enabling virtual bus connections between simulation environments.
The gateway model runs in the remote simulation, and is written in that systems native language (or modelling construct).</description></item><item><title>Testing with CMocka</title><link>https://boschglobal.github.io/dse.doc/docs/devel/testing/cmocka/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/testing/cmocka/</guid><description>CMocka Testing for C Code The DSE Projects use CMocka for both Unit and Integration testing. This document introduces the typical CMocka Test Project and explains the testing features which are most often used when developing.
Code Layout and Test Organisation L- tests/cmocka Directory containing CMocka tests. L- target An individual test target (single test executable). L- __tests__.c Entry point for the test target (runs test groups). L- test_foo.c Contains a test group (e.</description></item><item><title>FMU API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmu/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmu/</guid><description>FMU API The FMU API provides a simplified FMU inteface with an abstracted varaible interface (indexing and storage). The FMU Interface includes the methods:
Implemented by FMU developer: [fmu_create()](#fmu_create) [fmu_init()](#fmu_init) [fmu_step()](#fmu_step) [fmu_destroy()](#fmu_destroy) Additional provided functions: [fmu_log()](#fmu_log) - logging function Supporting Variable Table mechanism: [fmu_register_var()](#fmu_register_var) [fmu_register_var_table()](#fmu_register_var_table) [fmu_var_table()](#fmu_var_table) An additional FMU Signal Interface is available for more complex integrations:
[fmu_signals_reset()](#fmu_signals_reset) [fmu_signals_setup()](#fmu_signals_setup) [fmu_signals_remove()](#fmu_signals_remove) FMUs imlemented using this simplified FMU API can be built for both FMI 2 and FMI 3 standards by linking to the relevant implementations:</description></item><item><title>Example Network Function API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/network/functions/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/network/functions/</guid><description>Example Network Functions Example implementation of Network Functions.
Typedefs InstanceData typedef struct InstanceData { int position; } Functions counter_inc_uint8 Increment an 8-bit counter in the message packet.
Note: in the encode path, changes to the counter are not reflected in the corresponding signal. Subsequent calls to network_message_recalculate may overwrite the modified counter.
Parameters data (void**) Pointer reference for instance data. payload (uint8_t*) The payload that this function will modify. payload_len (size_t) The length of the payload.</description></item><item><title>Gateway API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/gateway/</guid><description>Gateway Model When implemented, a Gateway Model makes it possible for a foreign Simulation Environment to connect with a Dynamic Simulation Environment. The two simulation environments can then exchange signals and maintain synchronisation.
Component Diagram @startuml gateway-model title Gateway Model node &amp;#34;Dynamic Simulation Environment&amp;#34; { component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif } package &amp;#34;Gateway Model&amp;#34; { component &amp;#34;ModelC Lib&amp;#34; as ModelC component &amp;#34;Model&amp;#34; } SBif &amp;lt;-down- ModelC Model -up-&amp;gt; ModelC :model_gw_setup() Model -up-&amp;gt; ModelC :model_gw_sync() Model -up-&amp;gt; ModelC :model_gw_exit() center footer Dynamic Simulation Environment @enduml Example // Copyright 2023 Robert Bosch GmbH // // SPDX-License-Identifier: Apache-2.</description></item><item><title>FMI Gateway FMU API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmigateway/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmigateway/</guid><description>fmu_signals_setup Placeholder to signal the FMU to not use the default signal allocation.
Parameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. fmu_signals_remove This method frees the allocated binary signal indexes.
Parameters fmu (FmuInstanceData*) The FMU Descriptor object representing an instance of the FMU Model. FMI ModelC Gateway Component Diagram @startuml fmigateway-component title FMI Gateway FMU center footer Dynamic Simulation Environment @enduml Example fmu_create This method allocates the necessary gateway models.</description></item><item><title>Schema: Manifest</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/manifest/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/manifest/</guid><description>(v0.0.1)
Manifest kind: Manifest metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: repos: - name: string repo: string path: string registry: string user: string token: string tools: - name: string version: string repo: string arch: - string schema: string models: - name: string version: string repo: string arch: string schema: string channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ?</description></item><item><title>Marshal API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/marshal/</guid><description>Marshal API The Marshal API supports two modes of operation:
Marshalling of intrinsic data types between source and target where the target represents externally defined data structures. Marshalling of signal maps between a signal interface and the source data objects (of the marshalling sub-system). When these operations are combined it becomes possible to map signals to externally defined data structures (i.e. C style structs).
Component Diagram @startuml data-marshal-interface skinparam nodesep 55 skinparam ranksep 40 title Marshal Interface interface &amp;#34;Signals&amp;#34; as sig package &amp;#34;Controller&amp;#34; { component &amp;#34;Source&amp;#34; as sou component &amp;#34;Target&amp;#34; as tar } sig -right-&amp;gt; sou : out sig &amp;lt;-right- sou : in sou -right-&amp;gt; tar : out sou &amp;lt;-right- tar : in center footer Dynamic Simulation Environment @enduml marshal_type_size Return the size of a MarshalType (in bytes).</description></item><item><title>FMI MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmimcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmimcl/</guid><description>FMI Model Compatibility Library The FMI Model Compatibility Library provides an interfaces for loading and operating FMUs.
Sequence Diagram @startuml fmimcl-sequence title FMI MCL - Sequence actor User participant ModelC participant MCL participant MARSHAL participant FMIMCL participant ENGINE participant ADAPTER participant COMPONENT User -&amp;gt; ModelC : model_create() activate ModelC ModelC -&amp;gt; MCL : MCL_create() activate MCL MCL -&amp;gt; FMIMCL : fmimcl_parse() activate FMIMCL FMIMCL -&amp;gt; FMIMCL : parse yaml FMIMCL -&amp;gt; MCL deactivate FMIMCL MCL -&amp;gt; FMIMCL : fmimcl_adapter_create() activate FMIMCL FMIMCL -&amp;gt; ADAPTER : adapter_create() activate ADAPTER ADAPTER -&amp;gt; ADAPTER : set adapter functions ADAPTER -&amp;gt; FMIMCL deactivate ADAPTER FMIMCL -&amp;gt; MCL deactivate FMIMCL MCL-&amp;gt; ENGINE: fmimcl_allocate_scalar_source() activate ENGINE ENGINE-&amp;gt; MCL deactivate ENGINE MCL-&amp;gt; ENGINE: fmimcl_generate_marshal_table() activate ENGINE ENGINE-&amp;gt; MCL deactivate ENGINE MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : MCL_load() activate MCL group Generate MarshalSignalMap list ||| MCL -&amp;gt; MCL++ loop for each SignalVector MCL -&amp;gt; MARSHAL : marshal_generate_signalmap() activate MARSHAL MARSHAL -&amp;gt; MCL deactivate MARSHAL end return NTL ||| end MCL -&amp;gt; ADAPTER : adapter_load() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : load_functions() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : mcl_init() activate MCL MCL -&amp;gt; ADAPTER : adapter_init() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : do_init() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; User deactivate ModelC User -&amp;gt; ModelC : model_step() activate ModelC ModelC -&amp;gt; MCL : mcl_marshal_out() activate MCL MCL -&amp;gt; MARSHAL : marshal_signalmap_out() activate MARSHAL MARSHAL -&amp;gt; MCL deactivate MARSHAL MCL -&amp;gt; ADAPTER : adapter_marshal_out() activate ADAPTER ADAPTER -&amp;gt; MARSHAL : marshal_group_out() activate MARSHAL MARSHAL -&amp;gt; ADAPTER deactivate MARSHAL ADAPTER -&amp;gt; COMPONENT : set_variables() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : mcl_step() activate MCL MCL -&amp;gt; ADAPTER : adapter_step() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : do_step() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : mcl_marshal_in() activate MCL MCL -&amp;gt; ADAPTER : adapter_marshal_in() activate ADAPTER ADAPTER -&amp;gt; COMPONENT : get_variables() activate COMPONENT COMPONENT -&amp;gt; ADAPTER deactivate COMPONENT ADAPTER -&amp;gt; MARSHAL : marshal_group_in() activate MARSHAL MARSHAL -&amp;gt; ADAPTER deactivate MARSHAL ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; MARSHAL : marshal_signalmap_in() activate MARSHAL MARSHAL -&amp;gt; MCL deactivate MARSHAL MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; User deactivate ModelC User -&amp;gt; ModelC : model_destroy() activate ModelC ModelC -&amp;gt; MCL : mcl_unload() activate MCL MCL -&amp;gt; ADAPTER : adapter_unload() activate ADAPTER ADAPTER -&amp;gt; MCL deactivate ADAPTER MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; MCL : MCL_destroy() activate MCL MCL -&amp;gt; FMIMCL: fmimcl_destroy() activate FMIMCL FMIMCL-&amp;gt; MCL deactivate FMIMCL MCL -&amp;gt; ModelC deactivate MCL ModelC -&amp;gt; User deactivate ModelC center footer Dynamic Simulation Environment @enduml mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.</description></item><item><title>MCL API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/mcl/</guid><description>Model Compatibility Library API A Model Compatibility Library provides an interface for supporting 3rd-party model interfaces in a DSE Simulation.
Component Diagram @startuml mcl-interface skinparam nodesep 55 skinparam ranksep 40 title MCL Interface component &amp;#34;Model&amp;#34; as m1 component &amp;#34;Model&amp;#34; as m2 interface &amp;#34;SimBus&amp;#34; as SBif m1 -left-&amp;gt; SBif m2 -right-&amp;gt; SBif package &amp;#34;MCL&amp;#34; { component &amp;#34;Runtime&amp;#34; as ModelC component &amp;#34;MCL&amp;#34; as Mcl interface &amp;#34;ModelVTable&amp;#34; as MVt interface &amp;#34;MclVTable&amp;#34; as MclVt component &amp;#34;MCL Lib&amp;#34; as MclLib } MclLib -up- MclVt MclLib -up- MVt SBif &amp;lt;-down- ModelC MVt )-up- ModelC MclVt )-up- Mcl component &amp;#34;Model&amp;#34; as MclModel interface &amp;#34;Model I/F&amp;#34; as ModelIf MclModel -up- ModelIf ModelIf )-up- MclLib center footer Dynamic Simulation Environment @enduml Typedefs MclDesc typedef struct MclDesc { int model; const char* adapter; const char* version; MclVTable vtable; double step_size; double model_time; double model_time_correction; struct { int count; const char** signal; struct { double* scalar; void** binary; } binary_len; int* kind; } source; int* msm; uint64_t [4] __reserved__; } MclVTable typedef struct MclVTable { MclLoad load; MclInit init; MclStep step; MclMarshalOut marshal_out; MclMarshalIn marshal_in; MclUnload unload; void *[2] __reserved__; } Functions mcl_create Create an instance of the MCL which will then be used to operate the Model that the MCL represents.</description></item><item><title>Mdf API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/clib/mdf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/clib/mdf/</guid><description>MDF API The MDF API (a part of the DSE C Lib) provides methods for creating an MDF4 data stream. Data is saved according to the ASAM Standards.
Because of the streaming design the exact number of samples written to an MDF file is not known when the MDF file is initially created. Accordingly, to indicate this condition, the follwing flags are set in the MDF file:
Update of cycle counters for CG-/CABLOCK required.</description></item><item><title>Model API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/model/</guid><description>Model API The Model API allows model developers and integrators to implement models which can be connected to a Simulation Bus. Models are able to exchange signals with other models via this connection to a Simulation Bus. A runtime environment, such as the ModelC Runtime/Importer, will load the model and also manages the connection with the Simulation Bus.
The Model API provides two simple interfaces which facilitate the development of models; the Model Interface which is concerned with the model lifecycle; and the Signal Interface which facilitates signal exchange.</description></item><item><title>Schema: Model</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/model/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/model/</guid><description>(v0.0.1)
Model kind: Model metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: runtime: dynlib: - path: string os: string arch: string variant: string libs: - string annotations: ? property1 ? property2 executable: - os: string arch: string libs: - string annotations: ? property1 ? property2 gateway: annotations: ? property1 ? property2 mcl: - path: string os: string arch: string variant: string libs: - string annotations: ?</description></item><item><title>Model C Debug Techniques</title><link>https://boschglobal.github.io/dse.doc/docs/devel/debug/modelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/debug/modelc/</guid><description>GDB GDB Enabled Makefiles Repos can be enabled for interactive GDB debugging with the following technique:
In the main Makefile, add the GDB_CMD environment variable (i.e. --env GDB_CMD=&amp;quot;$(GDB_CMD)&amp;quot;) to every DOCKER_CMD that requires interactive GDB debugging support.
For each Makefile run target where interactive GDB debugging is required, prefix the run command with the GDB_CMD variable, for example: cd build/_out; $(GDB_CMD) bin/test_tdd.
Set the GDB_CMD environment variable with your GDB command (e.</description></item><item><title>FMI ModelC FMU API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/fmi/fmimodelc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/fmi/fmimodelc/</guid><description>fmi2ExitInitializationMode Initialise the Model Runtime (of the ModelC library) and in the process establish the simulation that this ModelC FMU is wrapping/operating.
This function will generate indexes to map between FMI Variables and ModelC Signals; both scaler signals (double) and binary signals (string/binary).
Parameters c (fmi2Component*) An Fmu2InstanceData object representing an instance of this FMU. Returns fmi2OK (fmi2Status) The simulation that this FMU represents is ready to be operated. fmi2FreeInstance Free memory and resources related to the provided FMU instance.</description></item><item><title>Network Codec API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/ncodec/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/ncodec/</guid><description>Network Codec A Network Codec has two interfaces: a Codec Interface which is used to encode/decode message from a Model/Device (connected to a Network), and a Stream Interface which is used to exchange the encoded messages with other Model/Devices connected to the same Network.
The Network Codec API (codec.h &amp;amp; codec.c) provides the framework for implementing both the Codec Interface and the Stream Interface. A typical realisation of this scheme would be:</description></item><item><title>Network API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/network/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/network/network/</guid><description>Network Model The Network Model runs a Communication Stack which represents the connection between Physical Signals and Network Messages.
Typedefs MarshalItem typedef struct MarshalItem { NetworkSignal* signal; NetworkMessage* message; size_t signal_vector_index; } Network typedef struct Network { const char* name; int* doc; NetworkMessage* messages; const char* message_lib_path; const char* function_lib_path; void* message_lib_handle; void* function_lib_handle; MarshalItem* marshal_list; size_t signal_count; const char** signal_name; double* signal_vector; NetworkScheduleItem* schedule_list; uint32_t tick; uint32_t bus_id; uint32_t node_id; uint32_t interface_id; } NetworkFunction typedef struct NetworkFunction { char* name; int* annotations; void* data; NetworkFunctionFunc function; } NetworkMessage typedef struct NetworkMessage { const char* name; uint32_t frame_id; uint8_t frame_type; NetworkSignal* signals; const char* container; uint32_t mux_id; NetworkSignal* mux_signal; void* buffer; size_t buffer_len; uint8_t cycle_time_ms; void* payload; uint8_t payload_len; uint32_t buffer_checksum; bool needs_tx; PackFunc pack_func; UnpackFunc unpack_func; bool update_signals; NetworkFunction* encode_functions; NetworkFunction* decode_functions; } NetworkScheduleItem typedef struct NetworkScheduleItem { NetworkMessage* message; uint32_t alarm; } NetworkSignal typedef struct NetworkSignal { const char* name; char* signal_name; const char* member_type; unsigned int buffer_offset; double init_value; bool internal; double value; bool mux_signal; MarshalItem* mux_mi; EncodeFuncInt8 encode_func_int8; EncodeFuncInt16 encode_func_int16; EncodeFuncInt32 encode_func_int32; EncodeFuncInt64 encode_func_int64; EncodeFuncFloat encode_func_float; EncodeFuncDouble encode_func_double; DecodeFuncInt8 decode_func_int8; DecodeFuncInt16 decode_func_int16; DecodeFuncInt32 decode_func_int32; DecodeFuncInt64 decode_func_int64; DecodeFuncFloat decode_func_float; DecodeFuncDouble decode_func_double; RangeFuncInt8 range_func_int8; RangeFuncInt16 range_func_int16; RangeFuncInt32 range_func_int32; RangeFuncInt64 range_func_int64; RangeFuncFloat range_func_float; RangeFuncDouble range_func_double; } Functions</description></item><item><title>Schema: Network</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/network/</guid><description>(v1.0.0)
Network kind: Network metadata: name: CAN1 annotations: message_lib: examples/stub/data/message.so function_lib: examples/stub/data/function.so spec: messages: - message: systemStatus annotations: struct_name: CAN1_systemStatus_t struct_size: 4 frame_id: 496 frame_length: 8 cycle_time_ms: 10 signals: - signal: Crc annotations: struct_member_name: crc struct_member_offset: 0 struct_member_primitive_type: uint8_t - signal: Alive annotations: struct_member_name: alive struct_member_offset: 1 struct_member_primitive_type: uint8 - signal: Temperature annotations: struct_member_name: temperature struct_member_offset: 2 struct_member_primitive_type: int16_t functions: encode: - function: counter_inc_uint8 annotations: position: 1 - function: crc_generate annotations: position: 0 decode: - function: crc_validate annotations: position: 0 A Network definition.</description></item><item><title>Schema: ParameterSet</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/parameterset/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/parameterset/</guid><description>(v0.0.1)
ParameterSet kind: ParameterSet metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: parameters: - parameter: string value: string annotations: ? property1 ? property2 A parameter_set definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.</description></item><item><title>Schema: Propagator</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/propagator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/propagator/</guid><description>(v0.0.1)
Propagator kind: Propagator metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: options: direction: both signals: - signal: string target: string encoding: linear: min: 0 max: 0 factor: 0 offset: 0 mapping: - name: string source: 0 target: 0 range: min: 0 max: 0 A propagator definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object.</description></item><item><title>Schema: Runnable</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/runnable/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/runnable/</guid><description>(v1.0.0)
Runnable kind: Runnable metadata: name: target annotations: target_lib: examples/stub/lib/target.so spec: tasks: - function: task_init schedule: 0 - function: task_5ms schedule: 5 - function: task_10ms schedule: 10 - function: task_20ms schedule: 20 - function: task_40ms schedule: 40 A Runnable definition.
Supported annotations: Annotation Description target_lib Relative path of the shared library containing the Runnable library. Properties Name Type Required Description kind string true none metadata object false Information relating to an object.</description></item><item><title>Runtime API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/runtime/</guid><description>Runtime API The Runtime API provides methods for implementing a model Runtime/Importer which can be used to load, configure and execute a model.
Typedefs ChannelSpec typedef struct ChannelSpec { const char* name; const char* alias; void* private; } ModelCArguments typedef struct ModelCArguments { const char* transport; char* uri; const char* host; int port; double timeout; int log_level; double step_size; double end_time; int uid; const char* name; const char* file; const char* path; void* yaml_doc_list; int timeout_set_by_cli; int log_level_set_by_cli; int steps; const char* sim_path; int [4] __reserved__; } ModelDefinitionSpec typedef struct ModelDefinitionSpec { const char* name; const char* path; const char* file; char* full_path; void* doc; void* channels; } ModelInstanceSpec typedef struct ModelInstanceSpec { int uid; char* name; int* model_desc; ModelDefinitionSpec model_definition; void* spec; void* yaml_doc_list; void* private; int [8] __reserved__; } RuntimeModelDesc typedef struct RuntimeModelDesc { int model; struct { const char* runtime_model; char* sim_path; const char* model_name; const char* simulation_yaml; int argc; char** argv; void* doc_list; int log_level; double step_size; double end_time; double step_time_correction; int binary_signals_reset; } runtime; int [8] __reserved__; } SimulationSpec typedef struct SimulationSpec { const char* transport; char* uri; int uid; double timeout; double step_size; double end_time; ModelInstanceSpec* instance_list; const char* sim_path; int mode_loopback; int [4] __reserved__; } Functions modelc_destroy Bypass the controller and call model_destroy() directly.</description></item><item><title>Schema API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/schema/</guid><description>Schema API The Schema API provides a number of functions for parsing the YAML configuration documents which represent (some of) the Schemas of the Model C Library.
Typedefs SchemaLabel typedef struct SchemaLabel { const char* name; const char* value; } SchemaObject typedef struct SchemaObject { const char* kind; const char* name; void* doc; void* data; } SchemaObjectSelector typedef struct SchemaObjectSelector { const char* kind; const char* name; SchemaLabel* labels; int labels_len; void* data; } SchemaSignalObject typedef struct SchemaSignalObject { const char* signal; void* data; } Functions schema_build_channel_selector Builds a channel selector object based on the provided Model Instance and Channel Spec.</description></item><item><title>Schema: SignalData</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/signaldata/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/signaldata/</guid><description>(v0.0.1)
SignalData Data = [[0..N],[0..N]] MsgPack encoded Signal Data. Number of elements in each nested array should be identical.
Properties oneOf
Name Type Required Description anonymous SignalUid false Signal UID. xor
Name Type Required Description anonymous SignalValueNumeric false Numeric signal value. The value may be encoded as any integer or float type. xor
Name Type Required Description anonymous SignalValueBinary false Binary signal value. SignalUid 0 Signal UID.
Properties Name Type Required Description anonymous integer(int32) false Signal UID.</description></item><item><title>Schema: SignalGroup</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/signalgroup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/signalgroup/</guid><description>(v0.0.1)
SignalGroup kind: SignalGroup metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: signals: - signal: string transform: linear: factor: 0 offset: 0 annotations: ? property1 ? property2 A signal group definition.
Properties Name Type Required Description kind string true none metadata object false Information relating to an object. » name string false The name of the object. » labels object false Identifying information used to identify objects within the system (e.</description></item><item><title>SimMock API Reference</title><link>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/apis/modelc/simmock/</guid><description>SimMock API The SimMock API provides interfaces for the development of CMocka Tests with a representative mocked implementation of the ModelC &amp;lt;-&amp;gt; SimBus interface. The mock supports a Signal Vector (scalar) and Network Vector (binary). Several models may be loaded into the SimMock.
Component Diagram @startuml simmock-objects title SimMock Objects package &amp;#34;SimBus Mock&amp;#34; { class Signal &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +double scalar[] +annotation() } class Network &amp;lt;&amp;lt;SignalVector&amp;gt;&amp;gt; { +uint32_t count +bool is_binary +void* binary[] #NCODEC* ncodec[] +annotation() +append() +reset() #codec() } file svSig [ signalgroup.</description></item><item><title>Testing Models with SimMock</title><link>https://boschglobal.github.io/dse.doc/docs/devel/testing/simmock/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/testing/simmock/</guid><description>SimMock and CMocka Testing for Model Developers The DSE ModelC Library includes a SimMock source code library which may be used to develop integration tests for Models. With the SimMock library, a Model Developer is able to easily develop CMocka Testcases which:
Validate a model configuration and confirm the Models operation. Develop scenarios where expected signal exchange is verified. Inject network messages into the simulation or model (e.g. CAN frames) and read network messages.</description></item><item><title>Schema: Simulation</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/simulation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/simulation/</guid><description>(v0.0.1)
Simulation kind: Simulation metadata: name: project annotations: input: somefile.json generator: parse2ast spec: simulation: arch: linux-amd64 channels: - name: physical - name: network networks: - name: CAN mime_type: application/x uses: - name: model.linear url: https://github.com/boschglobal/dse.fmi version: 1.1.15 path: model/linear/path vars: - name: enable value: true stacks: - name: stack_name stacked: true arch: linux-amd64 models: - name: linear model: model.linear channels: - name: physical alias: scalar env: - name: SIMBUS_LOGLEVEL value: 4 workflows: - name: generate-fmimcl vars: - name: FMU_DIR value: &amp;#34;{{.</description></item><item><title>Schema: Stack</title><link>https://boschglobal.github.io/dse.doc/schemas/yaml/stack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/schemas/yaml/stack/</guid><description>(v0.0.1)
Stack kind: Stack metadata: name: string labels: property1: string property2: string annotations: ? property1 ? property2 spec: connection: timeout: string transport: redis: uri: string timeout: 0 runtime: env: property1: string property2: string stacked: true models: - name: string uid: 0 annotations: ? property1 ? property2 model: name: string mcl: strategy: string models: - name: string runtime: env: property1: string property2: string files: - string x32: true i386: true channels: - name: string alias: string expectedModelCount: 0 selectors: property1: string property2: string annotations: ?</description></item><item><title>Testing with Testscript</title><link>https://boschglobal.github.io/dse.doc/docs/devel/testing/testscript/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://boschglobal.github.io/dse.doc/docs/devel/testing/testscript/</guid><description>Testscript for E2E Testing DSE Projects can use Testscript to run End-to-end tests (E2E) which are written in the (simple) txtar format. The containerised runtime supports both the Simer simulation runner as well as Taskfile based workflows.
Code Layout and Test Organisation L- tests/testscript Directory containing Testscript tests. L- e2e Collection of E2E tests. L- testcase.txtar Individual testcase (in txtar format). L- Makefile High-level build automation. Example Test Files tests/exec.txtar env NAME=minimal_inst env SIM=dse/modelc/build/_out/examples/minimal env SANDBOX=dse/modelc/build/_out # TEST: MStep executable exec sh -e $WORK/test.</description></item></channel></rss>